import { Type, Omit } from "../types";
import * as K from "./kinds";
export declare namespace namedTypes {
    interface Printable {
        loc?: K.SourceLocationKind | null;
    }
    interface SourceLocation {
        start: K.PositionKind;
        end: K.PositionKind;
        source?: string | null;
    }
    interface Node extends Printable {
        type: string;
        comments?: K.CommentKind[] | null;
    }
    interface Comment extends Printable {
        value: string;
        leading?: boolean;
        trailing?: boolean;
    }
    interface Position {
        line: number;
        column: number;
    }
    interface File extends Omit<Node, "type"> {
        type: "File";
        program: K.ProgramKind;
        name?: string | null;
    }
    interface Program extends Omit<Node, "type"> {
        type: "Program";
        body: K.StatementKind[];
        directives?: K.DirectiveKind[];
        interpreter?: K.InterpreterDirectiveKind | null;
    }
    interface Statement extends Node {
    }
    interface Function extends Node {
        id?: K.IdentifierKind | null;
        params: K.PatternKind[];
        body: K.BlockStatementKind;
        generator?: boolean;
        async?: boolean;
        expression?: boolean;
        defaults?: (K.ExpressionKind | null)[];
        rest?: K.IdentifierKind | null;
        returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        predicate?: K.FlowPredicateKind | null;
    }
    interface Expression extends Node {
    }
    interface Pattern extends Node {
    }
    interface Identifier extends Omit<Expression, "type">, Omit<Pattern, "type"> {
        type: "Identifier";
        name: string;
        optional?: boolean;
        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
    }
    interface BlockStatement extends Omit<Statement, "type"> {
        type: "BlockStatement";
        body: K.StatementKind[];
        directives?: K.DirectiveKind[];
    }
    interface EmptyStatement extends Omit<Statement, "type"> {
        type: "EmptyStatement";
    }
    interface ExpressionStatement extends Omit<Statement, "type"> {
        type: "ExpressionStatement";
        expression: K.ExpressionKind;
    }
    interface IfStatement extends Omit<Statement, "type"> {
        type: "IfStatement";
        test: K.ExpressionKind;
        consequent: K.StatementKind;
        alternate?: K.StatementKind | null;
    }
    interface LabeledStatement extends Omit<Statement, "type"> {
        type: "LabeledStatement";
        label: K.IdentifierKind;
        body: K.StatementKind;
    }
    interface BreakStatement extends Omit<Statement, "type"> {
        type: "BreakStatement";
        label?: K.IdentifierKind | null;
    }
    interface ContinueStatement extends Omit<Statement, "type"> {
        type: "ContinueStatement";
        label?: K.IdentifierKind | null;
    }
    interface WithStatement extends Omit<Statement, "type"> {
        type: "WithStatement";
        object: K.ExpressionKind;
        body: K.StatementKind;
    }
    interface SwitchStatement extends Omit<Statement, "type"> {
        type: "SwitchStatement";
        discriminant: K.ExpressionKind;
        cases: K.SwitchCaseKind[];
        lexical?: boolean;
    }
    interface SwitchCase extends Omit<Node, "type"> {
        type: "SwitchCase";
        test: K.ExpressionKind | null;
        consequent: K.StatementKind[];
    }
    interface ReturnStatement extends Omit<Statement, "type"> {
        type: "ReturnStatement";
        argument: K.ExpressionKind | null;
    }
    interface ThrowStatement extends Omit<Statement, "type"> {
        type: "ThrowStatement";
        argument: K.ExpressionKind;
    }
    interface TryStatement extends Omit<Statement, "type"> {
        type: "TryStatement";
        block: K.BlockStatementKind;
        handler?: K.CatchClauseKind | null;
        handlers?: K.CatchClauseKind[];
        guardedHandlers?: K.CatchClauseKind[];
        finalizer?: K.BlockStatementKind | null;
    }
    interface CatchClause extends Omit<Node, "type"> {
        type: "CatchClause";
        param?: K.PatternKind | null;
        guard?: K.ExpressionKind | null;
        body: K.BlockStatementKind;
    }
    interface WhileStatement extends Omit<Statement, "type"> {
        type: "WhileStatement";
        test: K.ExpressionKind;
        body: K.StatementKind;
    }
    interface DoWhileStatement extends Omit<Statement, "type"> {
        type: "DoWhileStatement";
        body: K.StatementKind;
        test: K.ExpressionKind;
    }
    interface ForStatement extends Omit<Statement, "type"> {
        type: "ForStatement";
        init: K.VariableDeclarationKind | K.ExpressionKind | null;
        test: K.ExpressionKind | null;
        update: K.ExpressionKind | null;
        body: K.StatementKind;
    }
    interface Declaration extends Statement {
    }
    interface VariableDeclaration extends Omit<Declaration, "type"> {
        type: "VariableDeclaration";
        kind: "var" | "let" | "const";
        declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[];
    }
    interface ForInStatement extends Omit<Statement, "type"> {
        type: "ForInStatement";
        left: K.VariableDeclarationKind | K.ExpressionKind;
        right: K.ExpressionKind;
        body: K.StatementKind;
    }
    interface DebuggerStatement extends Omit<Statement, "type"> {
        type: "DebuggerStatement";
    }
    interface FunctionDeclaration extends Omit<Function, "type" | "id">, Omit<Declaration, "type"> {
        type: "FunctionDeclaration";
        id: K.IdentifierKind | null;
    }
    interface FunctionExpression extends Omit<Function, "type">, Omit<Expression, "type"> {
        type: "FunctionExpression";
    }
    interface VariableDeclarator extends Omit<Node, "type"> {
        type: "VariableDeclarator";
        id: K.PatternKind;
        init?: K.ExpressionKind | null;
    }
    interface ThisExpression extends Omit<Expression, "type"> {
        type: "ThisExpression";
    }
    interface ArrayExpression extends Omit<Expression, "type"> {
        type: "ArrayExpression";
        elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[];
    }
    interface ObjectExpression extends Omit<Expression, "type"> {
        type: "ObjectExpression";
        properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[];
    }
    interface Property extends Omit<Node, "type"> {
        type: "Property";
        kind: "init" | "get" | "set";
        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
        value: K.ExpressionKind | K.PatternKind;
        method?: boolean;
        shorthand?: boolean;
        computed?: boolean;
        decorators?: K.DecoratorKind[] | null;
    }
    interface Literal extends Omit<Expression, "type"> {
        type: "Literal";
        value: string | boolean | null | number | RegExp | BigInt;
    }
    interface SequenceExpression extends Omit<Expression, "type"> {
        type: "SequenceExpression";
        expressions: K.ExpressionKind[];
    }
    interface UnaryExpression extends Omit<Expression, "type"> {
        type: "UnaryExpression";
        operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
        argument: K.ExpressionKind;
        prefix?: boolean;
    }
    interface BinaryExpression extends Omit<Expression, "type"> {
        type: "BinaryExpression";
        operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "in" | "instanceof" | "**";
        left: K.ExpressionKind;
        right: K.ExpressionKind;
    }
    interface AssignmentExpression extends Omit<Expression, "type"> {
        type: "AssignmentExpression";
        operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**=" | "||=" | "&&=" | "??=";
        left: K.PatternKind | K.MemberExpressionKind;
        right: K.ExpressionKind;
    }
    interface ChainElement extends Node {
        optional?: boolean;
    }
    interface MemberExpression extends Omit<Expression, "type">, Omit<ChainElement, "type"> {
        type: "MemberExpression";
        object: K.ExpressionKind;
        property: K.IdentifierKind | K.ExpressionKind;
        computed?: boolean;
    }
    interface UpdateExpression extends Omit<Expression, "type"> {
        type: "UpdateExpression";
        operator: "++" | "--";
        argument: K.ExpressionKind;
        prefix: boolean;
    }
    interface LogicalExpression extends Omit<Expression, "type"> {
        type: "LogicalExpression";
        operator: "||" | "&&" | "??";
        left: K.ExpressionKind;
        right: K.ExpressionKind;
    }
    interface ConditionalExpression extends Omit<Expression, "type"> {
        type: "ConditionalExpression";
        test: K.ExpressionKind;
        consequent: K.ExpressionKind;
        alternate: K.ExpressionKind;
    }
    interface NewExpression extends Omit<Expression, "type"> {
        type: "NewExpression";
        callee: K.ExpressionKind;
        arguments: (K.ExpressionKind | K.SpreadElementKind)[];
        typeArguments?: null | K.TypeParameterInstantiationKind;
    }
    interface CallExpression extends Omit<Expression, "type">, Omit<ChainElement, "type"> {
        type: "CallExpression";
        callee: K.ExpressionKind;
        arguments: (K.ExpressionKind | K.SpreadElementKind)[];
        typeArguments?: null | K.TypeParameterInstantiationKind;
    }
    interface RestElement extends Omit<Pattern, "type"> {
        type: "RestElement";
        argument: K.PatternKind;
        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
    }
    interface TypeAnnotation extends Omit<Node, "type"> {
        type: "TypeAnnotation";
        typeAnnotation: K.FlowTypeKind;
    }
    interface TSTypeAnnotation extends Omit<Node, "type"> {
        type: "TSTypeAnnotation";
        typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind;
    }
    interface SpreadElementPattern extends Omit<Pattern, "type"> {
        type: "SpreadElementPattern";
        argument: K.PatternKind;
    }
    interface ArrowFunctionExpression extends Omit<Function, "type" | "id" | "body" | "generator">, Omit<Expression, "type"> {
        type: "ArrowFunctionExpression";
        id?: null;
        body: K.BlockStatementKind | K.ExpressionKind;
        generator?: false;
    }
    interface ForOfStatement extends Omit<Statement, "type"> {
        type: "ForOfStatement";
        left: K.VariableDeclarationKind | K.PatternKind;
        right: K.ExpressionKind;
        body: K.StatementKind;
        await?: boolean;
    }
    interface YieldExpression extends Omit<Expression, "type"> {
        type: "YieldExpression";
        argument: K.ExpressionKind | null;
        delegate?: boolean;
    }
    interface GeneratorExpression extends Omit<Expression, "type"> {
        type: "GeneratorExpression";
        body: K.ExpressionKind;
        blocks: K.ComprehensionBlockKind[];
        filter: K.ExpressionKind | null;
    }
    interface ComprehensionBlock extends Omit<Node, "type"> {
        type: "ComprehensionBlock";
        left: K.PatternKind;
        right: K.ExpressionKind;
        each: boolean;
    }
    interface ComprehensionExpression extends Omit<Expression, "type"> {
        type: "ComprehensionExpression";
        body: K.ExpressionKind;
        blocks: K.ComprehensionBlockKind[];
        filter: K.ExpressionKind | null;
    }
    interface ObjectProperty extends Omit<Node, "type"> {
        shorthand?: boolean;
        type: "ObjectProperty";
        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
        value: K.ExpressionKind | K.PatternKind;
        accessibility?: K.LiteralKind | null;
        computed?: boolean;
    }
    interface PropertyPattern extends Omit<Pattern, "type"> {
        type: "PropertyPattern";
        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
        pattern: K.PatternKind;
        computed?: boolean;
    }
    interface ObjectPattern extends Omit<Pattern, "type"> {
        type: "ObjectPattern";
        properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind | K.RestElementKind)[];
        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        decorators?: K.DecoratorKind[] | null;
    }
    interface ArrayPattern extends Omit<Pattern, "type"> {
        type: "ArrayPattern";
        elements: (K.PatternKind | K.SpreadElementKind | null)[];
    }
    interface SpreadElement extends Omit<Node, "type"> {
        type: "SpreadElement";
        argument: K.ExpressionKind;
    }
    interface AssignmentPattern extends Omit<Pattern, "type"> {
        type: "AssignmentPattern";
        left: K.PatternKind;
        right: K.ExpressionKind;
    }
    interface MethodDefinition extends Omit<Declaration, "type"> {
        type: "MethodDefinition";
        kind: "constructor" | "method" | "get" | "set";
        key: K.ExpressionKind;
        value: K.FunctionKind;
        computed?: boolean;
        static?: boolean;
        decorators?: K.DecoratorKind[] | null;
    }
    interface ClassPropertyDefinition extends Omit<Declaration, "type"> {
        type: "ClassPropertyDefinition";
        definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.StaticBlockKind;
    }
    interface ClassProperty extends Omit<Declaration, "type"> {
        type: "ClassProperty";
        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
        computed?: boolean;
        value: K.ExpressionKind | null;
        static?: boolean;
        typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
        variance?: K.VarianceKind | "plus" | "minus" | null;
        access?: "public" | "private" | "protected" | undefined;
    }
    interface StaticBlock extends Omit<Declaration, "type"> {
        type: "StaticBlock";
        body: K.StatementKind[];
    }
    interface ClassBody extends Omit<Declaration, "type"> {
        type: "ClassBody";
        body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassPrivatePropertyKind | K.ClassAccessorPropertyKind | K.ClassMethodKind | K.ClassPrivateMethodKind | K.StaticBlockKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
    }
    interface ClassDeclaration extends Omit<Declaration, "type"> {
        type: "ClassDeclaration";
        id: K.IdentifierKind | null;
        body: K.ClassBodyKind;
        superClass?: K.ExpressionKind | null;
        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
        implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
    }
    interface ClassExpression extends Omit<Expression, "type"> {
        type: "ClassExpression";
        id?: K.IdentifierKind | null;
        body: K.ClassBodyKind;
        superClass?: K.ExpressionKind | null;
        typeParameters?: K.TypeParameterDeclarationKind | K.TSTypeParameterDeclarationKind | null;
        superTypeParameters?: K.TypeParameterInstantiationKind | K.TSTypeParameterInstantiationKind | null;
        implements?: K.ClassImplementsKind[] | K.TSExpressionWithTypeArgumentsKind[];
    }
    interface Super extends Omit<Expression, "type"> {
        type: "Super";
    }
    interface Specifier extends Node {
    }
    interface ModuleSpecifier extends Specifier {
        local?: K.IdentifierKind | null;
        id?: K.IdentifierKind | null;
        name?: K.IdentifierKind | null;
    }
    interface ImportSpecifier extends Omit<ModuleSpecifier, "type"> {
        type: "ImportSpecifier";
        imported: K.IdentifierKind;
    }
    interface ImportDefaultSpecifier extends Omit<ModuleSpecifier, "type"> {
        type: "ImportDefaultSpecifier";
    }
    interface ImportNamespaceSpecifier extends Omit<ModuleSpecifier, "type"> {
        type: "ImportNamespaceSpecifier";
    }
    interface ImportDeclaration extends Omit<Declaration, "type"> {
        type: "ImportDeclaration";
        specifiers?: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[];
        source: K.LiteralKind;
        importKind?: "value" | "type" | "typeof";
        assertions?: K.ImportAttributeKind[];
    }
    interface ExportNamedDeclaration extends Omit<Declaration, "type"> {
        type: "ExportNamedDeclaration";
        declaration: K.DeclarationKind | null;
        specifiers?: K.ExportSpecifierKind[];
        source?: K.LiteralKind | null;
        assertions?: K.ImportAttributeKind[];
    }
    interface ExportSpecifier extends Omit<ModuleSpecifier, "type"> {
        type: "ExportSpecifier";
        exported: K.IdentifierKind;
    }
    interface ExportDefaultDeclaration extends Omit<Declaration, "type"> {
        type: "ExportDefaultDeclaration";
        declaration: K.DeclarationKind | K.ExpressionKind;
    }
    interface ExportAllDeclaration extends Omit<Declaration, "type"> {
        type: "ExportAllDeclaration";
        source: K.LiteralKind;
        exported?: K.IdentifierKind | null | undefined;
        assertions?: K.ImportAttributeKind[];
    }
    interface TaggedTemplateExpression extends Omit<Expression, "type"> {
        type: "TaggedTemplateExpression";
        tag: K.ExpressionKind;
        quasi: K.TemplateLiteralKind;
    }
    interface TemplateLiteral extends Omit<Expression, "type"> {
        type: "TemplateLiteral";
        quasis: K.TemplateElementKind[];
        expressions: K.ExpressionKind[] | K.TSTypeKind[];
    }
    interface TemplateElement extends Omit<Node, "type"> {
        type: "TemplateElement";
        value: {
            cooked: string | null;
            raw: string;
        };
        tail: boolean;
    }
    interface MetaProperty extends Omit<Expression, "type"> {
        type: "MetaProperty";
        meta: K.IdentifierKind;
        property: K.IdentifierKind;
    }
    interface AwaitExpression extends Omit<Expression, "type"> {
        type: "AwaitExpression";
        argument: K.ExpressionKind | null;
        all?: boolean;
    }
    interface SpreadProperty extends Omit<Node, "type"> {
        type: "SpreadProperty";
        argument: K.ExpressionKind;
    }
    interface SpreadPropertyPattern extends Omit<Pattern, "type"> {
        type: "SpreadPropertyPattern";
        argument: K.PatternKind;
    }
    interface ImportExpression extends Omit<Expression, "type"> {
        type: "ImportExpression";
        source: K.ExpressionKind;
    }
    interface ChainExpression extends Omit<Expression, "type"> {
        type: "ChainExpression";
        expression: K.ChainElementKind;
    }
    interface OptionalCallExpression extends Omit<CallExpression, "type" | "optional"> {
        type: "OptionalCallExpression";
        optional?: boolean;
    }
    interface OptionalMemberExpression extends Omit<MemberExpression, "type" | "optional"> {
        type: "OptionalMemberExpression";
        optional?: boolean;
    }
    interface Decorator extends Omit<Node, "type"> {
        type: "Decorator";
        expression: K.ExpressionKind;
    }
    interface PrivateName extends Omit<Expression, "type">, Omit<Pattern, "type"> {
        type: "PrivateName";
        id: K.IdentifierKind;
    }
    interface ClassPrivateProperty extends Omit<ClassProperty, "type" | "key" | "value"> {
        type: "ClassPrivateProperty";
        key: K.PrivateNameKind;
        value?: K.ExpressionKind | null;
    }
    interface ImportAttribute extends Omit<Node, "type"> {
        type: "ImportAttribute";
        key: K.IdentifierKind | K.LiteralKind;
        value: K.ExpressionKind;
    }
    interface RecordExpression extends Omit<Expression, "type"> {
        type: "RecordExpression";
        properties: (K.ObjectPropertyKind | K.ObjectMethodKind | K.SpreadElementKind)[];
    }
    interface ObjectMethod extends Omit<Node, "type">, Omit<Function, "type" | "params" | "body" | "generator" | "async"> {
        type: "ObjectMethod";
        kind: "method" | "get" | "set";
        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
        params: K.PatternKind[];
        body: K.BlockStatementKind;
        computed?: boolean;
        generator?: boolean;
        async?: boolean;
        accessibility?: K.LiteralKind | null;
        decorators?: K.DecoratorKind[] | null;
    }
    interface TupleExpression extends Omit<Expression, "type"> {
        type: "TupleExpression";
        elements: (K.ExpressionKind | K.SpreadElementKind | null)[];
    }
    interface ModuleExpression extends Omit<Node, "type"> {
        type: "ModuleExpression";
        body: K.ProgramKind;
    }
    interface JSXAttribute extends Omit<Node, "type"> {
        type: "JSXAttribute";
        name: K.JSXIdentifierKind | K.JSXNamespacedNameKind;
        value?: K.LiteralKind | K.JSXExpressionContainerKind | K.JSXElementKind | K.JSXFragmentKind | null;
    }
    interface JSXIdentifier extends Omit<Identifier, "type" | "name"> {
        type: "JSXIdentifier";
        name: string;
    }
    interface JSXNamespacedName extends Omit<Node, "type"> {
        type: "JSXNamespacedName";
        namespace: K.JSXIdentifierKind;
        name: K.JSXIdentifierKind;
    }
    interface JSXExpressionContainer extends Omit<Expression, "type"> {
        type: "JSXExpressionContainer";
        expression: K.ExpressionKind | K.JSXEmptyExpressionKind;
    }
    interface JSXElement extends Omit<Expression, "type"> {
        type: "JSXElement";
        openingElement: K.JSXOpeningElementKind;
        closingElement?: K.JSXClosingElementKind | null;
        children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
        name?: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
        selfClosing?: boolean;
        attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
    }
    interface JSXFragment extends Omit<Expression, "type"> {
        type: "JSXFragment";
        openingFragment: K.JSXOpeningFragmentKind;
        closingFragment: K.JSXClosingFragmentKind;
        children?: (K.JSXTextKind | K.JSXExpressionContainerKind | K.JSXSpreadChildKind | K.JSXElementKind | K.JSXFragmentKind | K.LiteralKind)[];
    }
    interface JSXMemberExpression extends Omit<MemberExpression, "type" | "object" | "property" | "computed"> {
        type: "JSXMemberExpression";
        object: K.JSXIdentifierKind | K.JSXMemberExpressionKind;
        property: K.JSXIdentifierKind;
        computed?: boolean;
    }
    interface JSXSpreadAttribute extends Omit<Node, "type"> {
        type: "JSXSpreadAttribute";
        argument: K.ExpressionKind;
    }
    interface JSXEmptyExpression extends Omit<Node, "type"> {
        type: "JSXEmptyExpression";
    }
    interface JSXText extends Omit<Literal, "type" | "value"> {
        type: "JSXText";
        value: string;
        raw?: string;
    }
    interface JSXSpreadChild extends Omit<Node, "type"> {
        type: "JSXSpreadChild";
        expression: K.ExpressionKind;
    }
    interface JSXOpeningElement extends Omit<Node, "type"> {
        type: "JSXOpeningElement";
        name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
        attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
        selfClosing?: boolean;
    }
    interface JSXClosingElement extends Omit<Node, "type"> {
        type: "JSXClosingElement";
        name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
    }
    interface JSXOpeningFragment extends Omit<Node, "type"> {
        type: "JSXOpeningFragment";
    }
    interface JSXClosingFragment extends Omit<Node, "type"> {
        type: "JSXClosingFragment";
    }
    interface TypeParameterDeclaration extends Omit<Node, "type"> {
        type: "TypeParameterDeclaration";
        params: K.TypeParameterKind[];
    }
    interface TSTypeParameterDeclaration extends Omit<Declaration, "type"> {
        type: "TSTypeParameterDeclaration";
        params: K.TSTypeParameterKind[];
    }
    interface TypeParameterInstantiation extends Omit<Node, "type"> {
        type: "TypeParameterInstantiation";
        params: K.FlowTypeKind[];
    }
    interface TSTypeParameterInstantiation extends Omit<Node, "type"> {
        type: "TSTypeParameterInstantiation";
        params: K.TSTypeKind[];
    }
    interface ClassImplements extends Omit<Node, "type"> {
        type: "ClassImplements";
        id: K.IdentifierKind;
        superClass?: K.ExpressionKind | null;
        typeParameters?: K.TypeParameterInstantiationKind | null;
    }
    interface TSType extends Node {
    }
    interface TSHasOptionalTypeParameterInstantiation {
        typeParameters?: K.TSTypeParameterInstantiationKind | null;
    }
    interface TSExpressionWithTypeArguments extends Omit<TSType, "type">, TSHasOptionalTypeParameterInstantiation {
        type: "TSExpressionWithTypeArguments";
        expression: K.IdentifierKind | K.TSQualifiedNameKind;
    }
    interface Flow extends Node {
    }
    interface FlowType extends Flow {
    }
    interface AnyTypeAnnotation extends Omit<FlowType, "type"> {
        type: "AnyTypeAnnotation";
    }
    interface EmptyTypeAnnotation extends Omit<FlowType, "type"> {
        type: "EmptyTypeAnnotation";
    }
    interface MixedTypeAnnotation extends Omit<FlowType, "type"> {
        type: "MixedTypeAnnotation";
    }
    interface VoidTypeAnnotation extends Omit<FlowType, "type"> {
        type: "VoidTypeAnnotation";
    }
    interface SymbolTypeAnnotation extends Omit<FlowType, "type"> {
        type: "SymbolTypeAnnotation";
    }
    interface NumberTypeAnnotation extends Omit<FlowType, "type"> {
        type: "NumberTypeAnnotation";
    }
    interface BigIntTypeAnnotation extends Omit<FlowType, "type"> {
        type: "BigIntTypeAnnotation";
    }
    interface NumberLiteralTypeAnnotation extends Omit<FlowType, "type"> {
        type: "NumberLiteralTypeAnnotation";
        value: number;
        raw: string;
    }
    interface NumericLiteralTypeAnnotation extends Omit<FlowType, "type"> {
        type: "NumericLiteralTypeAnnotation";
        value: number;
        raw: string;
    }
    interface BigIntLiteralTypeAnnotation extends Omit<FlowType, "type"> {
        type: "BigIntLiteralTypeAnnotation";
        value: null;
        raw: string;
    }
    interface StringTypeAnnotation extends Omit<FlowType, "type"> {
        type: "StringTypeAnnotation";
    }
    interface StringLiteralTypeAnnotation extends Omit<FlowType, "type"> {
        type: "StringLiteralTypeAnnotation";
        value: string;
        raw: string;
    }
    interface BooleanTypeAnnotation extends Omit<FlowType, "type"> {
        type: "BooleanTypeAnnotation";
    }
    interface BooleanLiteralTypeAnnotation extends Omit<FlowType, "type"> {
        type: "BooleanLiteralTypeAnnotation";
        value: boolean;
        raw: string;
    }
    interface NullableTypeAnnotation extends Omit<FlowType, "type"> {
        type: "NullableTypeAnnotation";
        typeAnnotation: K.FlowTypeKind;
    }
    interface NullLiteralTypeAnnotation extends Omit<FlowType, "type"> {
        type: "NullLiteralTypeAnnotation";
    }
    interface NullTypeAnnotation extends Omit<FlowType, "type"> {
        type: "NullTypeAnnotation";
    }
    interface ThisTypeAnnotation extends Omit<FlowType, "type"> {
        type: "ThisTypeAnnotation";
    }
    interface ExistsTypeAnnotation extends Omit<FlowType, "type"> {
        type: "ExistsTypeAnnotation";
    }
    interface ExistentialTypeParam extends Omit<FlowType, "type"> {
        type: "ExistentialTypeParam";
    }
    interface FunctionTypeAnnotation extends Omit<FlowType, "type"> {
        type: "FunctionTypeAnnotation";
        params: K.FunctionTypeParamKind[];
        returnType: K.FlowTypeKind;
        rest: K.FunctionTypeParamKind | null;
        typeParameters: K.TypeParameterDeclarationKind | null;
    }
    interface FunctionTypeParam extends Omit<Node, "type"> {
        type: "FunctionTypeParam";
        name: K.IdentifierKind | null;
        typeAnnotation: K.FlowTypeKind;
        optional: boolean;
    }
    interface ArrayTypeAnnotation extends Omit<FlowType, "type"> {
        type: "ArrayTypeAnnotation";
        elementType: K.FlowTypeKind;
    }
    interface ObjectTypeAnnotation extends Omit<FlowType, "type"> {
        type: "ObjectTypeAnnotation";
        properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[];
        indexers?: K.ObjectTypeIndexerKind[];
        callProperties?: K.ObjectTypeCallPropertyKind[];
        inexact?: boolean | undefined;
        exact?: boolean;
        internalSlots?: K.ObjectTypeInternalSlotKind[];
    }
    interface ObjectTypeProperty extends Omit<Node, "type"> {
        type: "ObjectTypeProperty";
        key: K.LiteralKind | K.IdentifierKind;
        value: K.FlowTypeKind;
        optional: boolean;
        variance?: K.VarianceKind | "plus" | "minus" | null;
    }
    interface ObjectTypeSpreadProperty extends Omit<Node, "type"> {
        type: "ObjectTypeSpreadProperty";
        argument: K.FlowTypeKind;
    }
    interface ObjectTypeIndexer extends Omit<Node, "type"> {
        type: "ObjectTypeIndexer";
        id: K.IdentifierKind;
        key: K.FlowTypeKind;
        value: K.FlowTypeKind;
        variance?: K.VarianceKind | "plus" | "minus" | null;
        static?: boolean;
    }
    interface ObjectTypeCallProperty extends Omit<Node, "type"> {
        type: "ObjectTypeCallProperty";
        value: K.FunctionTypeAnnotationKind;
        static?: boolean;
    }
    interface ObjectTypeInternalSlot extends Omit<Node, "type"> {
        type: "ObjectTypeInternalSlot";
        id: K.IdentifierKind;
        value: K.FlowTypeKind;
        optional: boolean;
        static: boolean;
        method: boolean;
    }
    interface Variance extends Omit<Node, "type"> {
        type: "Variance";
        kind: "plus" | "minus";
    }
    interface QualifiedTypeIdentifier extends Omit<Node, "type"> {
        type: "QualifiedTypeIdentifier";
        qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
        id: K.IdentifierKind;
    }
    interface GenericTypeAnnotation extends Omit<FlowType, "type"> {
        type: "GenericTypeAnnotation";
        id: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
        typeParameters: K.TypeParameterInstantiationKind | null;
    }
    interface MemberTypeAnnotation extends Omit<FlowType, "type"> {
        type: "MemberTypeAnnotation";
        object: K.IdentifierKind;
        property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind;
    }
    interface IndexedAccessType extends Omit<FlowType, "type"> {
        type: "IndexedAccessType";
        objectType: K.FlowTypeKind;
        indexType: K.FlowTypeKind;
    }
    interface OptionalIndexedAccessType extends Omit<FlowType, "type"> {
        type: "OptionalIndexedAccessType";
        objectType: K.FlowTypeKind;
        indexType: K.FlowTypeKind;
        optional: boolean;
    }
    interface UnionTypeAnnotation extends Omit<FlowType, "type"> {
        type: "UnionTypeAnnotation";
        types: K.FlowTypeKind[];
    }
    interface IntersectionTypeAnnotation extends Omit<FlowType, "type"> {
        type: "IntersectionTypeAnnotation";
        types: K.FlowTypeKind[];
    }
    interface TypeofTypeAnnotation extends Omit<FlowType, "type"> {
        type: "TypeofTypeAnnotation";
        argument: K.FlowTypeKind;
    }
    interface TypeParameter extends Omit<FlowType, "type"> {
        type: "TypeParameter";
        name: string;
        variance?: K.VarianceKind | "plus" | "minus" | null;
        bound?: K.TypeAnnotationKind | null;
        default?: K.FlowTypeKind | null;
    }
    interface InterfaceTypeAnnotation extends Omit<FlowType, "type"> {
        type: "InterfaceTypeAnnotation";
        body: K.ObjectTypeAnnotationKind;
        extends?: K.InterfaceExtendsKind[] | null;
    }
    interface InterfaceExtends extends Omit<Node, "type"> {
        type: "InterfaceExtends";
        id: K.IdentifierKind;
        typeParameters?: K.TypeParameterInstantiationKind | null;
    }
    interface InterfaceDeclaration extends Omit<Declaration, "type"> {
        type: "InterfaceDeclaration";
        id: K.IdentifierKind;
        typeParameters?: K.TypeParameterDeclarationKind | null;
        body: K.ObjectTypeAnnotationKind;
        extends: K.InterfaceExtendsKind[];
    }
    interface DeclareInterface extends Omit<InterfaceDeclaration, "type"> {
        type: "DeclareInterface";
    }
    interface TypeAlias extends Omit<Declaration, "type"> {
        type: "TypeAlias";
        id: K.IdentifierKind;
        typeParameters: K.TypeParameterDeclarationKind | null;
        right: K.FlowTypeKind;
    }
    interface DeclareTypeAlias extends Omit<TypeAlias, "type"> {
        type: "DeclareTypeAlias";
    }
    interface OpaqueType extends Omit<Declaration, "type"> {
        type: "OpaqueType";
        id: K.IdentifierKind;
        typeParameters: K.TypeParameterDeclarationKind | null;
        impltype: K.FlowTypeKind;
        supertype: K.FlowTypeKind | null;
    }
    interface DeclareOpaqueType extends Omit<OpaqueType, "type" | "impltype"> {
        type: "DeclareOpaqueType";
        impltype: K.FlowTypeKind | null;
    }
    interface TypeCastExpression extends Omit<Expression, "type"> {
        type: "TypeCastExpression";
        expression: K.ExpressionKind;
        typeAnnotation: K.TypeAnnotationKind;
    }
    interface TupleTypeAnnotation extends Omit<FlowType, "type"> {
        type: "TupleTypeAnnotation";
        types: K.FlowTypeKind[];
    }
    interface DeclareVariable extends Omit<Statement, "type"> {
        type: "DeclareVariable";
        id: K.IdentifierKind;
    }
    interface DeclareFunction extends Omit<Statement, "type"> {
        type: "DeclareFunction";
        id: K.IdentifierKind;
        predicate?: K.FlowPredicateKind | null;
    }
    interface FlowPredicate extends Flow {
    }
    interface DeclareClass extends Omit<InterfaceDeclaration, "type"> {
        type: "DeclareClass";
    }
    interface DeclareModule extends Omit<Statement, "type"> {
        type: "DeclareModule";
        id: K.IdentifierKind | K.LiteralKind;
        body: K.BlockStatementKind;
    }
    interface DeclareModuleExports extends Omit<Statement, "type"> {
        type: "DeclareModuleExports";
        typeAnnotation: K.TypeAnnotationKind;
    }
    interface DeclareExportDeclaration extends Omit<Declaration, "type"> {
        type: "DeclareExportDeclaration";
        default: boolean;
        declaration: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | K.TypeAliasKind | K.DeclareOpaqueTypeKind | K.InterfaceDeclarationKind | null;
        specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
        source?: K.LiteralKind | null;
    }
    interface ExportBatchSpecifier extends Omit<Specifier, "type"> {
        type: "ExportBatchSpecifier";
    }
    interface DeclareExportAllDeclaration extends Omit<Declaration, "type"> {
        type: "DeclareExportAllDeclaration";
        source?: K.LiteralKind | null;
    }
    interface InferredPredicate extends Omit<FlowPredicate, "type"> {
        type: "InferredPredicate";
    }
    interface DeclaredPredicate extends Omit<FlowPredicate, "type"> {
        type: "DeclaredPredicate";
        value: K.ExpressionKind;
    }
    interface EnumDeclaration extends Omit<Declaration, "type"> {
        type: "EnumDeclaration";
        id: K.IdentifierKind;
        body: K.EnumBooleanBodyKind | K.EnumNumberBodyKind | K.EnumStringBodyKind | K.EnumSymbolBodyKind;
    }
    interface EnumBooleanBody {
        type: "EnumBooleanBody";
        members: K.EnumBooleanMemberKind[];
        explicitType: boolean;
    }
    interface EnumNumberBody {
        type: "EnumNumberBody";
        members: K.EnumNumberMemberKind[];
        explicitType: boolean;
    }
    interface EnumStringBody {
        type: "EnumStringBody";
        members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[];
        explicitType: boolean;
    }
    interface EnumSymbolBody {
        type: "EnumSymbolBody";
        members: K.EnumDefaultedMemberKind[];
    }
    interface EnumBooleanMember {
        type: "EnumBooleanMember";
        id: K.IdentifierKind;
        init: K.LiteralKind | boolean;
    }
    interface EnumNumberMember {
        type: "EnumNumberMember";
        id: K.IdentifierKind;
        init: K.LiteralKind;
    }
    interface EnumStringMember {
        type: "EnumStringMember";
        id: K.IdentifierKind;
        init: K.LiteralKind;
    }
    interface EnumDefaultedMember {
        type: "EnumDefaultedMember";
        id: K.IdentifierKind;
    }
    interface ExportDeclaration extends Omit<Declaration, "type"> {
        type: "ExportDeclaration";
        default: boolean;
        declaration: K.DeclarationKind | K.ExpressionKind | null;
        specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
        source?: K.LiteralKind | null;
    }
    interface Block extends Comment {
        type: "Block";
    }
    interface Line extends Comment {
        type: "Line";
    }
    interface Noop extends Omit<Statement, "type"> {
        type: "Noop";
    }
    interface DoExpression extends Omit<Expression, "type"> {
        type: "DoExpression";
        body: K.StatementKind[];
    }
    interface BindExpression extends Omit<Expression, "type"> {
        type: "BindExpression";
        object: K.ExpressionKind | null;
        callee: K.ExpressionKind;
    }
    interface ParenthesizedExpression extends Omit<Expression, "type"> {
        type: "ParenthesizedExpression";
        expression: K.ExpressionKind;
    }
    interface ExportNamespaceSpecifier extends Omit<Specifier, "type"> {
        type: "ExportNamespaceSpecifier";
        exported: K.IdentifierKind;
    }
    interface ExportDefaultSpecifier extends Omit<Specifier, "type"> {
        type: "ExportDefaultSpecifier";
        exported: K.IdentifierKind;
    }
    interface CommentBlock extends Comment {
        type: "CommentBlock";
    }
    interface CommentLine extends Comment {
        type: "CommentLine";
    }
    interface Directive extends Omit<Node, "type"> {
        type: "Directive";
        value: K.DirectiveLiteralKind;
    }
    interface DirectiveLiteral extends Omit<Node, "type">, Omit<Expression, "type"> {
        type: "DirectiveLiteral";
        value?: string;
    }
    interface InterpreterDirective extends Omit<Node, "type"> {
        type: "InterpreterDirective";
        value: string;
    }
    interface StringLiteral extends Omit<Literal, "type" | "value"> {
        type: "StringLiteral";
        value: string;
        extra?: {
            rawValue: string;
            raw: string;
        };
    }
    interface NumericLiteral extends Omit<Literal, "type" | "value"> {
        type: "NumericLiteral";
        value: number;
        raw?: string | null;
        extra?: {
            rawValue: number;
            raw: string;
        };
    }
    interface BigIntLiteral extends Omit<Literal, "type" | "value"> {
        type: "BigIntLiteral";
        value: string | number;
        extra?: {
            rawValue: string;
            raw: string;
        };
    }
    interface DecimalLiteral extends Omit<Literal, "type" | "value"> {
        type: "DecimalLiteral";
        value: string;
        extra?: {
            rawValue: string;
            raw: string;
        };
    }
    interface NullLiteral extends Omit<Literal, "type" | "value"> {
        type: "NullLiteral";
        value?: null;
    }
    interface BooleanLiteral extends Omit<Literal, "type" | "value"> {
        type: "BooleanLiteral";
        value: boolean;
    }
    interface RegExpLiteral extends Omit<Literal, "type" | "value"> {
        type: "RegExpLiteral";
        pattern: string;
        flags: string;
        value?: RegExp;
        extra?: {
            rawValue: RegExp | undefined;
            raw: string;
        };
        regex?: {
            pattern: string;
            flags: string;
        };
    }
    interface ClassMethod extends Omit<Declaration, "type">, Omit<Function, "type" | "body"> {
        type: "ClassMethod";
        key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
        kind?: "get" | "set" | "method" | "constructor";
        body: K.BlockStatementKind;
        access?: "public" | "private" | "protected" | null;
        computed?: boolean;
        static?: boolean;
        abstract?: boolean;
        accessibility?: "public" | "private" | "protected" | null;
        decorators?: K.DecoratorKind[] | null;
        definite?: boolean;
        optional?: boolean;
        override?: boolean;
        readonly?: boolean;
    }
    interface ClassPrivateMethod extends Omit<Declaration, "type">, Omit<Function, "type" | "body"> {
        type: "ClassPrivateMethod";
        key: K.PrivateNameKind;
        kind?: "get" | "set" | "method" | "constructor";
        body: K.BlockStatementKind;
        access?: "public" | "private" | "protected" | null;
        computed?: boolean;
        static?: boolean;
        abstract?: boolean;
        accessibility?: "public" | "private" | "protected" | null;
        decorators?: K.DecoratorKind[] | null;
        definite?: boolean;
        optional?: boolean;
        override?: boolean;
        readonly?: boolean;
    }
    interface TSHasOptionalTypeAnnotation {
        typeAnnotation?: K.TSTypeAnnotationKind | null;
    }
    interface ClassAccessorProperty extends Omit<Declaration, "type">, TSHasOptionalTypeAnnotation {
        type: "ClassAccessorProperty";
        key: K.LiteralKind | K.IdentifierKind | K.PrivateNameKind | K.ExpressionKind;
        value?: K.ExpressionKind | null;
        computed?: boolean;
        static?: boolean;
        abstract?: boolean;
        accessibility?: "public" | "private" | "protected" | null;
        decorators?: K.DecoratorKind[] | null;
        definite?: boolean;
        optional?: boolean;
        override?: boolean;
        readonly?: boolean;
    }
    interface RestProperty extends Omit<Node, "type"> {
        type: "RestProperty";
        argument: K.ExpressionKind;
    }
    interface ForAwaitStatement extends Omit<Statement, "type"> {
        type: "ForAwaitStatement";
        left: K.VariableDeclarationKind | K.ExpressionKind;
        right: K.ExpressionKind;
        body: K.StatementKind;
    }
    interface Import extends Omit<Expression, "type"> {
        type: "Import";
    }
    interface V8IntrinsicIdentifier extends Omit<Expression, "type"> {
        type: "V8IntrinsicIdentifier";
        name: string;
    }
    interface TopicReference extends Omit<Expression, "type"> {
        type: "TopicReference";
    }
    interface TSQualifiedName extends Omit<Node, "type"> {
        type: "TSQualifiedName";
        left: K.IdentifierKind | K.TSQualifiedNameKind;
        right: K.IdentifierKind | K.TSQualifiedNameKind;
    }
    interface TSTypeReference extends Omit<TSType, "type">, TSHasOptionalTypeParameterInstantiation {
        type: "TSTypeReference";
        typeName: K.IdentifierKind | K.TSQualifiedNameKind;
    }
    interface TSHasOptionalTypeParameters {
        typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
    }
    interface TSAsExpression extends Omit<Expression, "type">, Omit<Pattern, "type"> {
        type: "TSAsExpression";
        expression: K.ExpressionKind;
        typeAnnotation: K.TSTypeKind;
        extra?: {
            parenthesized: boolean;
        } | null;
    }
    interface TSTypeCastExpression extends Omit<Expression, "type"> {
        type: "TSTypeCastExpression";
        expression: K.ExpressionKind;
        typeAnnotation: K.TSTypeKind;
    }
    interface TSSatisfiesExpression extends Omit<Expression, "type">, Omit<Pattern, "type"> {
        type: "TSSatisfiesExpression";
        expression: K.ExpressionKind;
        typeAnnotation: K.TSTypeKind;
    }
    interface TSNonNullExpression extends Omit<Expression, "type">, Omit<Pattern, "type"> {
        type: "TSNonNullExpression";
        expression: K.ExpressionKind;
    }
    interface TSAnyKeyword extends Omit<TSType, "type"> {
        type: "TSAnyKeyword";
    }
    interface TSBigIntKeyword extends Omit<TSType, "type"> {
        type: "TSBigIntKeyword";
    }
    interface TSBooleanKeyword extends Omit<TSType, "type"> {
        type: "TSBooleanKeyword";
    }
    interface TSNeverKeyword extends Omit<TSType, "type"> {
        type: "TSNeverKeyword";
    }
    interface TSNullKeyword extends Omit<TSType, "type"> {
        type: "TSNullKeyword";
    }
    interface TSNumberKeyword extends Omit<TSType, "type"> {
        type: "TSNumberKeyword";
    }
    interface TSObjectKeyword extends Omit<TSType, "type"> {
        type: "TSObjectKeyword";
    }
    interface TSStringKeyword extends Omit<TSType, "type"> {
        type: "TSStringKeyword";
    }
    interface TSSymbolKeyword extends Omit<TSType, "type"> {
        type: "TSSymbolKeyword";
    }
    interface TSUndefinedKeyword extends Omit<TSType, "type"> {
        type: "TSUndefinedKeyword";
    }
    interface TSUnknownKeyword extends Omit<TSType, "type"> {
        type: "TSUnknownKeyword";
    }
    interface TSVoidKeyword extends Omit<TSType, "type"> {
        type: "TSVoidKeyword";
    }
    interface TSIntrinsicKeyword extends Omit<TSType, "type"> {
        type: "TSIntrinsicKeyword";
    }
    interface TSThisType extends Omit<TSType, "type"> {
        type: "TSThisType";
    }
    interface TSArrayType extends Omit<TSType, "type"> {
        type: "TSArrayType";
        elementType: K.TSTypeKind;
    }
    interface TSLiteralType extends Omit<TSType, "type"> {
        type: "TSLiteralType";
        literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind | K.TemplateLiteralKind | K.UnaryExpressionKind | K.BigIntLiteralKind;
    }
    interface TSUnionType extends Omit<TSType, "type"> {
        type: "TSUnionType";
        types: K.TSTypeKind[];
    }
    interface TSIntersectionType extends Omit<TSType, "type"> {
        type: "TSIntersectionType";
        types: K.TSTypeKind[];
    }
    interface TSConditionalType extends Omit<TSType, "type"> {
        type: "TSConditionalType";
        checkType: K.TSTypeKind;
        extendsType: K.TSTypeKind;
        trueType: K.TSTypeKind;
        falseType: K.TSTypeKind;
    }
    interface TSInferType extends Omit<TSType, "type"> {
        type: "TSInferType";
        typeParameter: K.TSTypeParameterKind;
    }
    interface TSTypeParameter extends Omit<Identifier, "type" | "name"> {
        type: "TSTypeParameter";
        name: K.IdentifierKind | string;
        constraint?: K.TSTypeKind | undefined;
        default?: K.TSTypeKind | undefined;
    }
    interface TSParenthesizedType extends Omit<TSType, "type"> {
        type: "TSParenthesizedType";
        typeAnnotation: K.TSTypeKind;
    }
    interface TSFunctionType extends Omit<TSType, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
        type: "TSFunctionType";
        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
    }
    interface TSConstructorType extends Omit<TSType, "type">, TSHasOptionalTypeParameters, TSHasOptionalTypeAnnotation {
        type: "TSConstructorType";
        parameters: (K.IdentifierKind | K.RestElementKind | K.ArrayPatternKind | K.ObjectPatternKind)[];
    }
    interface TSDeclareFunction extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
        type: "TSDeclareFunction";
        declare?: boolean;
        async?: boolean;
        generator?: boolean;
        id?: K.IdentifierKind | null;
        params: K.PatternKind[];
        returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
    }
    interface TSDeclareMethod extends Omit<Declaration, "type">, TSHasOptionalTypeParameters {
        type: "TSDeclareMethod";
        async?: boolean;
        generator?: boolean;
        params: K.PatternKind[];
        abstract?: boolean;
        accessibility?: "public" | "private" | "protected" | undefined;
        static?: boolean;
        computed?: boolean;
        optional?: boolean;
        key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind;
        kind?: "get" | "set" | "method" | "constructor";
        access?: "public" | "private" | "protected" | undefined;
        decorators?: K.DecoratorKind[] | null;
        returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
    }
    interface TSMappedType extends Omit<TSType, "type"> {
        type: "TSMappedType";
        readonly?: boolean | "+" | "-";
        typeParameter: K.TSTypeParameterKind;
        optional?: boolean | "+" | "-";
        typeAnnotation?: K.TSTypeKind | null;
    }
    interface TSTupleType extends Omit<TSType, "type"> {
        type: "TSTupleType";
        elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[];
    }
    interface TSNamedTupleMember extends Omit<TSType, "type"> {
        type: "TSNamedTupleMember";
        label: K.IdentifierKind;
        optional?: boolean;
        elementType: K.TSTypeKind;
    }
    interface TSRestType extends Omit<TSType, "type"> {
        type: "TSRestType";
        typeAnnotation: K.TSTypeKind;
    }
    interface TSOptionalType extends Omit<TSType, "type"> {
        type: "TSOptionalType";
        typeAnnotation: K.TSTypeKind;
    }
    interface TSIndexedAccessType extends Omit<TSType, "type"> {
        type: "TSIndexedAccessType";
        objectType: K.TSTypeKind;
        indexType: K.TSTypeKind;
    }
    interface TSTypeOperator extends Omit<TSType, "type"> {
        type: "TSTypeOperator";
        operator: string;
        typeAnnotation: K.TSTypeKind;
    }
    interface TSIndexSignature extends Omit<Declaration, "type">, TSHasOptionalTypeAnnotation {
        type: "TSIndexSignature";
        parameters: K.IdentifierKind[];
        r