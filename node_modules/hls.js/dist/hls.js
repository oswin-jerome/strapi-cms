(function __HLS_WORKER_BUNDLE__(__IN_WORKER__){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Hls = factory());
})(this, (function () { 'use strict';

  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : String(i);
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    try {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    } catch (e) {
      return typeof fn === "function";
    }
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var urlToolkit = {exports: {}};

  (function (module, exports) {
  	// see https://tools.ietf.org/html/rfc1808

  	(function (root) {
  	  var URL_REGEX =
  	    /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
  	  var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
  	  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  	  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;

  	  var URLToolkit = {
  	    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
  	    // E.g
  	    // With opts.alwaysNormalize = false (default, spec compliant)
  	    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
  	    // With opts.alwaysNormalize = true (not spec compliant)
  	    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
  	    buildAbsoluteURL: function (baseURL, relativeURL, opts) {
  	      opts = opts || {};
  	      // remove any remaining space and CRLF
  	      baseURL = baseURL.trim();
  	      relativeURL = relativeURL.trim();
  	      if (!relativeURL) {
  	        // 2a) If the embedded URL is entirely empty, it inherits the
  	        // entire base URL (i.e., is set equal to the base URL)
  	        // and we are done.
  	        if (!opts.alwaysNormalize) {
  	          return baseURL;
  	        }
  	        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
  	        if (!basePartsForNormalise) {
  	          throw new Error('Error trying to parse base URL.');
  	        }
  	        basePartsForNormalise.path = URLToolkit.normalizePath(
  	          basePartsForNormalise.path
  	        );
  	        return URLToolkit.buildURLFromParts(basePartsForNormalise);
  	      }
  	      var relativeParts = URLToolkit.parseURL(relativeURL);
  	      if (!relativeParts) {
  	        throw new Error('Error trying to parse relative URL.');
  	      }
  	      if (relativeParts.scheme) {
  	        // 2b) If the embedded URL starts with a scheme name, it is
  	        // interpreted as an absolute URL and we are done.
  	        if (!opts.alwaysNormalize) {
  	          return relativeURL;
  	        }
  	        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
  	        return URLToolkit.buildURLFromParts(relativeParts);
  	      }
  	      var baseParts = URLToolkit.parseURL(baseURL);
  	      if (!baseParts) {
  	        throw new Error('Error trying to parse base URL.');
  	      }
  	      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
  	        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
  	        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
  	        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
  	        baseParts.netLoc = pathParts[1];
  	        baseParts.path = pathParts[2];
  	      }
  	      if (baseParts.netLoc && !baseParts.path) {
  	        baseParts.path = '/';
  	      }
  	      var builtParts = {
  	        // 2c) Otherwise, the embedded URL inherits the scheme of
  	        // the base URL.
  	        scheme: baseParts.scheme,
  	        netLoc: relativeParts.netLoc,
  	        path: null,
  	        params: relativeParts.params,
  	        query: relativeParts.query,
  	        fragment: relativeParts.fragment,
  	      };
  	      if (!relativeParts.netLoc) {
  	        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
  	        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
  	        // (if any) of the base URL.
  	        builtParts.netLoc = baseParts.netLoc;
  	        // 4) If the embedded URL path is preceded by a slash "/", the
  	        // path is not relative and we skip to Step 7.
  	        if (relativeParts.path[0] !== '/') {
  	          if (!relativeParts.path) {
  	            // 5) If the embedded URL path is empty (and not preceded by a
  	            // slash), then the embedded URL inherits the base URL path
  	            builtParts.path = baseParts.path;
  	            // 5a) if the embedded URL's <params> is non-empty, we skip to
  	            // step 7; otherwise, it inherits the <params> of the base
  	            // URL (if any) and
  	            if (!relativeParts.params) {
  	              builtParts.params = baseParts.params;
  	              // 5b) if the embedded URL's <query> is non-empty, we skip to
  	              // step 7; otherwise, it inherits the <query> of the base
  	              // URL (if any) and we skip to step 7.
  	              if (!relativeParts.query) {
  	                builtParts.query = baseParts.query;
  	              }
  	            }
  	          } else {
  	            // 6) The last segment of the base URL's path (anything
  	            // following the rightmost slash "/", or the entire path if no
  	            // slash is present) is removed and the embedded URL's path is
  	            // appended in its place.
  	            var baseURLPath = baseParts.path;
  	            var newPath =
  	              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +
  	              relativeParts.path;
  	            builtParts.path = URLToolkit.normalizePath(newPath);
  	          }
  	        }
  	      }
  	      if (builtParts.path === null) {
  	        builtParts.path = opts.alwaysNormalize
  	          ? URLToolkit.normalizePath(relativeParts.path)
  	          : relativeParts.path;
  	      }
  	      return URLToolkit.buildURLFromParts(builtParts);
  	    },
  	    parseURL: function (url) {
  	      var parts = URL_REGEX.exec(url);
  	      if (!parts) {
  	        return null;
  	      }
  	      return {
  	        scheme: parts[1] || '',
  	        netLoc: parts[2] || '',
  	        path: parts[3] || '',
  	        params: parts[4] || '',
  	        query: parts[5] || '',
  	        fragment: parts[6] || '',
  	      };
  	    },
  	    normalizePath: function (path) {
  	      // The following operations are
  	      // then applied, in order, to the new path:
  	      // 6a) All occurrences of "./", where "." is a complete path
  	      // segment, are removed.
  	      // 6b) If the path ends with "." as a complete path segment,
  	      // that "." is removed.
  	      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
  	      // 6c) All occurrences of "<segment>/../", where <segment> is a
  	      // complete path segment not equal to "..", are removed.
  	      // Removal of these path segments is performed iteratively,
  	      // removing the leftmost matching pattern on each iteration,
  	      // until no matching pattern remains.
  	      // 6d) If the path ends with "<segment>/..", where <segment> is a
  	      // complete path segment not equal to "..", that
  	      // "<segment>/.." is removed.
  	      while (
  	        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length
  	      ) {}
  	      return path.split('').reverse().join('');
  	    },
  	    buildURLFromParts: function (parts) {
  	      return (
  	        parts.scheme +
  	        parts.netLoc +
  	        parts.path +
  	        parts.params +
  	        parts.query +
  	        parts.fragment
  	      );
  	    },
  	  };

  	  module.exports = URLToolkit;
  	})(); 
  } (urlToolkit));

  var urlToolkitExports = urlToolkit.exports;

  // https://caniuse.com/mdn-javascript_builtins_number_isfinite
  var isFiniteNumber = Number.isFinite || function (value) {
    return typeof value === 'number' && isFinite(value);
  };

  // https://caniuse.com/mdn-javascript_builtins_number_issafeinteger
  var isSafeInteger = Number.isSafeInteger || function (value) {
    return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;
  };
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

  var Events = /*#__PURE__*/function (Events) {
    Events["MEDIA_ATTACHING"] = "hlsMediaAttaching";
    Events["MEDIA_ATTACHED"] = "hlsMediaAttached";
    Events["MEDIA_DETACHING"] = "hlsMediaDetaching";
    Events["MEDIA_DETACHED"] = "hlsMediaDetached";
    Events["BUFFER_RESET"] = "hlsBufferReset";
    Events["BUFFER_CODECS"] = "hlsBufferCodecs";
    Events["BUFFER_CREATED"] = "hlsBufferCreated";
    Events["BUFFER_APPENDING"] = "hlsBufferAppending";
    Events["BUFFER_APPENDED"] = "hlsBufferAppended";
    Events["BUFFER_EOS"] = "hlsBufferEos";
    Events["BUFFER_FLUSHING"] = "hlsBufferFlushing";
    Events["BUFFER_FLUSHED"] = "hlsBufferFlushed";
    Events["MANIFEST_LOADING"] = "hlsManifestLoading";
    Events["MANIFEST_LOADED"] = "hlsManifestLoaded";
    Events["MANIFEST_PARSED"] = "hlsManifestParsed";
    Events["LEVEL_SWITCHING"] = "hlsLevelSwitching";
    Events["LEVEL_SWITCHED"] = "hlsLevelSwitched";
    Events["LEVEL_LOADING"] = "hlsLevelLoading";
    Events["LEVEL_LOADED"] = "hlsLevelLoaded";
    Events["LEVEL_UPDATED"] = "hlsLevelUpdated";
    Events["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
    Events["LEVELS_UPDATED"] = "hlsLevelsUpdated";
    Events["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
    Events["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
    Events["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
    Events["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
    Events["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
    Events["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
    Events["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
    Events["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
    Events["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
    Events["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
    Events["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
    Events["CUES_PARSED"] = "hlsCuesParsed";
    Events["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
    Events["INIT_PTS_FOUND"] = "hlsInitPtsFound";
    Events["FRAG_LOADING"] = "hlsFragLoading";
    Events["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
    Events["FRAG_LOADED"] = "hlsFragLoaded";
    Events["FRAG_DECRYPTED"] = "hlsFragDecrypted";
    Events["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
    Events["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
    Events["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
    Events["FRAG_PARSED"] = "hlsFragParsed";
    Events["FRAG_BUFFERED"] = "hlsFragBuffered";
    Events["FRAG_CHANGED"] = "hlsFragChanged";
    Events["FPS_DROP"] = "hlsFpsDrop";
    Events["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
    Events["MAX_AUTO_LEVEL_UPDATED"] = "hlsMaxAutoLevelUpdated";
    Events["ERROR"] = "hlsError";
    Events["DESTROYING"] = "hlsDestroying";
    Events["KEY_LOADING"] = "hlsKeyLoading";
    Events["KEY_LOADED"] = "hlsKeyLoaded";
    Events["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
    Events["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
    Events["STEERING_MANIFEST_LOADED"] = "hlsSteeringManifestLoaded";
    return Events;
  }({});

  /**
   * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.
   */

  var ErrorTypes = /*#__PURE__*/function (ErrorTypes) {
    ErrorTypes["NETWORK_ERROR"] = "networkError";
    ErrorTypes["MEDIA_ERROR"] = "mediaError";
    ErrorTypes["KEY_SYSTEM_ERROR"] = "keySystemError";
    ErrorTypes["MUX_ERROR"] = "muxError";
    ErrorTypes["OTHER_ERROR"] = "otherError";
    return ErrorTypes;
  }({});
  var ErrorDetails = /*#__PURE__*/function (ErrorDetails) {
    ErrorDetails["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
    ErrorDetails["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
    ErrorDetails["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
    ErrorDetails["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
    ErrorDetails["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
    ErrorDetails["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
    ErrorDetails["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
    ErrorDetails["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
    ErrorDetails["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
    ErrorDetails["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
    ErrorDetails["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
    ErrorDetails["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
    ErrorDetails["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
    ErrorDetails["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
    ErrorDetails["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
    ErrorDetails["LEVEL_LOAD_ERROR"] = "levelLoadError";
    ErrorDetails["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
    ErrorDetails["LEVEL_PARSING_ERROR"] = "levelParsingError";
    ErrorDetails["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
    ErrorDetails["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
    ErrorDetails["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
    ErrorDetails["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
    ErrorDetails["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
    ErrorDetails["FRAG_LOAD_ERROR"] = "fragLoadError";
    ErrorDetails["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
    ErrorDetails["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
    ErrorDetails["FRAG_PARSING_ERROR"] = "fragParsingError";
    ErrorDetails["FRAG_GAP"] = "fragGap";
    ErrorDetails["REMUX_ALLOC_ERROR"] = "remuxAllocError";
    ErrorDetails["KEY_LOAD_ERROR"] = "keyLoadError";
    ErrorDetails["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
    ErrorDetails["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
    ErrorDetails["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
    ErrorDetails["BUFFER_APPEND_ERROR"] = "bufferAppendError";
    ErrorDetails["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
    ErrorDetails["BUFFER_STALLED_ERROR"] = "bufferStalledError";
    ErrorDetails["BUFFER_FULL_ERROR"] = "bufferFullError";
    ErrorDetails["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
    ErrorDetails["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
    ErrorDetails["INTERNAL_EXCEPTION"] = "internalException";
    ErrorDetails["INTERNAL_ABORTED"] = "aborted";
    ErrorDetails["UNKNOWN"] = "unknown";
    return ErrorDetails;
  }({});

  var noop = function noop() {};
  var fakeLogger = {
    trace: noop,
    debug: noop,
    log: noop,
    warn: noop,
    info: noop,
    error: noop
  };
  var exportedLogger = fakeLogger;

  // let lastCallTime;
  // function formatMsgWithTimeInfo(type, msg) {
  //   const now = Date.now();
  //   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
  //   lastCallTime = now;
  //   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
  //   return msg;
  // }

  function consolePrintFn(type) {
    var func = self.console[type];
    if (func) {
      return func.bind(self.console, "[" + type + "] >");
    }
    return noop;
  }
  function exportLoggerFunctions(debugConfig) {
    for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      functions[_key - 1] = arguments[_key];
    }
    functions.forEach(function (type) {
      exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
    });
  }
  function enableLogs(debugConfig, id) {
    // check that console is available
    if (typeof console === 'object' && debugConfig === true || typeof debugConfig === 'object') {
      exportLoggerFunctions(debugConfig,
      // Remove out from list here to hard-disable a log-level
      // 'trace',
      'debug', 'log', 'info', 'warn', 'error');
      // Some browsers don't allow to use bind on console object anyway
      // fallback to default if needed
      try {
        exportedLogger.log("Debug logs enabled for \"" + id + "\" in hls.js version " + "1.5.20");
      } catch (e) {
        exportedLogger = fakeLogger;
      }
    } else {
      exportedLogger = fakeLogger;
    }
  }
  var logger = exportedLogger;

  var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
  var ATTR_LIST_REGEX = /(.+?)=(".*?"|.*?)(?:,|$)/g;

  // adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js
  var AttrList = /*#__PURE__*/function () {
    function AttrList(attrs) {
      if (typeof attrs === 'string') {
        attrs = AttrList.parseAttrList(attrs);
      }
      _extends(this, attrs);
    }
    var _proto = AttrList.prototype;
    _proto.decimalInteger = function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    };
    _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;
        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    };
    _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    };
    _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    };
    _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {
      var value = this[attrName];
      return value ? parseFloat(value) : defaultValue;
    };
    _proto.enumeratedString = function enumeratedString(attrName) {
      return this[attrName];
    };
    _proto.bool = function bool(attrName) {
      return this[attrName] === 'YES';
    };
    _proto.decimalResolution = function decimalResolution(attrName) {
      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    };
    AttrList.parseAttrList = function parseAttrList(input) {
      var match;
      var attrs = {};
      var quote = '"';
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        var value = match[2];
        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        var name = match[1].trim();
        attrs[name] = value;
      }
      return attrs;
    };
    _createClass(AttrList, [{
      key: "clientAttrs",
      get: function get() {
        return Object.keys(this).filter(function (attr) {
          return attr.substring(0, 2) === 'X-';
        });
      }
    }]);
    return AttrList;
  }();

  // Avoid exporting const enum so that these values can be inlined

  function isDateRangeCueAttribute(attrName) {
    return attrName !== "ID" && attrName !== "CLASS" && attrName !== "START-DATE" && attrName !== "DURATION" && attrName !== "END-DATE" && attrName !== "END-ON-NEXT";
  }
  function isSCTE35Attribute(attrName) {
    return attrName === "SCTE35-OUT" || attrName === "SCTE35-IN";
  }
  var DateRange = /*#__PURE__*/function () {
    function DateRange(dateRangeAttr, dateRangeWithSameId) {
      this.attr = void 0;
      this._startDate = void 0;
      this._endDate = void 0;
      this._badValueForSameId = void 0;
      if (dateRangeWithSameId) {
        var previousAttr = dateRangeWithSameId.attr;
        for (var key in previousAttr) {
          if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
            logger.warn("DATERANGE tag attribute: \"" + key + "\" does not match for tags with ID: \"" + dateRangeAttr.ID + "\"");
            this._badValueForSameId = key;
            break;
          }
        }
        // Merge DateRange tags with the same ID
        dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);
      }
      this.attr = dateRangeAttr;
      this._startDate = new Date(dateRangeAttr["START-DATE"]);
      if ("END-DATE" in this.attr) {
        var endDate = new Date(this.attr["END-DATE"]);
        if (isFiniteNumber(endDate.getTime())) {
          this._endDate = endDate;
        }
      }
    }
    _createClass(DateRange, [{
      key: "id",
      get: function get() {
        return this.attr.ID;
      }
    }, {
      key: "class",
      get: function get() {
        return this.attr.CLASS;
      }
    }, {
      key: "startDate",
      get: function get() {
        return this._startDate;
      }
    }, {
      key: "endDate",
      get: function get() {
        if (this._endDate) {
          return this._endDate;
        }
        var duration = this.duration;
        if (duration !== null) {
          return new Date(this._startDate.getTime() + duration * 1000);
        }
        return null;
      }
    }, {
      key: "duration",
      get: function get() {
        if ("DURATION" in this.attr) {
          var duration = this.attr.decimalFloatingPoint("DURATION");
          if (isFiniteNumber(duration)) {
            return duration;
          }
        } else if (this._endDate) {
          return (this._endDate.getTime() - this._startDate.getTime()) / 1000;
        }
        return null;
      }
    }, {
      key: "plannedDuration",
      get: function get() {
        if ("PLANNED-DURATION" in this.attr) {
          return this.attr.decimalFloatingPoint("PLANNED-DURATION");
        }
        return null;
      }
    }, {
      key: "endOnNext",
      get: function get() {
        return this.attr.bool("END-ON-NEXT");
      }
    }, {
      key: "isValid",
      get: function get() {
        return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);
      }
    }]);
    return DateRange;
  }();

  var LoadStats = function LoadStats() {
    this.aborted = false;
    this.loaded = 0;
    this.retry = 0;
    this.total = 0;
    this.chunkCount = 0;
    this.bwEstimate = 0;
    this.loading = {
      start: 0,
      first: 0,
      end: 0
    };
    this.parsing = {
      start: 0,
      end: 0
    };
    this.buffering = {
      start: 0,
      first: 0,
      end: 0
    };
  };

  var ElementaryStreamTypes = {
    AUDIO: "audio",
    VIDEO: "video",
    AUDIOVIDEO: "audiovideo"
  };
  var BaseSegment = /*#__PURE__*/function () {
    function BaseSegment(baseurl) {
      var _this$elementaryStrea;
      this._byteRange = null;
      this._url = null;
      // baseurl is the URL to the playlist
      this.baseurl = void 0;
      // relurl is the portion of the URL that comes from inside the playlist.
      this.relurl = void 0;
      // Holds the types of data this fragment supports
      this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);
      this.baseurl = baseurl;
    }

    // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
    var _proto = BaseSegment.prototype;
    _proto.setByteRange = function setByteRange(value, previous) {
      var params = value.split('@', 2);
      var start;
      if (params.length === 1) {
        start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;
      } else {
        start = parseInt(params[1]);
      }
      this._byteRange = [start, parseInt(params[0]) + start];
    };
    _createClass(BaseSegment, [{
      key: "byteRange",
      get: function get() {
        if (!this._byteRange) {
          return [];
        }
        return this._byteRange;
      }
    }, {
      key: "byteRangeStartOffset",
      get: function get() {
        return this.byteRange[0];
      }
    }, {
      key: "byteRangeEndOffset",
      get: function get() {
        return this.byteRange[1];
      }
    }, {
      key: "url",
      get: function get() {
        if (!this._url && this.baseurl && this.relurl) {
          this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
            alwaysNormalize: true
          });
        }
        return this._url || '';
      },
      set: function set(value) {
        this._url = value;
      }
    }]);
    return BaseSegment;
  }();

  /**
   * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.
   */
  var Fragment = /*#__PURE__*/function (_BaseSegment) {
    _inheritsLoose(Fragment, _BaseSegment);
    function Fragment(type, baseurl) {
      var _this;
      _this = _BaseSegment.call(this, baseurl) || this;
      _this._decryptdata = null;
      _this.rawProgramDateTime = null;
      _this.programDateTime = null;
      _this.tagList = [];
      // EXTINF has to be present for a m3u8 to be considered valid
      _this.duration = 0;
      // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'
      _this.sn = 0;
      // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption
      // core difference from the private field _decryptdata is the lack of the initialized IV
      // _decryptdata will set the IV for this segment based on the segment number in the fragment
      _this.levelkeys = void 0;
      // A string representing the fragment type
      _this.type = void 0;
      // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading
      _this.loader = null;
      // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading
      _this.keyLoader = null;
      // The level/track index to which the fragment belongs
      _this.level = -1;
      // The continuity counter of the fragment
      _this.cc = 0;
      // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
      _this.startPTS = void 0;
      // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
      _this.endPTS = void 0;
      // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
      _this.startDTS = void 0;
      // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
      _this.endDTS = void 0;
      // The start time of the fragment, as listed in the manifest. Updated after transmux complete.
      _this.start = 0;
      // Set by `updateFragPTSDTS` in level-helper
      _this.deltaPTS = void 0;
      // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
      _this.maxStartPTS = void 0;
      // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
      _this.minEndPTS = void 0;
      // Load/parse timing information
      _this.stats = new LoadStats();
      // Init Segment bytes (unset for media segments)
      _this.data = void 0;
      // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered
      _this.bitrateTest = false;
      // #EXTINF  segment title
      _this.title = null;
      // The Media Initialization Section for this segment
      _this.initSegment = null;
      // Fragment is the last fragment in the media playlist
      _this.endList = void 0;
      // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded
      _this.gap = void 0;
      // Deprecated
      _this.urlId = 0;
      _this.type = type;
      return _this;
    }
    var _proto2 = Fragment.prototype;
    _proto2.setKeyFormat = function setKeyFormat(keyFormat) {
      if (this.levelkeys) {
        var _key = this.levelkeys[keyFormat];
        if (_key && !this._decryptdata) {
          this._decryptdata = _key.getDecryptData(this.sn);
        }
      }
    };
    _proto2.abortRequests = function abortRequests() {
      var _this$loader, _this$keyLoader;
      (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();
      (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();
    };
    _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {
      if (partial === void 0) {
        partial = false;
      }
      var elementaryStreams = this.elementaryStreams;
      var info = elementaryStreams[type];
      if (!info) {
        elementaryStreams[type] = {
          startPTS: startPTS,
          endPTS: endPTS,
          startDTS: startDTS,
          endDTS: endDTS,
          partial: partial
        };
        return;
      }
      info.startPTS = Math.min(info.startPTS, startPTS);
      info.endPTS = Math.max(info.endPTS, endPTS);
      info.startDTS = Math.min(info.startDTS, startDTS);
      info.endDTS = Math.max(info.endDTS, endDTS);
    };
    _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {
      var elementaryStreams = this.elementaryStreams;
      elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
      elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
      elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
    };
    _createClass(Fragment, [{
      key: "decryptdata",
      get: function get() {
        var levelkeys = this.levelkeys;
        if (!levelkeys && !this._decryptdata) {
          return null;
        }
        if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
          var _key2 = this.levelkeys.identity;
          if (_key2) {
            this._decryptdata = _key2.getDecryptData(this.sn);
          } else {
            var keyFormats = Object.keys(this.levelkeys);
            if (keyFormats.length === 1) {
              return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
            }
          }
        }
        return this._decryptdata;
      }
    }, {
      key: "end",
      get: function get() {
        return this.start + this.duration;
      }
    }, {
      key: "endProgramDateTime",
      get: function get() {
        if (this.programDateTime === null) {
          return null;
        }
        if (!isFiniteNumber(this.programDateTime)) {
          return null;
        }
        var duration = !isFiniteNumber(this.duration) ? 0 : this.duration;
        return this.programDateTime + duration * 1000;
      }
    }, {
      key: "encrypted",
      get: function get() {
        var _this$_decryptdata;
        // At the m3u8-parser level we need to add support for manifest signalled keyformats
        // when we want the fragment to start reporting that it is encrypted.
        // Currently, keyFormat will only be set for identity keys
        if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {
          return true;
        } else if (this.levelkeys) {
          var keyFormats = Object.keys(this.levelkeys);
          var len = keyFormats.length;
          if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
            return true;
          }
        }
        return false;
      }
    }]);
    return Fragment;
  }(BaseSegment);

  /**
   * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.
   */
  var Part = /*#__PURE__*/function (_BaseSegment2) {
    _inheritsLoose(Part, _BaseSegment2);
    function Part(partAttrs, frag, baseurl, index, previous) {
      var _this2;
      _this2 = _BaseSegment2.call(this, baseurl) || this;
      _this2.fragOffset = 0;
      _this2.duration = 0;
      _this2.gap = false;
      _this2.independent = false;
      _this2.relurl = void 0;
      _this2.fragment = void 0;
      _this2.index = void 0;
      _this2.stats = new LoadStats();
      _this2.duration = partAttrs.decimalFloatingPoint('DURATION');
      _this2.gap = partAttrs.bool('GAP');
      _this2.independent = partAttrs.bool('INDEPENDENT');
      _this2.relurl = partAttrs.enumeratedString('URI');
      _this2.fragment = frag;
      _this2.index = index;
      var byteRange = partAttrs.enumeratedString('BYTERANGE');
      if (byteRange) {
        _this2.setByteRange(byteRange, previous);
      }
      if (previous) {
        _this2.fragOffset = previous.fragOffset + previous.duration;
      }
      return _this2;
    }
    _createClass(Part, [{
      key: "start",
      get: function get() {
        return this.fragment.start + this.fragOffset;
      }
    }, {
      key: "end",
      get: function get() {
        return this.start + this.duration;
      }
    }, {
      key: "loaded",
      get: function get() {
        var elementaryStreams = this.elementaryStreams;
        return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
      }
    }]);
    return Part;
  }(BaseSegment);

  var DEFAULT_TARGET_DURATION = 10;

  /**
   * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.
   */
  var LevelDetails = /*#__PURE__*/function () {
    function LevelDetails(baseUrl) {
      this.PTSKnown = false;
      this.alignedSliding = false;
      this.averagetargetduration = void 0;
      this.endCC = 0;
      this.endSN = 0;
      this.fragments = void 0;
      this.fragmentHint = void 0;
      this.partList = null;
      this.dateRanges = void 0;
      this.live = true;
      this.ageHeader = 0;
      this.advancedDateTime = void 0;
      this.updated = true;
      this.advanced = true;
      this.availabilityDelay = void 0;
      // Manifest reload synchronization
      this.misses = 0;
      this.startCC = 0;
      this.startSN = 0;
      this.startTimeOffset = null;
      this.targetduration = 0;
      this.totalduration = 0;
      this.type = null;
      this.url = void 0;
      this.m3u8 = '';
      this.version = null;
      this.canBlockReload = false;
      this.canSkipUntil = 0;
      this.canSkipDateRanges = false;
      this.skippedSegments = 0;
      this.recentlyRemovedDateranges = void 0;
      this.partHoldBack = 0;
      this.holdBack = 0;
      this.partTarget = 0;
      this.preloadHint = void 0;
      this.renditionReports = void 0;
      this.tuneInGoal = 0;
      this.deltaUpdateFailed = void 0;
      this.driftStartTime = 0;
      this.driftEndTime = 0;
      this.driftStart = 0;
      this.driftEnd = 0;
      this.encryptedFragments = void 0;
      this.playlistParsingError = null;
      this.variableList = null;
      this.hasVariableRefs = false;
      this.fragments = [];
      this.encryptedFragments = [];
      this.dateRanges = {};
      this.url = baseUrl;
    }
    var _proto = LevelDetails.prototype;
    _proto.reloaded = function reloaded(previous) {
      if (!previous) {
        this.advanced = true;
        this.updated = true;
        return;
      }
      var partSnDiff = this.lastPartSn - previous.lastPartSn;
      var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
      this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;
      this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
      if (this.updated || this.advanced) {
        this.misses = Math.floor(previous.misses * 0.6);
      } else {
        this.misses = previous.misses + 1;
      }
      this.availabilityDelay = previous.availabilityDelay;
    };
    _createClass(LevelDetails, [{
      key: "hasProgramDateTime",
      get: function get() {
        if (this.fragments.length) {
          return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);
        }
        return false;
      }
    }, {
      key: "levelTargetDuration",
      get: function get() {
        return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
      }
    }, {
      key: "drift",
      get: function get() {
        var runTime = this.driftEndTime - this.driftStartTime;
        if (runTime > 0) {
          var runDuration = this.driftEnd - this.driftStart;
          return runDuration * 1000 / runTime;
        }
        return 1;
      }
    }, {
      key: "edge",
      get: function get() {
        return this.partEnd || this.fragmentEnd;
      }
    }, {
      key: "partEnd",
      get: function get() {
        var _this$partList;
        if ((_this$partList = this.partList) != null && _this$partList.length) {
          return this.partList[this.partList.length - 1].end;
        }
        return this.fragmentEnd;
      }
    }, {
      key: "fragmentEnd",
      get: function get() {
        var _this$fragments;
        if ((_this$fragments = this.fragments) != null && _this$fragments.length) {
          return this.fragments[this.fragments.length - 1].end;
        }
        return 0;
      }
    }, {
      key: "age",
      get: function get() {
        if (this.advancedDateTime) {
          return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;
        }
        return 0;
      }
    }, {
      key: "lastPartIndex",
      get: function get() {
        var _this$partList2;
        if ((_this$partList2 = this.partList) != null && _this$partList2.length) {
          return this.partList[this.partList.length - 1].index;
        }
        return -1;
      }
    }, {
      key: "lastPartSn",
      get: function get() {
        var _this$partList3;
        if ((_this$partList3 = this.partList) != null && _this$partList3.length) {
          return this.partList[this.partList.length - 1].fragment.sn;
        }
        return this.endSN;
      }
    }]);
    return LevelDetails;
  }();

  function base64Decode(base64encodedStr) {
    return Uint8Array.from(atob(base64encodedStr), function (c) {
      return c.charCodeAt(0);
    });
  }

  function getKeyIdBytes(str) {
    var keyIdbytes = strToUtf8array(str).subarray(0, 16);
    var paddedkeyIdbytes = new Uint8Array(16);
    paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);
    return paddedkeyIdbytes;
  }
  function changeEndianness(keyId) {
    var swap = function swap(array, from, to) {
      var cur = array[from];
      array[from] = array[to];
      array[to] = cur;
    };
    swap(keyId, 0, 3);
    swap(keyId, 1, 2);
    swap(keyId, 4, 5);
    swap(keyId, 6, 7);
  }
  function convertDataUriToArrayBytes(uri) {
    // data:[<media type][;attribute=value][;base64],<data>
    var colonsplit = uri.split(':');
    var keydata = null;
    if (colonsplit[0] === 'data' && colonsplit.length === 2) {
      var semicolonsplit = colonsplit[1].split(';');
      var commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');
      if (commasplit.length === 2) {
        var isbase64 = commasplit[0] === 'base64';
        var data = commasplit[1];
        if (isbase64) {
          semicolonsplit.splice(-1, 1); // remove from processing
          keydata = base64Decode(data);
        } else {
          keydata = getKeyIdBytes(data);
        }
      }
    }
    return keydata;
  }
  function strToUtf8array(str) {
    return Uint8Array.from(unescape(encodeURIComponent(str)), function (c) {
      return c.charCodeAt(0);
    });
  }

  /** returns `undefined` is `self` is missing, e.g. in node */
  var optionalSelf = typeof self !== 'undefined' ? self : undefined;

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
   */
  var KeySystems = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.fps",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "com.widevine.alpha"
  };

  // Playlist #EXT-X-KEY KEYFORMAT values
  var KeySystemFormats = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.streamingkeydelivery",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
  };
  function keySystemFormatToKeySystemDomain(format) {
    switch (format) {
      case KeySystemFormats.FAIRPLAY:
        return KeySystems.FAIRPLAY;
      case KeySystemFormats.PLAYREADY:
        return KeySystems.PLAYREADY;
      case KeySystemFormats.WIDEVINE:
        return KeySystems.WIDEVINE;
      case KeySystemFormats.CLEARKEY:
        return KeySystems.CLEARKEY;
    }
  }

  // System IDs for which we can extract a key ID from "encrypted" event PSSH
  var KeySystemIds = {
    CENC: "1077efecc0b24d02ace33c1e52e2fb4b",
    CLEARKEY: "e2719d58a985b3c9781ab030af78d30e",
    FAIRPLAY: "94ce86fb07ff4f43adb893d2fa968ca2",
    PLAYREADY: "9a04f07998404286ab92e65be0885f95",
    WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
  };
  function keySystemIdToKeySystemDomain(systemId) {
    if (systemId === KeySystemIds.WIDEVINE) {
      return KeySystems.WIDEVINE;
    } else if (systemId === KeySystemIds.PLAYREADY) {
      return KeySystems.PLAYREADY;
    } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {
      return KeySystems.CLEARKEY;
    }
  }
  function keySystemDomainToKeySystemFormat(keySystem) {
    switch (keySystem) {
      case KeySystems.FAIRPLAY:
        return KeySystemFormats.FAIRPLAY;
      case KeySystems.PLAYREADY:
        return KeySystemFormats.PLAYREADY;
      case KeySystems.WIDEVINE:
        return KeySystemFormats.WIDEVINE;
      case KeySystems.CLEARKEY:
        return KeySystemFormats.CLEARKEY;
    }
  }
  function getKeySystemsForConfig(config) {
    var drmSystems = config.drmSystems,
      widevineLicenseUrl = config.widevineLicenseUrl;
    var keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(function (keySystem) {
      return !!drmSystems[keySystem];
    }) : [];
    if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {
      keySystemsToAttempt.push(KeySystems.WIDEVINE);
    }
    return keySystemsToAttempt;
  }
  var requestMediaKeySystemAccess = function (_optionalSelf$navigat) {
    if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {
      return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
    } else {
      return null;
    }
  }();

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
   */
  function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
    var initDataTypes;
    switch (keySystem) {
      case KeySystems.FAIRPLAY:
        initDataTypes = ['cenc', 'sinf'];
        break;
      case KeySystems.WIDEVINE:
      case KeySystems.PLAYREADY:
        initDataTypes = ['cenc'];
        break;
      case KeySystems.CLEARKEY:
        initDataTypes = ['cenc', 'keyids'];
        break;
      default:
        throw new Error("Unknown key-system: " + keySystem);
    }
    return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);
  }
  function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {
    var baseConfig = {
      initDataTypes: initDataTypes,
      persistentState: drmSystemOptions.persistentState || 'optional',
      distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'optional',
      sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],
      audioCapabilities: audioCodecs.map(function (codec) {
        return {
          contentType: "audio/mp4; codecs=\"" + codec + "\"",
          robustness: drmSystemOptions.audioRobustness || '',
          encryptionScheme: drmSystemOptions.audioEncryptionScheme || null
        };
      }),
      videoCapabilities: videoCodecs.map(function (codec) {
        return {
          contentType: "video/mp4; codecs=\"" + codec + "\"",
          robustness: drmSystemOptions.videoRobustness || '',
          encryptionScheme: drmSystemOptions.videoEncryptionScheme || null
        };
      })
    };
    return [baseConfig];
  }
  function parsePlayReadyWRM(keyBytes) {
    var keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);
    var keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));

    // Parse Playready WRMHeader XML
    var xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);
    var parser = new DOMParser();
    var xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');
    var keyData = xmlDoc.getElementsByTagName('KID')[0];
    if (keyData) {
      var keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');
      if (keyId) {
        var keyIdArray = base64Decode(keyId).subarray(0, 16);
        // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID
        // KID value in tenc is a big endian UUID GUID interpretation of UUID
        changeEndianness(keyIdArray);
        return keyIdArray;
      }
    }
    return null;
  }

  function sliceUint8(array, start, end) {
    // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.
    // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.
    return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));
  }

  // breaking up those two types in order to clarify what is happening in the decoding path.

  /**
   * Returns true if an ID3 header can be found at offset in data
   * @param data - The data to search
   * @param offset - The offset at which to start searching
   */
  var isHeader$2 = function isHeader(data, offset) {
    /*
     * http://id3.org/id3v2.3.0
     * [0]     = 'I'
     * [1]     = 'D'
     * [2]     = '3'
     * [3,4]   = {Version}
     * [5]     = {Flags}
     * [6-9]   = {ID3 Size}
     *
     * An ID3v2 tag can be detected with the following pattern:
     *  $49 44 33 yy yy xx zz zz zz zz
     * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
     */
    if (offset + 10 <= data.length) {
      // look for 'ID3' identifier
      if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
        // check version is within range
        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {
          // check size is within range
          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
            return true;
          }
        }
      }
    }
    return false;
  };

  /**
   * Returns true if an ID3 footer can be found at offset in data
   * @param data - The data to search
   * @param offset - The offset at which to start searching
   */
  var isFooter = function isFooter(data, offset) {
    /*
     * The footer is a copy of the header, but with a different identifier
     */
    if (offset + 10 <= data.length) {
      // look for '3DI' identifier
      if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
        // check version is within range
        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {
          // check size is within range
          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
            return true;
          }
        }
      }
    }
    return false;
  };

  /**
   * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
   * @param data - The data to search in
   * @param offset - The offset at which to start searching
   * @returns the block of data containing any ID3 tags found
   * or *undefined* if no header is found at the starting offset
   */
  var getID3Data = function getID3Data(data, offset) {
    var front = offset;
    var length = 0;
    while (isHeader$2(data, offset)) {
      // ID3 header is 10 bytes
      length += 10;
      var size = readSize(data, offset + 6);
      length += size;
      if (isFooter(data, offset + 10)) {
        // ID3 footer is 10 bytes
        length += 10;
      }
      offset += length;
    }
    if (length > 0) {
      return data.subarray(front, front + length);
    }
    return undefined;
  };
  var readSize = function readSize(data, offset) {
    var size = 0;
    size = (data[offset] & 0x7f) << 21;
    size |= (data[offset + 1] & 0x7f) << 14;
    size |= (data[offset + 2] & 0x7f) << 7;
    size |= data[offset + 3] & 0x7f;
    return size;
  };
  var canParse$2 = function canParse(data, offset) {
    return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;
  };

  /**
   * Searches for the Elementary Stream timestamp found in the ID3 data chunk
   * @param data - Block of data containing one or more ID3 tags
   */
  var getTimeStamp = function getTimeStamp(data) {
    var frames = getID3Frames(data);
    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i];
      if (isTimeStampFrame(frame)) {
        return readTimeStamp(frame);
      }
    }
    return undefined;
  };

  /**
   * Returns true if the ID3 frame is an Elementary Stream timestamp frame
   */
  var isTimeStampFrame = function isTimeStampFrame(frame) {
    return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
  };
  var getFrameData = function getFrameData(data) {
    /*
    Frame ID       $xx xx xx xx (four characters)
    Size           $xx xx xx xx
    Flags          $xx xx
    */
    var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
    var size = readSize(data, 4);

    // skip frame id, size, and flags
    var offset = 10;
    return {
      type: type,
      size: size,
      data: data.subarray(offset, offset + size)
    };
  };

  /**
   * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
   * @param id3Data - The ID3 data containing one or more ID3 tags
   */
  var getID3Frames = function getID3Frames(id3Data) {
    var offset = 0;
    var frames = [];
    while (isHeader$2(id3Data, offset)) {
      var size = readSize(id3Data, offset + 6);
      // skip past ID3 header
      offset += 10;
      var end = offset + size;
      // loop through frames in the ID3 tag
      while (offset + 8 < end) {
        var frameData = getFrameData(id3Data.subarray(offset));
        var frame = decodeFrame(frameData);
        if (frame) {
          frames.push(frame);
        }

        // skip frame header and frame data
        offset += frameData.size + 10;
      }
      if (isFooter(id3Data, offset)) {
        offset += 10;
      }
    }
    return frames;
  };
  var decodeFrame = function decodeFrame(frame) {
    if (frame.type === 'PRIV') {
      return decodePrivFrame(frame);
    } else if (frame.type[0] === 'W') {
      return decodeURLFrame(frame);
    }
    return decodeTextFrame(frame);
  };
  var decodePrivFrame = function decodePrivFrame(frame) {
    /*
    Format: <text string>\0<binary data>
    */
    if (frame.size < 2) {
      return undefined;
    }
    var owner = utf8ArrayToStr(frame.data, true);
    var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
    return {
      key: frame.type,
      info: owner,
      data: privateData.buffer
    };
  };
  var decodeTextFrame = function decodeTextFrame(frame) {
    if (frame.size < 2) {
      return undefined;
    }
    if (frame.type === 'TXXX') {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{Value}
      */
      var index = 1;
      var description = utf8ArrayToStr(frame.data.subarray(index), true);
      index += description.length + 1;
      var value = utf8ArrayToStr(frame.data.subarray(index));
      return {
        key: frame.type,
        info: description,
        data: value
      };
    }
    /*
    Format:
    [0]   = {Text Encoding}
    [1-?] = {Value}
    */
    var text = utf8ArrayToStr(frame.data.subarray(1));
    return {
      key: frame.type,
      data: text
    };
  };
  var decodeURLFrame = function decodeURLFrame(frame) {
    if (frame.type === 'WXXX') {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{URL}
      */
      if (frame.size < 2) {
        return undefined;
      }
      var index = 1;
      var description = utf8ArrayToStr(frame.data.subarray(index), true);
      index += description.length + 1;
      var value = utf8ArrayToStr(frame.data.subarray(index));
      return {
        key: frame.type,
        info: description,
        data: value
      };
    }
    /*
    Format:
    [0-?] = {URL}
    */
    var url = utf8ArrayToStr(frame.data);
    return {
      key: frame.type,
      data: url
    };
  };
  var readTimeStamp = function readTimeStamp(timeStampFrame) {
    if (timeStampFrame.data.byteLength === 8) {
      var data = new Uint8Array(timeStampFrame.data);
      // timestamp is 33 bit expressed as a big-endian eight-octet number,
      // with the upper 31 bits set to zero.
      var pts33Bit = data[3] & 0x1;
      var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
      timestamp /= 45;
      if (pts33Bit) {
        timestamp += 47721858.84;
      } // 2^32 / 90

      return Math.round(timestamp);
    }
    return undefined;
  };

  // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
  // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
  /* utf.js - UTF-8 <=> UTF-16 convertion
   *
   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
   * Version: 1.0
   * LastModified: Dec 25 1999
   * This library is free.  You can redistribute it and/or modify it.
   */
  var utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {
    if (exitOnNull === void 0) {
      exitOnNull = false;
    }
    var decoder = getTextDecoder();
    if (decoder) {
      var decoded = decoder.decode(array);
      if (exitOnNull) {
        // grab up to the first null
        var idx = decoded.indexOf('\0');
        return idx !== -1 ? decoded.substring(0, idx) : decoded;
      }

      // remove any null characters
      return decoded.replace(/\0/g, '');
    }
    var len = array.length;
    var c;
    var char2;
    var char3;
    var out = '';
    var i = 0;
    while (i < len) {
      c = array[i++];
      if (c === 0x00 && exitOnNull) {
        return out;
      } else if (c === 0x00 || c === 0x03) {
        // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
        continue;
      }
      switch (c >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          // 0xxxxxxx
          out += String.fromCharCode(c);
          break;
        case 12:
        case 13:
          // 110x xxxx   10xx xxxx
          char2 = array[i++];
          out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);
          break;
        case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = array[i++];
          char3 = array[i++];
          out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);
          break;
      }
    }
    return out;
  };
  var decoder;
  function getTextDecoder() {
    // On Play Station 4, TextDecoder is defined but partially implemented.
    // Manual decoding option is preferable
    if (navigator.userAgent.includes('PlayStation 4')) {
      return;
    }
    if (!decoder && typeof self.TextDecoder !== 'undefined') {
      decoder = new self.TextDecoder('utf-8');
    }
    return decoder;
  }

  /**
   *  hex dump helper class
   */

  var Hex = {
    hexDump: function hexDump(array) {
      var str = '';
      for (var i = 0; i < array.length; i++) {
        var h = array[i].toString(16);
        if (h.length < 2) {
          h = '0' + h;
        }
        str += h;
      }
      return str;
    }
  };

  var UINT32_MAX$1 = Math.pow(2, 32) - 1;
  var push = [].push;

  // We are using fixed track IDs for driving the MP4 remuxer
  // instead of following the TS PIDs.
  // There is no reason not to do this and some browsers/SourceBuffer-demuxers
  // may not like if there are TrackID "switches"
  // See https://github.com/video-dev/hls.js/issues/1331
  // Here we are mapping our internal track types to constant MP4 track IDs
  // With MSE currently one can only have one track of each, and we are muxing
  // whatever video/audio rendition in them.
  var RemuxerTrackIdConfig = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
  };
  function bin2str(data) {
    return String.fromCharCode.apply(null, data);
  }
  function readUint16(buffer, offset) {
    var val = buffer[offset] << 8 | buffer[offset + 1];
    return val < 0 ? 65536 + val : val;
  }
  function readUint32(buffer, offset) {
    var val = readSint32(buffer, offset);
    return val < 0 ? 4294967296 + val : val;
  }
  function readUint64(buffer, offset) {
    var result = readUint32(buffer, offset);
    result *= Math.pow(2, 32);
    result += readUint32(buffer, offset + 4);
    return result;
  }
  function readSint32(buffer, offset) {
    return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
  }
  function writeUint32(buffer, offset, value) {
    buffer[offset] = value >> 24;
    buffer[offset + 1] = value >> 16 & 0xff;
    buffer[offset + 2] = value >> 8 & 0xff;
    buffer[offset + 3] = value & 0xff;
  }

  // Find "moof" box
  function hasMoofData(data) {
    var end = data.byteLength;
    for (var i = 0; i < end;) {
      var size = readUint32(data, i);
      if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {
        return true;
      }
      i = size > 1 ? i + size : end;
    }
    return false;
  }

  // Find the data for a box specified by its path
  function findBox(data, path) {
    var results = [];
    if (!path.length) {
      // short-circuit the search for empty paths
      return results;
    }
    var end = data.byteLength;
    for (var i = 0; i < end;) {
      var size = readUint32(data, i);
      var type = bin2str(data.subarray(i + 4, i + 8));
      var endbox = size > 1 ? i + size : end;
      if (type === path[0]) {
        if (path.length === 1) {
          // this is the end of the path and we've found the box we were
          // looking for
          results.push(data.subarray(i + 8, endbox));
        } else {
          // recursively search for the next box along the path
          var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
          if (subresults.length) {
            push.apply(results, subresults);
          }
        }
      }
      i = endbox;
    }

    // we've finished searching all of data
    return results;
  }
  function parseSegmentIndex(sidx) {
    var references = [];
    var version = sidx[0];

    // set initial offset, we skip the reference ID (not needed)
    var index = 8;
    var timescale = readUint32(sidx, index);
    index += 4;
    var earliestPresentationTime = 0;
    var firstOffset = 0;
    if (version === 0) {
      earliestPresentationTime = readUint32(sidx, index);
      firstOffset = readUint32(sidx, index + 4);
      index += 8;
    } else {
      earliestPresentationTime = readUint64(sidx, index);
      firstOffset = readUint64(sidx, index + 8);
      index += 16;
    }

    // skip reserved
    index += 2;
    var startByte = sidx.length + firstOffset;
    var referencesCount = readUint16(sidx, index);
    index += 2;
    for (var i = 0; i < referencesCount; i++) {
      var referenceIndex = index;
      var referenceInfo = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      var referenceSize = referenceInfo & 0x7fffffff;
      var referenceType = (referenceInfo & 0x80000000) >>> 31;
      if (referenceType === 1) {
        logger.warn('SIDX has hierarchical references (not supported)');
        return null;
      }
      var subsegmentDuration = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      references.push({
        referenceSize: referenceSize,
        subsegmentDuration: subsegmentDuration,
        // unscaled
        info: {
          duration: subsegmentDuration / timescale,
          start: startByte,
          end: startByte + referenceSize - 1
        }
      });
      startByte += referenceSize;

      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
      // for |sapDelta|.
      referenceIndex += 4;

      // skip to next ref
      index = referenceIndex;
    }
    return {
      earliestPresentationTime: earliestPresentationTime,
      timescale: timescale,
      version: version,
      referencesCount: referencesCount,
      references: references
    };
  }

  /**
   * Parses an MP4 initialization segment and extracts stream type and
   * timescale values for any declared tracks. Timescale values indicate the
   * number of clock ticks per second to assume for time-based values
   * elsewhere in the MP4.
   *
   * To determine the start time of an MP4, you need two pieces of
   * information: the timescale unit and the earliest base media decode
   * time. Multiple timescales can be specified within an MP4 but the
   * base media decode time is always expressed in the timescale from
   * the media header box for the track:
   * ```
   * moov > trak > mdia > mdhd.timescale
   * moov > trak > mdia > hdlr
   * ```
   * @param initSegment the bytes of the init segment
   * @returns a hash of track type to timescale values or null if
   * the init segment is malformed.
   */

  function parseInitSegment(initSegment) {
    var result = [];
    var traks = findBox(initSegment, ['moov', 'trak']);
    for (var i = 0; i < traks.length; i++) {
      var trak = traks[i];
      var tkhd = findBox(trak, ['tkhd'])[0];
      if (tkhd) {
        var version = tkhd[0];
        var trackId = readUint32(tkhd, version === 0 ? 12 : 20);
        var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];
        if (mdhd) {
          version = mdhd[0];
          var timescale = readUint32(mdhd, version === 0 ? 12 : 20);
          var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];
          if (hdlr) {
            var hdlrType = bin2str(hdlr.subarray(8, 12));
            var type = {
              soun: ElementaryStreamTypes.AUDIO,
              vide: ElementaryStreamTypes.VIDEO
            }[hdlrType];
            if (type) {
              // Parse codec details
              var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];
              var stsdData = parseStsd(stsd);
              result[trackId] = {
                timescale: timescale,
                type: type
              };
              result[type] = _objectSpread2({
                timescale: timescale,
                id: trackId
              }, stsdData);
            }
          }
        }
      }
    }
    var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);
    trex.forEach(function (trex) {
      var trackId = readUint32(trex, 4);
      var track = result[trackId];
      if (track) {
        track.default = {
          duration: readUint32(trex, 12),
          flags: readUint32(trex, 20)
        };
      }
    });
    return result;
  }
  function parseStsd(stsd) {
    var sampleEntries = stsd.subarray(8);
    var sampleEntriesEnd = sampleEntries.subarray(8 + 78);
    var fourCC = bin2str(sampleEntries.subarray(4, 8));
    var codec = fourCC;
    var encrypted = fourCC === 'enca' || fourCC === 'encv';
    if (encrypted) {
      var encBox = findBox(sampleEntries, [fourCC])[0];
      var encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);
      var sinfs = findBox(encBoxChildren, ['sinf']);
      sinfs.forEach(function (sinf) {
        var schm = findBox(sinf, ['schm'])[0];
        if (schm) {
          var scheme = bin2str(schm.subarray(4, 8));
          if (scheme === 'cbcs' || scheme === 'cenc') {
            var frma = findBox(sinf, ['frma'])[0];
            if (frma) {
              // for encrypted content codec fourCC will be in frma
              codec = bin2str(frma);
            }
          }
        }
      });
    }
    switch (codec) {
      case 'avc1':
      case 'avc2':
      case 'avc3':
      case 'avc4':
        {
          // extract profile + compatibility + level out of avcC box
          var avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];
          codec += '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);
          break;
        }
      case 'mp4a':
        {
          var codecBox = findBox(sampleEntries, [fourCC])[0];
          var esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];
          if (esdsBox && esdsBox.length > 12) {
            var i = 4;
            // ES Descriptor tag
            if (esdsBox[i++] !== 0x03) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            i += 2; // skip es_id;
            var flags = esdsBox[i++];
            if (flags & 0x80) {
              i += 2; // skip dependency es_id
            }
            if (flags & 0x40) {
              i += esdsBox[i++]; // skip URL
            }
            // Decoder config descriptor
            if (esdsBox[i++] !== 0x04) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            var objectType = esdsBox[i++];
            if (objectType === 0x40) {
              codec += '.' + toHex(objectType);
            } else {
              break;
            }
            i += 12;
            // Decoder specific info
            if (esdsBox[i++] !== 0x05) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            var firstByte = esdsBox[i++];
            var audioObjectType = (firstByte & 0xf8) >> 3;
            if (audioObjectType === 31) {
              audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);
            }
            codec += '.' + audioObjectType;
          }
          break;
        }
      case 'hvc1':
      case 'hev1':
        {
          var hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];
          var profileByte = hvcCBox[1];
          var profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];
          var generalProfileIdc = profileByte & 0x1f;
          var profileCompat = readUint32(hvcCBox, 2);
          var tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';
          var levelIDC = hvcCBox[12];
          var constraintIndicator = hvcCBox.subarray(6, 12);
          codec += '.' + profileSpace + generalProfileIdc;
          codec += '.' + profileCompat.toString(16).toUpperCase();
          codec += '.' + tierFlag + levelIDC;
          var constraintString = '';
          for (var _i = constraintIndicator.length; _i--;) {
            var _byte = constraintIndicator[_i];
            if (_byte || constraintString) {
              var encodedByte = _byte.toString(16).toUpperCase();
              constraintString = '.' + encodedByte + constraintString;
            }
          }
          codec += constraintString;
          break;
        }
      case 'dvh1':
      case 'dvhe':
        {
          var dvcCBox = findBox(sampleEntriesEnd, ['dvcC'])[0];
          var profile = dvcCBox[2] >> 1 & 0x7f;
          var level = dvcCBox[2] << 5 & 0x20 | dvcCBox[3] >> 3 & 0x1f;
          codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level);
          break;
        }
      case 'vp09':
        {
          var vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];
          var _profile = vpcCBox[4];
          var _level = vpcCBox[5];
          var bitDepth = vpcCBox[6] >> 4 & 0x0f;
          codec += '.' + addLeadingZero(_profile) + '.' + addLeadingZero(_level) + '.' + addLeadingZero(bitDepth);
          break;
        }
      case 'av01':
        {
          var av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];
          var _profile2 = av1CBox[1] >>> 5;
          var _level2 = av1CBox[1] & 0x1f;
          var _tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';
          var highBitDepth = (av1CBox[2] & 0x40) >> 6;
          var twelveBit = (av1CBox[2] & 0x20) >> 5;
          var _bitDepth = _profile2 === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;
          var monochrome = (av1CBox[2] & 0x10) >> 4;
          var chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;
          var chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;
          var chromaSamplePosition = av1CBox[2] & 0x03;
          // TODO: parse color_description_present_flag
          // default it to BT.709/limited range for now
          // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax
          var colorPrimaries = 1;
          var transferCharacteristics = 1;
          var matrixCoefficients = 1;
          var videoFullRangeFlag = 0;
          codec += '.' + _profile2 + '.' + addLeadingZero(_level2) + _tierFlag + '.' + addLeadingZero(_bitDepth) + '.' + monochrome + '.' + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + '.' + addLeadingZero(colorPrimaries) + '.' + addLeadingZero(transferCharacteristics) + '.' + addLeadingZero(matrixCoefficients) + '.' + videoFullRangeFlag;
          break;
        }
    }
    return {
      codec: codec,
      encrypted: encrypted
    };
  }
  function skipBERInteger(bytes, i) {
    var limit = i + 5;
    while (bytes[i++] & 0x80 && i < limit) {}
    return i;
  }
  function toHex(x) {
    return ('0' + x.toString(16).toUpperCase()).slice(-2);
  }
  function addLeadingZero(num) {
    return (num < 10 ? '0' : '') + num;
  }
  function patchEncyptionData(initSegment, decryptdata) {
    if (!initSegment || !decryptdata) {
      return initSegment;
    }
    var keyId = decryptdata.keyId;
    if (keyId && decryptdata.isCommonEncryption) {
      var traks = findBox(initSegment, ['moov', 'trak']);
      traks.forEach(function (trak) {
        var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];

        // skip the sample entry count
        var sampleEntries = stsd.subarray(8);
        var encBoxes = findBox(sampleEntries, ['enca']);
        var isAudio = encBoxes.length > 0;
        if (!isAudio) {
          encBoxes = findBox(sampleEntries, ['encv']);
        }
        encBoxes.forEach(function (enc) {
          var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
          var sinfBoxes = findBox(encBoxChildren, ['sinf']);
          sinfBoxes.forEach(function (sinf) {
            var tenc = parseSinf(sinf);
            if (tenc) {
              // Look for default key id (keyID offset is always 8 within the tenc box):
              var tencKeyId = tenc.subarray(8, 24);
              if (!tencKeyId.some(function (b) {
                return b !== 0;
              })) {
                logger.log("[eme] Patching keyId in 'enc" + (isAudio ? 'a' : 'v') + ">sinf>>tenc' box: " + Hex.hexDump(tencKeyId) + " -> " + Hex.hexDump(keyId));
                tenc.set(keyId, 8);
              }
            }
          });
        });
      });
    }
    return initSegment;
  }
  function parseSinf(sinf) {
    var schm = findBox(sinf, ['schm'])[0];
    if (schm) {
      var scheme = bin2str(schm.subarray(4, 8));
      if (scheme === 'cbcs' || scheme === 'cenc') {
        return findBox(sinf, ['schi', 'tenc'])[0];
      }
    }
    return null;
  }

  /**
   * Determine the base media decode start time, in seconds, for an MP4
   * fragment. If multiple fragments are specified, the earliest time is
   * returned.
   *
   * The base media decode time can be parsed from track fragment
   * metadata:
   * ```
   * moof > traf > tfdt.baseMediaDecodeTime
   * ```
   * It requires the timescale value from the mdhd to interpret.
   *
   * @param initData - a hash of track type to timescale values
   * @param fmp4 - the bytes of the mp4 fragment
   * @returns the earliest base media decode start time for the
   * fragment, in seconds
   */
  function getStartDTS(initData, fmp4) {
    // we need info from two children of each track fragment box
    return findBox(fmp4, ['moof', 'traf']).reduce(function (result, traf) {
      var tfdt = findBox(traf, ['tfdt'])[0];
      var version = tfdt[0];
      var start = findBox(traf, ['tfhd']).reduce(function (result, tfhd) {
        // get the track id from the tfhd
        var id = readUint32(tfhd, 4);
        var track = initData[id];
        if (track) {
          var baseTime = readUint32(tfdt, 4);
          if (version === 1) {
            // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.
            // This prevents large values from being used for initPTS, which can cause playlist sync issues.
            // https://github.com/video-dev/hls.js/issues/5303
            if (baseTime === UINT32_MAX$1) {
              logger.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time");
              return result;
            }
            baseTime *= UINT32_MAX$1 + 1;
            baseTime += readUint32(tfdt, 8);
          }
          // assume a 90kHz clock if no timescale was specified
          var scale = track.timescale || 90e3;
          // convert base time to seconds
          var startTime = baseTime / scale;
          if (isFiniteNumber(startTime) && (result === null || startTime < result)) {
            return startTime;
          }
        }
        return result;
      }, null);
      if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {
        return start;
      }
      return result;
    }, null);
  }

  /*
    For Reference:
    aligned(8) class TrackFragmentHeaderBox
             extends FullBox(tfhd, 0, tf_flags){
       unsigned int(32)  track_ID;
       // all the following are optional fields
       unsigned int(64)  base_data_offset;
       unsigned int(32)  sample_description_index;
       unsigned int(32)  default_sample_duration;
       unsigned int(32)  default_sample_size;
       unsigned int(32)  default_sample_flags
    }
   */
  function getDuration(data, initData) {
    var rawDuration = 0;
    var videoDuration = 0;
    var audioDuration = 0;
    var trafs = findBox(data, ['moof', 'traf']);
    for (var i = 0; i < trafs.length; i++) {
      var traf = trafs[i];
      // There is only one tfhd & trun per traf
      // This is true for CMAF style content, and we should perhaps check the ftyp
      // and only look for a single trun then, but for ISOBMFF we should check
      // for multiple track runs.
      var tfhd = findBox(traf, ['tfhd'])[0];
      // get the track id from the tfhd
      var id = readUint32(tfhd, 4);
      var track = initData[id];
      if (!track) {
        continue;
      }
      var trackDefault = track.default;
      var tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);
      var sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;
      if (tfhdFlags & 0x000008) {
        // 0x000008 indicates the presence of the default_sample_duration field
        if (tfhdFlags & 0x000002) {
          // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration
          // If present, the default_sample_duration exists at byte offset 12
          sampleDuration = readUint32(tfhd, 12);
        } else {
          // Otherwise, the duration is at byte offset 8
          sampleDuration = readUint32(tfhd, 8);
        }
      }
      // assume a 90kHz clock if no timescale was specified
      var timescale = track.timescale || 90e3;
      var truns = findBox(traf, ['trun']);
      for (var j = 0; j < truns.length; j++) {
        rawDuration = computeRawDurationFromSamples(truns[j]);
        if (!rawDuration && sampleDuration) {
          var sampleCount = readUint32(truns[j], 4);
          rawDuration = sampleDuration * sampleCount;
        }
        if (track.type === ElementaryStreamTypes.VIDEO) {
          videoDuration += rawDuration / timescale;
        } else if (track.type === ElementaryStreamTypes.AUDIO) {
          audioDuration += rawDuration / timescale;
        }
      }
    }
    if (videoDuration === 0 && audioDuration === 0) {
      // If duration samples are not available in the traf use sidx subsegment_duration
      var sidxMinStart = Infinity;
      var sidxMaxEnd = 0;
      var sidxDuration = 0;
      var sidxs = findBox(data, ['sidx']);
      for (var _i2 = 0; _i2 < sidxs.length; _i2++) {
        var sidx = parseSegmentIndex(sidxs[_i2]);
        if (sidx != null && sidx.references) {
          sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);
          var subSegmentDuration = sidx.references.reduce(function (dur, ref) {
            return dur + ref.info.duration || 0;
          }, 0);
          sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);
          sidxDuration = sidxMaxEnd - sidxMinStart;
        }
      }
      if (sidxDuration && isFiniteNumber(sidxDuration)) {
        return sidxDuration;
      }
    }
    if (videoDuration) {
      return videoDuration;
    }
    return audioDuration;
  }

  /*
    For Reference:
    aligned(8) class TrackRunBox
             extends FullBox(trun, version, tr_flags) {
       unsigned int(32)  sample_count;
       // the following are optional fields
       signed int(32) data_offset;
       unsigned int(32)  first_sample_flags;
       // all fields in the following array are optional
       {
          unsigned int(32)  sample_duration;
          unsigned int(32)  sample_size;
          unsigned int(32)  sample_flags
          if (version == 0)
             { unsigned int(32)
          else
             { signed int(32)
       }[ sample_count ]
    }
   */
  function computeRawDurationFromSamples(trun) {
    var flags = readUint32(trun, 0);
    // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.
    // Each field is an int32, which is 4 bytes
    var offset = 8;
    // data-offset-present flag
    if (flags & 0x000001) {
      offset += 4;
    }
    // first-sample-flags-present flag
    if (flags & 0x000004) {
      offset += 4;
    }
    var duration = 0;
    var sampleCount = readUint32(trun, 4);
    for (var i = 0; i < sampleCount; i++) {
      // sample-duration-present flag
      if (flags & 0x000100) {
        var sampleDuration = readUint32(trun, offset);
        duration += sampleDuration;
        offset += 4;
      }
      // sample-size-present flag
      if (flags & 0x000200) {
        offset += 4;
      }
      // sample-flags-present flag
      if (flags & 0x000400) {
        offset += 4;
      }
      // sample-composition-time-offsets-present flag
      if (flags & 0x000800) {
        offset += 4;
      }
    }
    return duration;
  }
  function offsetStartDTS(initData, fmp4, timeOffset) {
    findBox(fmp4, ['moof', 'traf']).forEach(function (traf) {
      findBox(traf, ['tfhd']).forEach(function (tfhd) {
        // get the track id from the tfhd
        var id = readUint32(tfhd, 4);
        var track = initData[id];
        if (!track) {
          return;
        }
        // assume a 90kHz clock if no timescale was specified
        var timescale = track.timescale || 90e3;
        // get the base media decode time from the tfdt
        findBox(traf, ['tfdt']).forEach(function (tfdt) {
          var version = tfdt[0];
          var offset = timeOffset * timescale;
          if (offset) {
            var baseMediaDecodeTime = readUint32(tfdt, 4);
            if (version === 0) {
              baseMediaDecodeTime -= offset;
              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
              writeUint32(tfdt, 4, baseMediaDecodeTime);
            } else {
              baseMediaDecodeTime *= Math.pow(2, 32);
              baseMediaDecodeTime += readUint32(tfdt, 8);
              baseMediaDecodeTime -= offset;
              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
              var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));
              var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));
              writeUint32(tfdt, 4, upper);
              writeUint32(tfdt, 8, lower);
            }
          }
        });
      });
    });
  }

  // TODO: Check if the last moof+mdat pair is part of the valid range
  function segmentValidRange(data) {
    var segmentedRange = {
      valid: null,
      remainder: null
    };
    var moofs = findBox(data, ['moof']);
    if (moofs.length < 2) {
      segmentedRange.remainder = data;
      return segmentedRange;
    }
    var last = moofs[moofs.length - 1];
    // Offset by 8 bytes; findBox offsets the start by as much
    segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);
    segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);
    return segmentedRange;
  }
  function appendUint8Array(data1, data2) {
    var temp = new Uint8Array(data1.length + data2.length);
    temp.set(data1);
    temp.set(data2, data1.length);
    return temp;
  }
  function parseSamples(timeOffset, track) {
    var seiSamples = [];
    var videoData = track.samples;
    var timescale = track.timescale;
    var trackId = track.id;
    var isHEVCFlavor = false;
    var moofs = findBox(videoData, ['moof']);
    moofs.map(function (moof) {
      var moofOffset = moof.byteOffset - 8;
      var trafs = findBox(moof, ['traf']);
      trafs.map(function (traf) {
        // get the base media decode time from the tfdt
        var baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {
          var version = tfdt[0];
          var result = readUint32(tfdt, 4);
          if (version === 1) {
            result *= Math.pow(2, 32);
            result += readUint32(tfdt, 8);
          }
          return result / timescale;
        })[0];
        if (baseTime !== undefined) {
          timeOffset = baseTime;
        }
        return findBox(traf, ['tfhd']).map(function (tfhd) {
          var id = readUint32(tfhd, 4);
          var tfhdFlags = readUint32(tfhd, 0) & 0xffffff;
          var baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;
          var sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;
          var defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;
          var defaultSampleDuration = 0;
          var defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;
          var defaultSampleSize = 0;
          var defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;
          var tfhdOffset = 8;
          if (id === trackId) {
            if (baseDataOffsetPresent) {
              tfhdOffset += 8;
            }
            if (sampleDescriptionIndexPresent) {
              tfhdOffset += 4;
            }
            if (defaultSampleDurationPresent) {
              defaultSampleDuration = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleSizePresent) {
              defaultSampleSize = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleFlagsPresent) {
              tfhdOffset += 4;
            }
            if (track.type === 'video') {
              isHEVCFlavor = isHEVC(track.codec);
            }
            findBox(traf, ['trun']).map(function (trun) {
              var version = trun[0];
              var flags = readUint32(trun, 0) & 0xffffff;
              var dataOffsetPresent = (flags & 0x000001) !== 0;
              var dataOffset = 0;
              var firstSampleFlagsPresent = (flags & 0x000004) !== 0;
              var sampleDurationPresent = (flags & 0x000100) !== 0;
              var sampleDuration = 0;
              var sampleSizePresent = (flags & 0x000200) !== 0;
              var sampleSize = 0;
              var sampleFlagsPresent = (flags & 0x000400) !== 0;
              var sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;
              var compositionOffset = 0;
              var sampleCount = readUint32(trun, 4);
              var trunOffset = 8; // past version, flags, and sample count

              if (dataOffsetPresent) {
                dataOffset = readUint32(trun, trunOffset);
                trunOffset += 4;
              }
              if (firstSampleFlagsPresent) {
                trunOffset += 4;
              }
              var sampleOffset = dataOffset + moofOffset;
              for (var ix = 0; ix < sampleCount; ix++) {
                if (sampleDurationPresent) {
                  sampleDuration = readUint32(trun, trunOffset);
                  trunOffset += 4;
                } else {
                  sampleDuration = defaultSampleDuration;
                }
                if (sampleSizePresent) {
                  sampleSize = readUint32(trun, trunOffset);
                  trunOffset += 4;
                } else {
                  sampleSize = defaultSampleSize;
                }
                if (sampleFlagsPresent) {
                  trunOffset += 4;
                }
                if (sampleCompositionOffsetsPresent) {
                  if (version === 0) {
                    compositionOffset = readUint32(trun, trunOffset);
                  } else {
                    compositionOffset = readSint32(trun, trunOffset);
                  }
                  trunOffset += 4;
                }
                if (track.type === ElementaryStreamTypes.VIDEO) {
                  var naluTotalSize = 0;
                  while (naluTotalSize < sampleSize) {
                    var naluSize = readUint32(videoData, sampleOffset);
                    sampleOffset += 4;
                    if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                      var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                      parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);
                    }
                    sampleOffset += naluSize;
                    naluTotalSize += naluSize + 4;
                  }
                }
                timeOffset += sampleDuration / timescale;
              }
            });
          }
        });
      });
    });
    return seiSamples;
  }
  function isHEVC(codec) {
    if (!codec) {
      return false;
    }
    var delimit = codec.indexOf('.');
    var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);
    return baseCodec === 'hvc1' || baseCodec === 'hev1' ||
    // Dolby Vision
    baseCodec === 'dvh1' || baseCodec === 'dvhe';
  }
  function isSEIMessage(isHEVCFlavor, naluHeader) {
    if (isHEVCFlavor) {
      var naluType = naluHeader >> 1 & 0x3f;
      return naluType === 39 || naluType === 40;
    } else {
      var _naluType = naluHeader & 0x1f;
      return _naluType === 6;
    }
  }
  function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
    var data = discardEPB(unescapedData);
    var seiPtr = 0;
    // skip nal header
    seiPtr += headerSize;
    var payloadType = 0;
    var payloadSize = 0;
    var b = 0;
    while (seiPtr < data.length) {
      payloadType = 0;
      do {
        if (seiPtr >= data.length) {
          break;
        }
        b = data[seiPtr++];
        payloadType += b;
      } while (b === 0xff);

      // Parse payload size.
      payloadSize = 0;
      do {
        if (seiPtr >= data.length) {
          break;
        }
        b = data[seiPtr++];
        payloadSize += b;
      } while (b === 0xff);
      var leftOver = data.length - seiPtr;
      // Create a variable to process the payload
      var payPtr = seiPtr;

      // Increment the seiPtr to the end of the payload
      if (payloadSize < leftOver) {
        seiPtr += payloadSize;
      } else if (payloadSize > leftOver) {
        // Some type of corruption has happened?
        logger.error("Malformed SEI payload. " + payloadSize + " is too small, only " + leftOver + " bytes left to parse.");
        // We might be able to parse some data, but let's be safe and ignore it.
        break;
      }
      if (payloadType === 4) {
        var countryCode = data[payPtr++];
        if (countryCode === 181) {
          var providerCode = readUint16(data, payPtr);
          payPtr += 2;
          if (providerCode === 49) {
            var userStructure = readUint32(data, payPtr);
            payPtr += 4;
            if (userStructure === 0x47413934) {
              var userDataType = data[payPtr++];

              // Raw CEA-608 bytes wrapped in CEA-708 packet
              if (userDataType === 3) {
                var firstByte = data[payPtr++];
                var totalCCs = 0x1f & firstByte;
                var enabled = 0x40 & firstByte;
                var totalBytes = enabled ? 2 + totalCCs * 3 : 0;
                var byteArray = new Uint8Array(totalBytes);
                if (enabled) {
                  byteArray[0] = firstByte;
                  for (var i = 1; i < totalBytes; i++) {
                    byteArray[i] = data[payPtr++];
                  }
                }
                samples.push({
                  type: userDataType,
                  payloadType: payloadType,
                  pts: pts,
                  bytes: byteArray
                });
              }
            }
          }
        }
      } else if (payloadType === 5) {
        if (payloadSize > 16) {
          var uuidStrArray = [];
          for (var _i3 = 0; _i3 < 16; _i3++) {
            var _b = data[payPtr++].toString(16);
            uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);
            if (_i3 === 3 || _i3 === 5 || _i3 === 7 || _i3 === 9) {
              uuidStrArray.push('-');
            }
          }
          var length = payloadSize - 16;
          var userDataBytes = new Uint8Array(length);
          for (var _i4 = 0; _i4 < length; _i4++) {
            userDataBytes[_i4] = data[payPtr++];
          }
          samples.push({
            payloadType: payloadType,
            pts: pts,
            uuid: uuidStrArray.join(''),
            userData: utf8ArrayToStr(userDataBytes),
            userDataBytes: userDataBytes
          });
        }
      }
    }
  }

  /**
   * remove Emulation Prevention bytes from a RBSP
   */
  function discardEPB(data) {
    var length = data.byteLength;
    var EPBPositions = [];
    var i = 1;

    // Find all `Emulation Prevention Bytes`
    while (i < length - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
        EPBPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    }

    // If no Emulation Prevention Bytes were found just return the original
    // array
    if (EPBPositions.length === 0) {
      return data;
    }

    // Create a new array to hold the NAL unit data
    var newLength = length - EPBPositions.length;
    var newData = new Uint8Array(newLength);
    var sourceIndex = 0;
    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === EPBPositions[0]) {
        // Skip this byte
        sourceIndex++;
        // Remove this position index
        EPBPositions.shift();
      }
      newData[i] = data[sourceIndex];
    }
    return newData;
  }
  function parseEmsg(data) {
    var version = data[0];
    var schemeIdUri = '';
    var value = '';
    var timeScale = 0;
    var presentationTimeDelta = 0;
    var presentationTime = 0;
    var eventDuration = 0;
    var id = 0;
    var offset = 0;
    if (version === 0) {
      while (bin2str(data.subarray(offset, offset + 1)) !== '\0') {
        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
      while (bin2str(data.subarray(offset, offset + 1)) !== '\0') {
        value += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
      timeScale = readUint32(data, 12);
      presentationTimeDelta = readUint32(data, 16);
      eventDuration = readUint32(data, 20);
      id = readUint32(data, 24);
      offset = 28;
    } else if (version === 1) {
      offset += 4;
      timeScale = readUint32(data, offset);
      offset += 4;
      var leftPresentationTime = readUint32(data, offset);
      offset += 4;
      var rightPresentationTime = readUint32(data, offset);
      offset += 4;
      presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;
      if (!isSafeInteger(presentationTime)) {
        presentationTime = Number.MAX_SAFE_INTEGER;
        logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');
      }
      eventDuration = readUint32(data, offset);
      offset += 4;
      id = readUint32(data, offset);
      offset += 4;
      while (bin2str(data.subarray(offset, offset + 1)) !== '\0') {
        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
      while (bin2str(data.subarray(offset, offset + 1)) !== '\0') {
        value += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    var payload = data.subarray(offset, data.byteLength);
    return {
      schemeIdUri: schemeIdUri,
      value: value,
      timeScale: timeScale,
      presentationTime: presentationTime,
      presentationTimeDelta: presentationTimeDelta,
      eventDuration: eventDuration,
      id: id,
      payload: payload
    };
  }
  function mp4Box(type) {
    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      payload[_key - 1] = arguments[_key];
    }
    var len = payload.length;
    var size = 8;
    var i = len;
    while (i--) {
      size += payload[i].byteLength;
    }
    var result = new Uint8Array(size);
    result[0] = size >> 24 & 0xff;
    result[1] = size >> 16 & 0xff;
    result[2] = size >> 8 & 0xff;
    result[3] = size & 0xff;
    result.set(type, 4);
    for (i = 0, size = 8; i < len; i++) {
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  }
  function mp4pssh(systemId, keyids, data) {
    if (systemId.byteLength !== 16) {
      throw new RangeError('Invalid system id');
    }
    var version;
    var kids;
    if (keyids) {
      version = 1;
      kids = new Uint8Array(keyids.length * 16);
      for (var ix = 0; ix < keyids.length; ix++) {
        var k = keyids[ix]; // uint8array
        if (k.byteLength !== 16) {
          throw new RangeError('Invalid key');
        }
        kids.set(k, ix * 16);
      }
    } else {
      version = 0;
      kids = new Uint8Array();
    }
    var kidCount;
    if (version > 0) {
      kidCount = new Uint8Array(4);
      if (keyids.length > 0) {
        new DataView(kidCount.buffer).setUint32(0, keyids.length, false);
      }
    } else {
      kidCount = new Uint8Array();
    }
    var dataSize = new Uint8Array(4);
    if (data && data.byteLength > 0) {
      new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);
    }
    return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags
    ]), systemId,
    // 16 bytes
    kidCount, kids, dataSize, data || new Uint8Array());
  }
  function parseMultiPssh(initData) {
    var results = [];
    if (initData instanceof ArrayBuffer) {
      var length = initData.byteLength;
      var offset = 0;
      while (offset + 32 < length) {
        var view = new DataView(initData, offset);
        var pssh = parsePssh(view);
        results.push(pssh);
        offset += pssh.size;
      }
    }
    return results;
  }
  function parsePssh(view) {
    var size = view.getUint32(0);
    var offset = view.byteOffset;
    var length = view.byteLength;
    if (length < size) {
      return {
        offset: offset,
        size: length
      };
    }
    var type = view.getUint32(4);
    if (type !== 0x70737368) {
      return {
        offset: offset,
        size: size
      };
    }
    var version = view.getUint32(8) >>> 24;
    if (version !== 0 && version !== 1) {
      return {
        offset: offset,
        size: size
      };
    }
    var buffer = view.buffer;
    var systemId = Hex.hexDump(new Uint8Array(buffer, offset + 12, 16));
    var dataSizeOrKidCount = view.getUint32(28);
    var kids = null;
    var data = null;
    if (version === 0) {
      if (size - 32 < dataSizeOrKidCount || dataSizeOrKidCount < 22) {
        return {
          offset: offset,
          size: size
        };
      }
      data = new Uint8Array(buffer, offset + 32, dataSizeOrKidCount);
    } else if (version === 1) {
      if (!dataSizeOrKidCount || length < offset + 32 + dataSizeOrKidCount * 16 + 16) {
        return {
          offset: offset,
          size: size
        };
      }
      kids = [];
      for (var i = 0; i < dataSizeOrKidCount; i++) {
        kids.push(new Uint8Array(buffer, offset + 32 + i * 16, 16));
      }
    }
    return {
      version: version,
      systemId: systemId,
      kids: kids,
      data: data,
      offset: offset,
      size: size
    };
  }

  var keyUriToKeyIdMap = {};
  var LevelKey = /*#__PURE__*/function () {
    LevelKey.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {
      keyUriToKeyIdMap = {};
    };
    function LevelKey(method, uri, format, formatversions, iv) {
      if (formatversions === void 0) {
        formatversions = [1];
      }
      if (iv === void 0) {
        iv = null;
      }
      this.uri = void 0;
      this.method = void 0;
      this.keyFormat = void 0;
      this.keyFormatVersions = void 0;
      this.encrypted = void 0;
      this.isCommonEncryption = void 0;
      this.iv = null;
      this.key = null;
      this.keyId = null;
      this.pssh = null;
      this.method = method;
      this.uri = uri;
      this.keyFormat = format;
      this.keyFormatVersions = formatversions;
      this.iv = iv;
      this.encrypted = method ? method !== 'NONE' : false;
      this.isCommonEncryption = this.encrypted && method !== 'AES-128';
    }
    var _proto = LevelKey.prototype;
    _proto.isSupported = function isSupported() {
      // If it's Segment encryption or No encryption, just select that key system
      if (this.method) {
        if (this.method === 'AES-128' || this.method === 'NONE') {
          return true;
        }
        if (this.keyFormat === 'identity') {
          // Maintain support for clear SAMPLE-AES with MPEG-3 TS
          return this.method === 'SAMPLE-AES';
        } else {
          switch (this.keyFormat) {
            case KeySystemFormats.FAIRPLAY:
            case KeySystemFormats.WIDEVINE:
            case KeySystemFormats.PLAYREADY:
            case KeySystemFormats.CLEARKEY:
              return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;
          }
        }
      }
      return false;
    };
    _proto.getDecryptData = function getDecryptData(sn) {
      if (!this.encrypted || !this.uri) {
        return null;
      }
      if (this.method === 'AES-128' && this.uri && !this.iv) {
        if (typeof sn !== 'number') {
          // We are fetching decryption data for a initialization segment
          // If the segment was encrypted with AES-128
          // It must have an IV defined. We cannot substitute the Segment Number in.
          if (this.method === 'AES-128' && !this.iv) {
            logger.warn("missing IV for initialization segment with method=\"" + this.method + "\" - compliance issue");
          }
          // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.
          sn = 0;
        }
        var iv = createInitializationVector(sn);
        var decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);
        return decryptdata;
      }

      // Initialize keyId if possible
      var keyBytes = convertDataUriToArrayBytes(this.uri);
      if (keyBytes) {
        switch (this.keyFormat) {
          case KeySystemFormats.WIDEVINE:
            // Setting `pssh` on this LevelKey/DecryptData allows HLS.js to generate a session using
            // the playlist-key before the "encrypted" event. (Comment out to only use "encrypted" path.)
            this.pssh = keyBytes;
            // In case of widevine keyID is embedded in PSSH box. Read Key ID.
            if (keyBytes.length >= 22) {
              this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);
            }
            break;
          case KeySystemFormats.PLAYREADY:
            {
              var PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);

              // Setting `pssh` on this LevelKey/DecryptData allows HLS.js to generate a session using
              // the playlist-key before the "encrypted" event. (Comment out to only use "encrypted" path.)
              this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);
              this.keyId = parsePlayReadyWRM(keyBytes);
              break;
            }
          default:
            {
              var keydata = keyBytes.subarray(0, 16);
              if (keydata.length !== 16) {
                var padded = new Uint8Array(16);
                padded.set(keydata, 16 - keydata.length);
                keydata = padded;
              }
              this.keyId = keydata;
              break;
            }
        }
      }

      // Default behavior: assign a new keyId for each uri
      if (!this.keyId || this.keyId.byteLength !== 16) {
        var keyId = keyUriToKeyIdMap[this.uri];
        if (!keyId) {
          var val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;
          keyId = new Uint8Array(16);
          var dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes
          dv.setUint32(0, val);
          keyUriToKeyIdMap[this.uri] = keyId;
        }
        this.keyId = keyId;
      }
      return this;
    };
    return LevelKey;
  }();
  function createInitializationVector(segmentNumber) {
    var uint8View = new Uint8Array(16);
    for (var i = 12; i < 16; i++) {
      uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
    }
    return uint8View;
  }

  var VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
  function hasVariableReferences(str) {
    return VARIABLE_REPLACEMENT_REGEX.test(str);
  }
  function substituteVariablesInAttributes(parsed, attr, attributeNames) {
    if (parsed.variableList !== null || parsed.hasVariableRefs) {
      for (var i = attributeNames.length; i--;) {
        var name = attributeNames[i];
        var value = attr[name];
        if (value) {
          attr[name] = substituteVariables(parsed, value);
        }
      }
    }
  }
  function substituteVariables(parsed, value) {
    if (parsed.variableList !== null || parsed.hasVariableRefs) {
      var variableList = parsed.variableList;
      return value.replace(VARIABLE_REPLACEMENT_REGEX, function (variableReference) {
        var variableName = variableReference.substring(2, variableReference.length - 1);
        var variableValue = variableList == null ? void 0 : variableList[variableName];
        if (variableValue === undefined) {
          parsed.playlistParsingError || (parsed.playlistParsingError = new Error("Missing preceding EXT-X-DEFINE tag for Variable Reference: \"" + variableName + "\""));
          return variableReference;
        }
        return variableValue;
      });
    }
    return value;
  }
  function addVariableDefinition(parsed, attr, parentUrl) {
    var variableList = parsed.variableList;
    if (!variableList) {
      parsed.variableList = variableList = {};
    }
    var NAME;
    var VALUE;
    if ('QUERYPARAM' in attr) {
      NAME = attr.QUERYPARAM;
      try {
        var searchParams = new self.URL(parentUrl).searchParams;
        if (searchParams.has(NAME)) {
          VALUE = searchParams.get(NAME);
        } else {
          throw new Error("\"" + NAME + "\" does not match any query parameter in URI: \"" + parentUrl + "\"");
        }
      } catch (error) {
        parsed.playlistParsingError || (parsed.playlistParsingError = new Error("EXT-X-DEFINE QUERYPARAM: " + error.message));
      }
    } else {
      NAME = attr.NAME;
      VALUE = attr.VALUE;
    }
    if (NAME in variableList) {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error("EXT-X-DEFINE duplicate Variable Name declarations: \"" + NAME + "\""));
    } else {
      variableList[NAME] = VALUE || '';
    }
  }
  function importVariableDefinition(parsed, attr, sourceVariableList) {
    var IMPORT = attr.IMPORT;
    if (sourceVariableList && IMPORT in sourceVariableList) {
      var variableList = parsed.variableList;
      if (!variableList) {
        parsed.variableList = variableList = {};
      }
      variableList[IMPORT] = sourceVariableList[IMPORT];
    } else {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error("EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \"" + IMPORT + "\""));
    }
  }

  /**
   * MediaSource helper
   */

  function getMediaSource(preferManagedMediaSource) {
    if (preferManagedMediaSource === void 0) {
      preferManagedMediaSource = true;
    }
    if (typeof self === 'undefined') return undefined;
    var mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;
    return mms || self.MediaSource || self.WebKitMediaSource;
  }
  function isManagedMediaSource(source) {
    return typeof self !== 'undefined' && source === self.ManagedMediaSource;
  }

  // from http://mp4ra.org/codecs.html
  // values indicate codec selection preference (lower is higher priority)
  var sampleEntryCodesISO = {
    audio: {
      a3ds: 1,
      'ac-3': 0.95,
      'ac-4': 1,
      alac: 0.9,
      alaw: 1,
      dra1: 1,
      'dts+': 1,
      'dts-': 1,
      dtsc: 1,
      dtse: 1,
      dtsh: 1,
      'ec-3': 0.9,
      enca: 1,
      fLaC: 0.9,
      // MP4-RA listed codec entry for FLAC
      flac: 0.9,
      // legacy browser codec name for FLAC
      FLAC: 0.9,
      // some manifests may list "FLAC" with Apple's tools
      g719: 1,
      g726: 1,
      m4ae: 1,
      mha1: 1,
      mha2: 1,
      mhm1: 1,
      mhm2: 1,
      mlpa: 1,
      mp4a: 1,
      'raw ': 1,
      Opus: 1,
      opus: 1,
      // browsers expect this to be lowercase despite MP4RA says 'Opus'
      samr: 1,
      sawb: 1,
      sawp: 1,
      sevc: 1,
      sqcp: 1,
      ssmv: 1,
      twos: 1,
      ulaw: 1
    },
    video: {
      avc1: 1,
      avc2: 1,
      avc3: 1,
      avc4: 1,
      avcp: 1,
      av01: 0.8,
      drac: 1,
      dva1: 1,
      dvav: 1,
      dvh1: 0.7,
      dvhe: 0.7,
      encv: 1,
      hev1: 0.75,
      hvc1: 0.75,
      mjp2: 1,
      mp4v: 1,
      mvc1: 1,
      mvc2: 1,
      mvc3: 1,
      mvc4: 1,
      resv: 1,
      rv60: 1,
      s263: 1,
      svc1: 1,
      svc2: 1,
      'vc-1': 1,
      vp08: 1,
      vp09: 0.9
    },
    text: {
      stpp: 1,
      wvtt: 1
    }
  };
  function isCodecType(codec, type) {
    var typeCodes = sampleEntryCodesISO[type];
    return !!typeCodes && !!typeCodes[codec.slice(0, 4)];
  }
  function areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource) {
    if (preferManagedMediaSource === void 0) {
      preferManagedMediaSource = true;
    }
    return !codecs.split(',').some(function (codec) {
      return !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource);
    });
  }
  function isCodecMediaSourceSupported(codec, type, preferManagedMediaSource) {
    var _MediaSource$isTypeSu;
    if (preferManagedMediaSource === void 0) {
      preferManagedMediaSource = true;
    }
    var MediaSource = getMediaSource(preferManagedMediaSource);
    return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;
  }
  function mimeTypeForCodec(codec, type) {
    return type + "/mp4;codecs=\"" + codec + "\"";
  }
  function videoCodecPreferenceValue(videoCodec) {
    if (videoCodec) {
      var fourCC = videoCodec.substring(0, 4);
      return sampleEntryCodesISO.video[fourCC];
    }
    return 2;
  }
  function codecsSetSelectionPreferenceValue(codecSet) {
    return codecSet.split(',').reduce(function (num, fourCC) {
      var preferenceValue = sampleEntryCodesISO.video[fourCC];
      if (preferenceValue) {
        return (preferenceValue * 2 + num) / (num ? 3 : 2);
      }
      return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);
    }, 0);
  }
  var CODEC_COMPATIBLE_NAMES = {};
  function getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource) {
    if (preferManagedMediaSource === void 0) {
      preferManagedMediaSource = true;
    }
    if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {
      return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];
    }

    // Idealy fLaC and Opus would be first (spec-compliant) but
    // some browsers will report that fLaC is supported then fail.
    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728
    var codecsToCheck = {
      flac: ['flac', 'fLaC', 'FLAC'],
      opus: ['opus', 'Opus']
    }[lowerCaseCodec];
    for (var i = 0; i < codecsToCheck.length; i++) {
      if (isCodecMediaSourceSupported(codecsToCheck[i], 'audio', preferManagedMediaSource)) {
        CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];
        return codecsToCheck[i];
      }
    }
    return lowerCaseCodec;
  }
  var AUDIO_CODEC_REGEXP = /flac|opus/i;
  function getCodecCompatibleName(codec, preferManagedMediaSource) {
    if (preferManagedMediaSource === void 0) {
      preferManagedMediaSource = true;
    }
    return codec.replace(AUDIO_CODEC_REGEXP, function (m) {
      return getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource);
    });
  }
  function pickMostCompleteCodecName(parsedCodec, levelCodec) {
    // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a
    // so use level codec is parsed codec is unavailable or incomplete
    if (parsedCodec && parsedCodec !== 'mp4a') {
      return parsedCodec;
    }
    return levelCodec ? levelCodec.split(',')[0] : levelCodec;
  }
  function convertAVC1ToAVCOTI(codec) {
    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported
    // Examples: avc1.66.30 to avc1.42001e and avc1.77.30,avc1.66.30 to avc1.4d001e,avc1.42001e.
    var codecs = codec.split(',');
    for (var i = 0; i < codecs.length; i++) {
      var avcdata = codecs[i].split('.');
      if (avcdata.length > 2) {
        var result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);
        codecs[i] = result;
      }
    }
    return codecs.join(',');
  }

  var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g;
  var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
  var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)

  var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
  /(?!#) *(\S[^\r\n]*)/.source,
  // segment URI, group 3 => the URI (note newline is not eaten)
  /#EXT-X-BYTERANGE:*(.+)/.source,
  // next segment's byterange, group 4 => range spec (x@y)
  /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
  // next segment's program date/time group 5 => the datetime spec
  /#.*/.source // All other non-segment oriented tags will match with all groups empty
  ].join('|'), 'g');
  var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join('|'));
  var M3U8Parser = /*#__PURE__*/function () {
    function M3U8Parser() {}
    M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        if (group.id === mediaGroupId) {
          return group;
        }
      }
    };
    M3U8Parser.resolve = function resolve(url, baseUrl) {
      return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {
        alwaysNormalize: true
      });
    };
    M3U8Parser.isMediaPlaylist = function isMediaPlaylist(str) {
      return IS_MEDIA_PLAYLIST.test(str);
    };
    M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
      var hasVariableRefs = hasVariableReferences(string) ;
      var parsed = {
        contentSteering: null,
        levels: [],
        playlistParsingError: null,
        sessionData: null,
        sessionKeys: null,
        startTimeOffset: null,
        variableList: null,
        hasVariableRefs: hasVariableRefs
      };
      var levelsWithKnownCodecs = [];
      MASTER_PLAYLIST_REGEX.lastIndex = 0;
      var result;
      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        if (result[1]) {
          var _level$unknownCodecs;
          // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1
          var attrs = new AttrList(result[1]);
          {
            substituteVariablesInAttributes(parsed, attrs, ['CODECS', 'SUPPLEMENTAL-CODECS', 'ALLOWED-CPC', 'PATHWAY-ID', 'STABLE-VARIANT-ID', 'AUDIO', 'VIDEO', 'SUBTITLES', 'CLOSED-CAPTIONS', 'NAME']);
          }
          var uri = substituteVariables(parsed, result[2]) ;
          var level = {
            attrs: attrs,
            bitrate: attrs.decimalInteger('BANDWIDTH') || attrs.decimalInteger('AVERAGE-BANDWIDTH'),
            name: attrs.NAME,
            url: M3U8Parser.resolve(uri, baseurl)
          };
          var resolution = attrs.decimalResolution('RESOLUTION');
          if (resolution) {
            level.width = resolution.width;
            level.height = resolution.height;
          }
          setCodecs(attrs.CODECS, level);
          if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {
            levelsWithKnownCodecs.push(level);
          }
          parsed.levels.push(level);
        } else if (result[3]) {
          var tag = result[3];
          var attributes = result[4];
          switch (tag) {
            case 'SESSION-DATA':
              {
                // #EXT-X-SESSION-DATA
                var sessionAttrs = new AttrList(attributes);
                {
                  substituteVariablesInAttributes(parsed, sessionAttrs, ['DATA-ID', 'LANGUAGE', 'VALUE', 'URI']);
                }
                var dataId = sessionAttrs['DATA-ID'];
                if (dataId) {
                  if (parsed.sessionData === null) {
                    parsed.sessionData = {};
                  }
                  parsed.sessionData[dataId] = sessionAttrs;
                }
                break;
              }
            case 'SESSION-KEY':
              {
                // #EXT-X-SESSION-KEY
                var sessionKey = parseKey(attributes, baseurl, parsed);
                if (sessionKey.encrypted && sessionKey.isSupported()) {
                  if (parsed.sessionKeys === null) {
                    parsed.sessionKeys = [];
                  }
                  parsed.sessionKeys.push(sessionKey);
                } else {
                  logger.warn("[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"" + attributes + "\"");
                }
                break;
              }
            case 'DEFINE':
              {
                // #EXT-X-DEFINE
                {
                  var variableAttributes = new AttrList(attributes);
                  substituteVariablesInAttributes(parsed, variableAttributes, ['NAME', 'VALUE', 'QUERYPARAM']);
                  addVariableDefinition(parsed, variableAttributes, baseurl);
                }
                break;
              }
            case 'CONTENT-STEERING':
              {
                // #EXT-X-CONTENT-STEERING
                var contentSteeringAttributes = new AttrList(attributes);
                {
                  substituteVariablesInAttributes(parsed, contentSteeringAttributes, ['SERVER-URI', 'PATHWAY-ID']);
                }
                parsed.contentSteering = {
                  uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),
                  pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'
                };
                break;
              }
            case 'START':
              {
                // #EXT-X-START
                parsed.startTimeOffset = parseStartTimeOffset(attributes);
                break;
              }
          }
        }
      }
      // Filter out levels with unknown codecs if it does not remove all levels
      var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;
      parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;
      if (parsed.levels.length === 0) {
        parsed.playlistParsingError = new Error('no levels found in manifest');
      }
      return parsed;
    };
    M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, parsed) {
      var result;
      var results = {};
      var levels = parsed.levels;
      var groupsByType = {
        AUDIO: levels.map(function (level) {
          return {
            id: level.attrs.AUDIO,
            audioCodec: level.audioCodec
          };
        }),
        SUBTITLES: levels.map(function (level) {
          return {
            id: level.attrs.SUBTITLES,
            textCodec: level.textCodec
          };
        }),
        'CLOSED-CAPTIONS': []
      };
      var id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
        var attrs = new AttrList(result[1]);
        var type = attrs.TYPE;
        if (type) {
          var groups = groupsByType[type];
          var medias = results[type] || [];
          results[type] = medias;
          {
            substituteVariablesInAttributes(parsed, attrs, ['URI', 'GROUP-ID', 'LANGUAGE', 'ASSOC-LANGUAGE', 'STABLE-RENDITION-ID', 'NAME', 'INSTREAM-ID', 'CHARACTERISTICS', 'CHANNELS']);
          }
          var lang = attrs.LANGUAGE;
          var assocLang = attrs['ASSOC-LANGUAGE'];
          var channels = attrs.CHANNELS;
          var characteristics = attrs.CHARACTERISTICS;
          var instreamId = attrs['INSTREAM-ID'];
          var media = {
            attrs: attrs,
            bitrate: 0,
            id: id++,
            groupId: attrs['GROUP-ID'] || '',
            name: attrs.NAME || lang || '',
            type: type,
            default: attrs.bool('DEFAULT'),
            autoselect: attrs.bool('AUTOSELECT'),
            forced: attrs.bool('FORCED'),
            lang: lang,
            url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''
          };
          if (assocLang) {
            media.assocLang = assocLang;
          }
          if (channels) {
            media.channels = channels;
          }
          if (characteristics) {
            media.characteristics = characteristics;
          }
          if (instreamId) {
            media.instreamId = instreamId;
          }
          if (groups != null && groups.length) {
            // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track
            // If we don't find the track signalled, lets use the first audio groups codec we have
            // Acting as a best guess
            var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];
            assignCodec(media, groupCodec, 'audioCodec');
            assignCodec(media, groupCodec, 'textCodec');
          }
          medias.push(media);
        }
      }
      return results;
    };
    M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {
      var level = new LevelDetails(baseurl);
      var fragments = level.fragments;
      // The most recent init segment seen (applies to all subsequent segments)
      var currentInitSegment = null;
      var currentSN = 0;
      var currentPart = 0;
      var totalduration = 0;
      var discontinuityCounter = 0;
      var prevFrag = null;
      var frag = new Fragment(type, baseurl);
      var result;
      var i;
      var levelkeys;
      var firstPdtIndex = -1;
      var createNextFrag = false;
      var nextByteRange = null;
      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
      level.m3u8 = string;
      level.hasVariableRefs = hasVariableReferences(string) ;
      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        if (createNextFrag) {
          createNextFrag = false;
          frag = new Fragment(type, baseurl);
          // setup the next fragment for part loading
          frag.start = totalduration;
          frag.sn = currentSN;
          frag.cc = discontinuityCounter;
          frag.level = id;
          if (currentInitSegment) {
            frag.initSegment = currentInitSegment;
            frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
            currentInitSegment.rawProgramDateTime = null;
            if (nextByteRange) {
              frag.setByteRange(nextByteRange);
              nextByteRange = null;
            }
          }
        }
        var duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var title = (' ' + result[2]).slice(1);
          frag.title = title || null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (isFiniteNumber(frag.duration)) {
            frag.start = totalduration;
            if (levelkeys) {
              setFragLevelKeys(frag, levelkeys, level);
            }
            frag.sn = currentSN;
            frag.level = id;
            frag.cc = discontinuityCounter;
            fragments.push(frag);
            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
            var uri = (' ' + result[3]).slice(1);
            frag.relurl = substituteVariables(level, uri) ;
            assignProgramDateTime(frag, prevFrag);
            prevFrag = frag;
            totalduration += frag.duration;
            currentSN++;
            currentPart = 0;
            createNextFrag = true;
          }
        } else if (result[4]) {
          // X-BYTERANGE
          var data = (' ' + result[4]).slice(1);
          if (prevFrag) {
            frag.setByteRange(data, prevFrag);
          } else {
            frag.setByteRange(data);
          }
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.rawProgramDateTime = (' ' + result[5]).slice(1);
          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
          if (firstPdtIndex === -1) {
            firstPdtIndex = fragments.length;
          }
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          if (!result) {
            logger.warn('No matches on slow regex match for level playlist!');
            continue;
          }
          for (i = 1; i < result.length; i++) {
            if (typeof result[i] !== 'undefined') {
              break;
            }
          }

          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var tag = (' ' + result[i]).slice(1);
          var value1 = (' ' + result[i + 1]).slice(1);
          var value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';
          switch (tag) {
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'SKIP':
              {
                var skipAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, skipAttrs, ['RECENTLY-REMOVED-DATERANGES']);
                }
                var skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');
                if (isFiniteNumber(skippedSegments)) {
                  level.skippedSegments = skippedSegments;
                  // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`
                  for (var _i = skippedSegments; _i--;) {
                    fragments.unshift(null);
                  }
                  currentSN += skippedSegments;
                }
                var recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');
                if (recentlyRemovedDateranges) {
                  level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\t');
                }
                break;
              }
            case 'TARGETDURATION':
              level.targetduration = Math.max(parseInt(value1), 1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'INDEPENDENT-SEGMENTS':
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case '#':
              if (value1 || value2) {
                frag.tagList.push(value2 ? [value1, value2] : [value1]);
              }
              break;
            case 'DISCONTINUITY':
              discontinuityCounter++;
              frag.tagList.push(['DIS']);
              break;
            case 'GAP':
              frag.gap = true;
              frag.tagList.push([tag]);
              break;
            case 'BITRATE':
              frag.tagList.push([tag, value1]);
              break;
            case 'DATERANGE':
              {
                var dateRangeAttr = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, dateRangeAttr, ['ID', 'CLASS', 'START-DATE', 'END-DATE', 'SCTE35-CMD', 'SCTE35-OUT', 'SCTE35-IN']);
                  substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);
                }
                var dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);
                if (dateRange.isValid || level.skippedSegments) {
                  level.dateRanges[dateRange.id] = dateRange;
                } else {
                  logger.warn("Ignoring invalid DATERANGE tag: \"" + value1 + "\"");
                }
                // Add to fragment tag list for backwards compatibility (< v1.2.0)
                frag.tagList.push(['EXT-X-DATERANGE', value1]);
                break;
              }
            case 'DEFINE':
              {
                {
                  var variableAttributes = new AttrList(value1);
                  substituteVariablesInAttributes(level, variableAttributes, ['NAME', 'VALUE', 'IMPORT', 'QUERYPARAM']);
                  if ('IMPORT' in variableAttributes) {
                    importVariableDefinition(level, variableAttributes, multivariantVariableList);
                  } else {
                    addVariableDefinition(level, variableAttributes, baseurl);
                  }
                }
                break;
              }
            case 'DISCONTINUITY-SEQUENCE':
              discontinuityCounter = parseInt(value1);
              break;
            case 'KEY':
              {
                var levelKey = parseKey(value1, baseurl, level);
                if (levelKey.isSupported()) {
                  if (levelKey.method === 'NONE') {
                    levelkeys = undefined;
                    break;
                  }
                  if (!levelkeys) {
                    levelkeys = {};
                  }
                  if (levelkeys[levelKey.keyFormat]) {
                    levelkeys = _extends({}, levelkeys);
                  }
                  levelkeys[levelKey.keyFormat] = levelKey;
                } else {
                  logger.warn("[Keys] Ignoring invalid EXT-X-KEY tag: \"" + value1 + "\"");
                }
                break;
              }
            case 'START':
              level.startTimeOffset = parseStartTimeOffset(value1);
              break;
            case 'MAP':
              {
                var mapAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, mapAttrs, ['BYTERANGE', 'URI']);
                }
                if (frag.duration) {
                  // Initial segment tag is after segment duration tag.
                  //   #EXTINF: 6.0
                  //   #EXT-X-MAP:URI="init.mp4
                  var init = new Fragment(type, baseurl);
                  setInitSegment(init, mapAttrs, id, levelkeys);
                  currentInitSegment = init;
                  frag.initSegment = currentInitSegment;
                  if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                  }
                } else {
                  // Initial segment tag is before segment duration tag
                  // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE
                  var end = frag.byteRangeEndOffset;
                  if (end) {
                    var start = frag.byteRangeStartOffset;
                    nextByteRange = end - start + "@" + start;
                  } else {
                    nextByteRange = null;
                  }
                  setInitSegment(frag, mapAttrs, id, levelkeys);
                  currentInitSegment = frag;
                  createNextFrag = true;
                }
                break;
              }
            case 'SERVER-CONTROL':
              {
                var serverControlAttrs = new AttrList(value1);
                level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');
                level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);
                level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');
                level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);
                level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);
                break;
              }
            case 'PART-INF':
              {
                var partInfAttrs = new AttrList(value1);
                level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');
                break;
              }
            case 'PART':
              {
                var partList = level.partList;
                if (!partList) {
                  partList = level.partList = [];
                }
                var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;
                var index = currentPart++;
                var partAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, partAttrs, ['BYTERANGE', 'URI']);
                }
                var part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);
                partList.push(part);
                frag.duration += part.duration;
                break;
              }
            case 'PRELOAD-HINT':
              {
                var preloadHintAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, preloadHintAttrs, ['URI']);
                }
                level.preloadHint = preloadHintAttrs;
                break;
              }
            case 'RENDITION-REPORT':
              {
                var renditionReportAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, renditionReportAttrs, ['URI']);
                }
                level.renditionReports = level.renditionReports || [];
                level.renditionReports.push(renditionReportAttrs);
                break;
              }
            default:
              logger.warn("line parsed but not handled: " + result);
              break;
          }
        }
      }
      if (prevFrag && !prevFrag.relurl) {
        fragments.pop();
        totalduration -= prevFrag.duration;
        if (level.partList) {
          level.fragmentHint = prevFrag;
        }
      } else if (level.partList) {
        assignProgramDateTime(frag, prevFrag);
        frag.cc = discontinuityCounter;
        level.fragmentHint = frag;
        if (levelkeys) {
          setFragLevelKeys(frag, levelkeys, level);
        }
      }
      var fragmentLength = fragments.length;
      var firstFragment = fragments[0];
      var lastFragment = fragments[fragmentLength - 1];
      totalduration += level.skippedSegments * level.targetduration;
      if (totalduration > 0 && fragmentLength && lastFragment) {
        level.averagetargetduration = totalduration / fragmentLength;
        var lastSn = lastFragment.sn;
        level.endSN = lastSn !== 'initSegment' ? lastSn : 0;
        if (!level.live) {
          lastFragment.endList = true;
        }
        if (firstFragment) {
          level.startCC = firstFragment.cc;
        }
      } else {
        level.endSN = 0;
        level.startCC = 0;
      }
      if (level.fragmentHint) {
        totalduration += level.fragmentHint.duration;
      }
      level.totalduration = totalduration;
      level.endCC = discontinuityCounter;

      /**
       * Backfill any missing PDT values
       * "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
       * one or more Media Segment URIs, the client SHOULD extrapolate
       * backward from that tag (using EXTINF durations and/or media
       * timestamps) to associate dates with those segments."
       * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
       * computed.
       */
      if (firstPdtIndex > 0) {
        backfillProgramDateTimes(fragments, firstPdtIndex);
      }
      return level;
    };
    return M3U8Parser;
  }();
  function parseKey(keyTagAttributes, baseurl, parsed) {
    var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;
    // https://tools.ietf.org/html/rfc8216#section-4.3.2.4
    var keyAttrs = new AttrList(keyTagAttributes);
    {
      substituteVariablesInAttributes(parsed, keyAttrs, ['KEYFORMAT', 'KEYFORMATVERSIONS', 'URI', 'IV', 'URI']);
    }
    var decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';
    var decrypturi = keyAttrs.URI;
    var decryptiv = keyAttrs.hexadecimalInteger('IV');
    var decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;
    // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of "identity".
    var decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';
    if (decrypturi && keyAttrs.IV && !decryptiv) {
      logger.error("Invalid IV: " + keyAttrs.IV);
    }
    // If decrypturi is a URI with a scheme, then baseurl will be ignored
    // No uri is allowed when METHOD is NONE
    var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';
    var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);
    return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);
  }
  function parseStartTimeOffset(startAttributes) {
    var startAttrs = new AttrList(startAttributes);
    var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
    if (isFiniteNumber(startTimeOffset)) {
      return startTimeOffset;
    }
    return null;
  }
  function setCodecs(codecsAttributeValue, level) {
    var codecs = (codecsAttributeValue || '').split(/[ ,]+/).filter(function (c) {
      return c;
    });
    ['video', 'audio', 'text'].forEach(function (type) {
      var filtered = codecs.filter(function (codec) {
        return isCodecType(codec, type);
      });
      if (filtered.length) {
        // Comma separated list of all codecs for type
        level[type + "Codec"] = filtered.join(',');
        // Remove known codecs so that only unknownCodecs are left after iterating through each type
        codecs = codecs.filter(function (codec) {
          return filtered.indexOf(codec) === -1;
        });
      }
    });
    level.unknownCodecs = codecs;
  }
  function assignCodec(media, groupItem, codecProperty) {
    var codecValue = groupItem[codecProperty];
    if (codecValue) {
      media[codecProperty] = codecValue;
    }
  }
  function backfillProgramDateTimes(fragments, firstPdtIndex) {
    var fragPrev = fragments[firstPdtIndex];
    for (var i = firstPdtIndex; i--;) {
      var frag = fragments[i];
      // Exit on delta-playlist skipped segments
      if (!frag) {
        return;
      }
      frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;
      fragPrev = frag;
    }
  }
  function assignProgramDateTime(frag, prevFrag) {
    if (frag.rawProgramDateTime) {
      frag.programDateTime = Date.parse(frag.rawProgramDateTime);
    } else if (prevFrag != null && prevFrag.programDateTime) {
      frag.programDateTime = prevFrag.endProgramDateTime;
    }
    if (!isFiniteNumber(frag.programDateTime)) {
      frag.programDateTime = null;
      frag.rawProgramDateTime = null;
    }
  }
  function setInitSegment(frag, mapAttrs, id, levelkeys) {
    frag.relurl = mapAttrs.URI;
    if (mapAttrs.BYTERANGE) {
      frag.setByteRange(mapAttrs.BYTERANGE);
    }
    frag.level = id;
    frag.sn = 'initSegment';
    if (levelkeys) {
      frag.levelkeys = levelkeys;
    }
    frag.initSegment = null;
  }
  function setFragLevelKeys(frag, levelkeys, level) {
    frag.levelkeys = levelkeys;
    var encryptedFragments = level.encryptedFragments;
    if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function (format) {
      return levelkeys[format].isCommonEncryption;
    })) {
      encryptedFragments.push(frag);
    }
  }

  var PlaylistContextType = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack"
  };
  var PlaylistLevelType = {
    MAIN: "main",
    AUDIO: "audio",
    SUBTITLE: "subtitle"
  };

  function mapContextToLevelType(context) {
    var type = context.type;
    switch (type) {
      case PlaylistContextType.AUDIO_TRACK:
        return PlaylistLevelType.AUDIO;
      case PlaylistContextType.SUBTITLE_TRACK:
        return PlaylistLevelType.SUBTITLE;
      default:
        return PlaylistLevelType.MAIN;
    }
  }
  function getResponseUrl(response, context) {
    var url = response.url;
    // responseURL not supported on some browsers (it is used to detect URL redirection)
    // data-uri mode also not supported (but no need to detect redirection)
    if (url === undefined || url.indexOf('data:') === 0) {
      // fallback to initial URL
      url = context.url;
    }
    return url;
  }
  var PlaylistLoader = /*#__PURE__*/function () {
    function PlaylistLoader(hls) {
      this.hls = void 0;
      this.loaders = Object.create(null);
      this.variableList = null;
      this.hls = hls;
      this.registerListeners();
    }
    var _proto = PlaylistLoader.prototype;
    _proto.startLoad = function startLoad(startPosition) {};
    _proto.stopLoad = function stopLoad() {
      this.destroyInternalLoaders();
    };
    _proto.registerListeners = function registerListeners() {
      var hls = this.hls;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
      hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
    };
    _proto.unregisterListeners = function unregisterListeners() {
      var hls = this.hls;
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
      hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
    }

    /**
     * Returns defaults or configured loader-type overloads (pLoader and loader config params)
     */;
    _proto.createInternalLoader = function createInternalLoader(context) {
      var config = this.hls.config;
      var PLoader = config.pLoader;
      var Loader = config.loader;
      var InternalLoader = PLoader || Loader;
      var loader = new InternalLoader(config);
      this.loaders[context.type] = loader;
      return loader;
    };
    _proto.getInternalLoader = function getInternalLoader(context) {
      return this.loaders[context.type];
    };
    _proto.resetInternalLoader = function resetInternalLoader(contextType) {
      if (this.loaders[contextType]) {
        delete this.loaders[contextType];
      }
    }

    /**
     * Call `destroy` on all internal loader instances mapped (one per context type)
     */;
    _proto.destroyInternalLoaders = function destroyInternalLoaders() {
      for (var contextType in this.loaders) {
        var loader = this.loaders[contextType];
        if (loader) {
          loader.destroy();
        }
        this.resetInternalLoader(contextType);
      }
    };
    _proto.destroy = function destroy() {
      this.variableList = null;
      this.unregisterListeners();
      this.destroyInternalLoaders();
    };
    _proto.onManifestLoading = function onManifestLoading(event, data) {
      var url = data.url;
      this.variableList = null;
      this.load({
        id: null,
        level: 0,
        responseType: 'text',
        type: PlaylistContextType.MANIFEST,
        url: url,
        deliveryDirectives: null
      });
    };
    _proto.onLevelLoading = function onLevelLoading(event, data) {
      var id = data.id,
        level = data.level,
        pathwayId = data.pathwayId,
        url = data.url,
        deliveryDirectives = data.deliveryDirectives;
      this.load({
        id: id,
        level: level,
        pathwayId: pathwayId,
        responseType: 'text',
        type: PlaylistContextType.LEVEL,
        url: url,
        deliveryDirectives: deliveryDirectives
      });
    };
    _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {
      var id = data.id,
        groupId = data.groupId,
        url = data.url,
        deliveryDirectives = data.deliveryDirectives;
      this.load({
        id: id,
        groupId: groupId,
        level: null,
        responseType: 'text',
        type: PlaylistContextType.AUDIO_TRACK,
        url: url,
        deliveryDirectives: deliveryDirectives
      });
    };
    _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {
      var id = data.id,
        groupId = data.groupId,
        url = data.url,
        deliveryDirectives = data.deliveryDirectives;
      this.load({
        id: id,
        groupId: groupId,
        level: null,
        responseType: 'text',
        type: PlaylistContextType.SUBTITLE_TRACK,
        url: url,
        deliveryDirectives: deliveryDirectives
      });
    };
    _proto.load = function load(context) {
      var _context$deliveryDire,
        _this = this;
      var config = this.hls.config;

      // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);

      // Check if a loader for this context already exists
      var loader = this.getInternalLoader(context);
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {
          // same URL can't overlap
          logger.trace('[playlist-loader]: playlist request ongoing');
          return;
        }
        logger.log("[playlist-loader]: aborting previous loader for type: " + context.type);
        loader.abort();
      }

      // apply different configs for retries depending on
      // context (manifest, level, audio/subs playlist)
      var loadPolicy;
      if (context.type === PlaylistContextType.MANIFEST) {
        loadPolicy = config.manifestLoadPolicy.default;
      } else {
        loadPolicy = _extends({}, config.playlistLoadPolicy.default, {
          timeoutRetry: null,
          errorRetry: null
        });
      }
      loader = this.createInternalLoader(context);

      // Override level/track timeout for LL-HLS requests
      // (the default of 10000ms is counter productive to blocking playlist reload requests)
      if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {
        var levelDetails;
        if (context.type === PlaylistContextType.LEVEL && context.level !== null) {
          levelDetails = this.hls.levels[context.level].details;
        } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {
          levelDetails = this.hls.audioTracks[context.id].details;
        } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {
          levelDetails = this.hls.subtitleTracks[context.id].details;
        }
        if (levelDetails) {
          var partTarget = levelDetails.partTarget;
          var targetDuration = levelDetails.targetduration;
          if (partTarget && targetDuration) {
            var maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;
            loadPolicy = _extends({}, loadPolicy, {
              maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),
              maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)
            });
          }
        }
      }
      var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
      var loaderConfig = {
        loadPolicy: loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
      };
      var loaderCallbacks = {
        onSuccess: function onSuccess(response, stats, context, networkDetails) {
          var loader = _this.getInternalLoader(context);
          _this.resetInternalLoader(context.type);
          var string = response.data;

          // Validate if it is an M3U8 at all
          if (string.indexOf('#EXTM3U') !== 0) {
            _this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);
            return;
          }
          stats.parsing.start = performance.now();
          if (M3U8Parser.isMediaPlaylist(string)) {
            _this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);
          } else {
            _this.handleMasterPlaylist(response, stats, context, networkDetails);
          }
        },
        onError: function onError(response, context, networkDetails, stats) {
          _this.handleNetworkError(context, networkDetails, false, response, stats);
        },
        onTimeout: function onTimeout(stats, context, networkDetails) {
          _this.handleNetworkError(context, networkDetails, true, undefined, stats);
        }
      };

      // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);

      loader.load(context, loaderConfig, loaderCallbacks);
    };
    _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {
      var hls = this.hls;
      var string = response.data;
      var url = getResponseUrl(response, context);
      var parsedResult = M3U8Parser.parseMasterPlaylist(string, url);
      if (parsedResult.playlistParsingError) {
        this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);
        return;
      }
      var contentSteering = parsedResult.contentSteering,
        levels = parsedResult.levels,
        sessionData = parsedResult.sessionData,
        sessionKeys = parsedResult.sessionKeys,
        startTimeOffset = parsedResult.startTimeOffset,
        variableList = parsedResult.variableList;
      this.variableList = variableList;
      var _M3U8Parser$parseMast = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult),
        _M3U8Parser$parseMast2 = _M3U8Parser$parseMast.AUDIO,
        audioTracks = _M3U8Parser$parseMast2 === void 0 ? [] : _M3U8Parser$parseMast2,
        subtitles = _M3U8Parser$parseMast.SUBTITLES,
        captions = _M3U8Parser$parseMast['CLOSED-CAPTIONS'];
      if (audioTracks.length) {
        // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
        var embeddedAudioFound = audioTracks.some(function (audioTrack) {
          return !audioTrack.url;
        });

        // if no embedded audio track defined, but audio codec signaled in quality level,
        // we need to signal this main audio track this could happen with playlists with
        // alt audio rendition in which quality levels (main)
        // contains both audio+video. but with mixed audio track not signaled
        if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
          logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');
          audioTracks.unshift({
            type: 'main',
            name: 'main',
            groupId: 'main',
            default: false,
            autoselect: false,
            forced: false,
            id: -1,
            attrs: new AttrList({}),
            bitrate: 0,
            url: ''
          });
        }
      }
      hls.trigger(Events.MANIFEST_LOADED, {
        levels: levels,
        audioTracks: audioTracks,
        subtitles: subtitles,
        captions: captions,
        contentSteering: contentSteering,
        url: url,
        stats: stats,
        networkDetails: networkDetails,
        sessionData: sessionData,
        sessionKeys: sessionKeys,
        startTimeOffset: startTimeOffset,
        variableList: variableList
      });
    };
    _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {
      var hls = this.hls;
      var id = context.id,
        level = context.level,
        type = context.type;
      var url = getResponseUrl(response, context);
      var levelUrlId = 0;
      var levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;
      var levelType = mapContextToLevelType(context);
      var levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);

      // We have done our first request (Manifest-type) and receive
      // not a master playlist but a chunk-list (track/level)
      // We fire the manifest-loaded event anyway with the parsed level-details
      // by creating a single-level structure for it.
      if (type === PlaylistContextType.MANIFEST) {
        var singleLevel = {
          attrs: new AttrList({}),
          bitrate: 0,
          details: levelDetails,
          name: '',
          url: url
        };
        hls.trigger(Events.MANIFEST_LOADED, {
          levels: [singleLevel],
          audioTracks: [],
          url: url,
          stats: stats,
          networkDetails: networkDetails,
          sessionData: null,
          sessionKeys: null,
          contentSteering: null,
          startTimeOffset: null,
          variableList: null
        });
      }

      // save parsing time
      stats.parsing.end = performance.now();

      // extend the context with the new levelDetails property
      context.levelDetails = levelDetails;
      this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);
    };
    _proto.handleManifestParsingError = function handleManifestParsingError(response, context, error, networkDetails, stats) {
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.MANIFEST_PARSING_ERROR,
        fatal: context.type === PlaylistContextType.MANIFEST,
        url: response.url,
        err: error,
        error: error,
        reason: error.message,
        response: response,
        context: context,
        networkDetails: networkDetails,
        stats: stats
      });
    };
    _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response, stats) {
      if (timeout === void 0) {
        timeout = false;
      }
      var message = "A network " + (timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')) + " occurred while loading " + context.type;
      if (context.type === PlaylistContextType.LEVEL) {
        message += ": " + context.level + " id: " + context.id;
      } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {
        message += " id: " + context.id + " group-id: \"" + context.groupId + "\"";
      }
      var error = new Error(message);
      logger.warn("[playlist-loader]: " + message);
      var details = ErrorDetails.UNKNOWN;
      var fatal = false;
      var loader = this.getInternalLoader(context);
      switch (context.type) {
        case PlaylistContextType.MANIFEST:
          details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case PlaylistContextType.LEVEL:
          details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case PlaylistContextType.AUDIO_TRACK:
          details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
        case PlaylistContextType.SUBTITLE_TRACK:
          details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        this.resetInternalLoader(context.type);
      }
      var errorData = {
        type: ErrorTypes.NETWORK_ERROR,
        details: details,
        fatal: fatal,
        url: context.url,
        loader: loader,
        context: context,
        error: error,
        networkDetails: networkDetails,
        stats: stats
      };
      if (response) {
        var url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;
        errorData.response = _objectSpread2({
          url: url,
          data: undefined
        }, response);
      }
      this.hls.trigger(Events.ERROR, errorData);
    };
    _proto.handlePlaylistLoaded = function handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {
      var hls = this.hls;
      var type = context.type,
        level = context.level,
        id = context.id,
        groupId = context.groupId,
        deliveryDirectives = context.deliveryDirectives;
      var url = getResponseUrl(response, context);
      var parent = mapContextToLevelType(context);
      var levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;
      if (!levelDetails.fragments.length) {
        var _error = new Error('No Segments found in Playlist');
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.LEVEL_EMPTY_ERROR,
          fatal: false,
          url: url,
          error: _error,
          reason: _error.message,
          response: response,
          context: context,
          level: levelIndex,
          parent: parent,
          networkDetails: networkDetails,
          stats: stats
        });
        return;
      }
      if (!levelDetails.targetduration) {
        levelDetails.playlistParsingError = new Error('Missing Target Duration');
      }
      var error = levelDetails.playlistParsingError;
      if (error) {
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.LEVEL_PARSING_ERROR,
          fatal: false,
          url: url,
          error: error,
          reason: error.message,
          response: response,
          context: context,
          level: levelIndex,
          parent: parent,
          networkDetails: networkDetails,
          stats: stats
        });
        return;
      }
      if (levelDetails.live && loader) {
        if (loader.getCacheAge) {
          levelDetails.ageHeader = loader.getCacheAge() || 0;
        }
        if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
          levelDetails.ageHeader = 0;
        }
      }
      switch (type) {
        case PlaylistContextType.MANIFEST:
        case PlaylistContextType.LEVEL:
          hls.trigger(Events.LEVEL_LOADED, {
            details: levelDetails,
            level: levelIndex || 0,
            id: id || 0,
            stats: stats,
            networkDetails: networkDetails,
            deliveryDirectives: deliveryDirectives
          });
          break;
        case PlaylistContextType.AUDIO_TRACK:
          hls.trigger(Events.AUDIO_TRACK_LOADED, {
            details: levelDetails,
            id: id || 0,
            groupId: groupId || '',
            stats: stats,
            networkDetails: networkDetails,
            deliveryDirectives: deliveryDirectives
          });
          break;
        case PlaylistContextType.SUBTITLE_TRACK:
          hls.trigger(Events.SUBTITLE_TRACK_LOADED, {
            details: levelDetails,
            id: id || 0,
            groupId: groupId || '',
            stats: stats,
            networkDetails: networkDetails,
            deliveryDirectives: deliveryDirectives
          });
          break;
      }
    };
    return PlaylistLoader;
  }();

  function sendAddTrackEvent(track, videoEl) {
    var event;
    try {
      event = new Event('addtrack');
    } catch (err) {
      // for IE11
      event = document.createEvent('Event');
      event.initEvent('addtrack', false, false);
    }
    event.track = track;
    videoEl.dispatchEvent(event);
  }
  function addCueToTrack(track, cue) {
    // Sometimes there are cue overlaps on segmented vtts so the same
    // cue can appear more than once in different vtt files.
    // This avoid showing duplicated cues with same timecode and text.
    var mode = track.mode;
    if (mode === 'disabled') {
      track.mode = 'hidden';
    }
    if (track.cues && !track.cues.getCueById(cue.id)) {
      try {
        track.addCue(cue);
        if (!track.cues.getCueById(cue.id)) {
          throw new Error("addCue is failed for: " + cue);
        }
      } catch (err) {
        logger.debug("[texttrack-utils]: " + err);
        try {
          var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
          textTrackCue.id = cue.id;
          track.addCue(textTrackCue);
        } catch (err2) {
          logger.debug("[texttrack-utils]: Legacy TextTrackCue fallback failed: " + err2);
        }
      }
    }
    if (mode === 'disabled') {
      track.mode = mode;
    }
  }
  function clearCurrentCues(track) {
    // When track.mode is disabled, track.cues will be null.
    // To guarantee the removal of cues, we need to temporarily
    // change the mode to hidden
    var mode = track.mode;
    if (mode === 'disabled') {
      track.mode = 'hidden';
    }
    if (track.cues) {
      for (var i = track.cues.length; i--;) {
        track.removeCue(track.cues[i]);
      }
    }
    if (mode === 'disabled') {
      track.mode = mode;
    }
  }
  function removeCuesInRange(track, start, end, predicate) {
    var mode = track.mode;
    if (mode === 'disabled') {
      track.mode = 'hidden';
    }
    if (track.cues && track.cues.length > 0) {
      var cues = getCuesInRange(track.cues, start, end);
      for (var i = 0; i < cues.length; i++) {
        if (!predicate || predicate(cues[i])) {
          track.removeCue(cues[i]);
        }
      }
    }
    if (mode === 'disabled') {
      track.mode = mode;
    }
  }

  // Find first cue starting after given time.
  // Modified version of binary search O(log(n)).
  function getFirstCueIndexAfterTime(cues, time) {
    // If first cue starts after time, start there
    if (time < cues[0].startTime) {
      return 0;
    }
    // If the last cue ends before time there is no overlap
    var len = cues.length - 1;
    if (time > cues[len].endTime) {
      return -1;
    }
    var left = 0;
    var right = len;
    while (left <= right) {
      var mid = Math.floor((right + left) / 2);
      if (time < cues[mid].startTime) {
        right = mid - 1;
      } else if (time > cues[mid].startTime && left < len) {
        left = mid + 1;
      } else {
        // If it's not lower or higher, it must be equal.
        return mid;
      }
    }
    // At this point, left and right have swapped.
    // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.
    return cues[left].startTime - time < time - cues[right].startTime ? left : right;
  }
  function getCuesInRange(cues, start, end) {
    var cuesFound = [];
    var firstCueInRange = getFirstCueIndexAfterTime(cues, start);
    if (firstCueInRange > -1) {
      for (var i = firstCueInRange, len = cues.length; i < len; i++) {
        var _cue = cues[i];
        if (_cue.startTime >= start && _cue.endTime <= end) {
          cuesFound.push(_cue);
        } else if (_cue.startTime > end) {
          return cuesFound;
        }
      }
    }
    return cuesFound;
  }
  function filterSubtitleTracks(textTrackList) {
    var tracks = [];
    for (var i = 0; i < textTrackList.length; i++) {
      var track = textTrackList[i];
      // Edge adds a track without a label; we don't want to use it
      if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {
        tracks.push(textTrackList[i]);
      }
    }
    return tracks;
  }

  var MetadataSchema = {
    audioId3: "org.id3",
    dateRange: "com.apple.quicktime.HLS",
    emsg: "https://aomedia.org/emsg/ID3"
  };

  var MIN_CUE_DURATION = 0.25;
  function getCueClass() {
    if (typeof self === 'undefined') return undefined;
    return self.VTTCue || self.TextTrackCue;
  }
  function createCueWithDataFields(Cue, startTime, endTime, data, type) {
    var cue = new Cue(startTime, endTime, '');
    try {
      cue.value = data;
      if (type) {
        cue.type = type;
      }
    } catch (e) {
      cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({
        type: type
      }, data) : data));
    }
    return cue;
  }

  // VTTCue latest draft allows an infinite duration, fallback
  // to MAX_VALUE if necessary
  var MAX_CUE_ENDTIME = function () {
    var Cue = getCueClass();
    try {
      Cue && new Cue(0, Number.POSITIVE_INFINITY, '');
    } catch (e) {
      return Number.MAX_VALUE;
    }
    return Number.POSITIVE_INFINITY;
  }();
  function dateRangeDateToTimelineSeconds(date, offset) {
    return date.getTime() / 1000 - offset;
  }
  function hexToArrayBuffer(str) {
    return Uint8Array.from(str.replace(/^0x/, '').replace(/([\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;
  }
  var ID3TrackController = /*#__PURE__*/function () {
    function ID3TrackController(hls) {
      this.hls = void 0;
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
      this.hls = hls;
      this._registerListeners();
    }
    var _proto = ID3TrackController.prototype;
    _proto.destroy = function destroy() {
      this._unregisterListeners();
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
      // @ts-ignore
      this.hls = null;
    };
    _proto._registerListeners = function _registerListeners() {
      var hls = this.hls;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    };
    _proto._unregisterListeners = function _unregisterListeners() {
      var hls = this.hls;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    }

    // Add ID3 metatadata text track.
    ;
    _proto.onMediaAttached = function onMediaAttached(event, data) {
      this.media = data.media;
    };
    _proto.onMediaDetaching = function onMediaDetaching() {
      if (!this.id3Track) {
        return;
      }
      clearCurrentCues(this.id3Track);
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
    };
    _proto.onManifestLoading = function onManifestLoading() {
      this.dateRangeCuesAppended = {};
    };
    _proto.createTrack = function createTrack(media) {
      var track = this.getID3Track(media.textTracks);
      track.mode = 'hidden';
      return track;
    };
    _proto.getID3Track = function getID3Track(textTracks) {
      if (!this.media) {
        return;
      }
      for (var i = 0; i < textTracks.length; i++) {
        var textTrack = textTracks[i];
        if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {
          // send 'addtrack' when reusing the textTrack for metadata,
          // same as what we do for captions
          sendAddTrackEvent(textTrack, this.media);
          return textTrack;
        }
      }
      return this.media.addTextTrack('metadata', 'id3');
    };
    _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {
      if (!this.media) {
        return;
      }
      var _this$hls$config = this.hls.config,
        enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues,
        enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;
      if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
        return;
      }
      var samples = data.samples;

      // create track dynamically
      if (!this.id3Track) {
        this.id3Track = this.createTrack(this.media);
      }
      var Cue = getCueClass();
      if (!Cue) {
        return;
      }
      for (var i = 0; i < samples.length; i++) {
        var type = samples[i].type;
        if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
          continue;
        }
        var frames = getID3Frames(samples[i].data);
        if (frames) {
          var startTime = samples[i].pts;
          var endTime = startTime + samples[i].duration;
          if (endTime > MAX_CUE_ENDTIME) {
            endTime = MAX_CUE_ENDTIME;
          }
          var timeDiff = endTime - startTime;
          if (timeDiff <= 0) {
            endTime = startTime + MIN_CUE_DURATION;
          }
          for (var j = 0; j < frames.length; j++) {
            var frame = frames[j];
            // Safari doesn't put the timestamp frame in the TextTrack
            if (!isTimeStampFrame(frame)) {
              // add a bounds to any unbounded cues
              this.updateId3CueEnds(startTime, type);
              var cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);
              if (cue) {
                this.id3Track.addCue(cue);
              }
            }
          }
        }
      }
    };
    _proto.updateId3CueEnds = function updateId3CueEnds(startTime, type) {
      var _this$id3Track;
      var cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;
      if (cues) {
        for (var i = cues.length; i--;) {
          var cue = cues[i];
          if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
            cue.endTime = startTime;
          }
        }
      }
    };
    _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {
      var startOffset = _ref.startOffset,
        endOffset = _ref.endOffset,
        type = _ref.type;
      var id3Track = this.id3Track,
        hls = this.hls;
      if (!hls) {
        return;
      }
      var _hls$config = hls.config,
        enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues,
        enableID3MetadataCues = _hls$config.enableID3MetadataCues;
      if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
        var predicate;
        if (type === 'audio') {
          predicate = function predicate(cue) {
            return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;
          };
        } else if (type === 'video') {
          predicate = function predicate(cue) {
            return cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
          };
        } else {
          predicate = function predicate(cue) {
            return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
          };
        }
        removeCuesInRange(id3Track, startOffset, endOffset, predicate);
      }
    };
    _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {
      var _this = this;
      var details = _ref2.details;
      if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
        return;
      }
      var dateRangeCuesAppended = this.dateRangeCuesAppended,
        id3Track = this.id3Track;
      var dateRanges = details.dateRanges;
      var ids = Object.keys(dateRanges);
      // Remove cues from track not found in details.dateRanges
      if (id3Track) {
        var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function (id) {
          return !ids.includes(id);
        });
        var _loop = function _loop() {
          var id = idsToRemove[i];
          Object.keys(dateRangeCuesAppended[id].cues).forEach(function (key) {
            id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);
          });
          delete dateRangeCuesAppended[id];
        };
        for (var i = idsToRemove.length; i--;) {
          _loop();
        }
      }
      // Exit if the playlist does not have Date Ranges or does not have Program Date Time
      var lastFragment = details.fragments[details.fragments.length - 1];
      if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {
        return;
      }
      if (!this.id3Track) {
        this.id3Track = this.createTrack(this.media);
      }
      var dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;
      var Cue = getCueClass();
      var _loop2 = function _loop2() {
        var id = ids[_i];
        var dateRange = dateRanges[id];
        var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);

        // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)
        var appendedDateRangeCues = dateRangeCuesAppended[id];
        var cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};
        var durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;
        var endTime = MAX_CUE_ENDTIME;
        var endDate = dateRange.endDate;
        if (endDate) {
          endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);
          durationKnown = true;
        } else if (dateRange.endOnNext && !durationKnown) {
          var nextDateRangeWithSameClass = ids.reduce(function (candidateDateRange, id) {
            if (id !== dateRange.id) {
              var otherDateRange = dateRanges[id];
              if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {
                return otherDateRange;
              }
            }
            return candidateDateRange;
          }, null);
          if (nextDateRangeWithSameClass) {
            endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);
            durationKnown = true;
          }
        }

        // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)
        // This is to emulate Safari HLS playback handling of DateRange tags
        var attributes = Object.keys(dateRange.attr);
        for (var j = 0; j < attributes.length; j++) {
          var key = attributes[j];
          if (!isDateRangeCueAttribute(key)) {
            continue;
          }
          var cue = cues[key];
          if (cue) {
            if (durationKnown && !appendedDateRangeCues.durationKnown) {
              cue.endTime = endTime;
            }
          } else if (Cue) {
            var data = dateRange.attr[key];
            if (isSCTE35Attribute(key)) {
              data = hexToArrayBuffer(data);
            }
            var _cue = createCueWithDataFields(Cue, startTime, endTime, {
              key: key,
              data: data
            }, MetadataSchema.dateRange);
            if (_cue) {
              _cue.id = id;
              _this.id3Track.addCue(_cue);
              cues[key] = _cue;
            }
          }
        }

        // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes
        dateRangeCuesAppended[id] = {
          cues: cues,
          dateRange: dateRange,
          durationKnown: durationKnown
        };
      };
      for (var _i = 0; _i < ids.length; _i++) {
        _loop2();
      }
    };
    return ID3TrackController;
  }();

  var LatencyController = /*#__PURE__*/function () {
    function LatencyController(hls) {
      var _this = this;
      this.hls = void 0;
      this.config = void 0;
      this.media = null;
      this.levelDetails = null;
      this.currentTime = 0;
      this.stallCount = 0;
      this._latency = null;
      this.timeupdateHandler = function () {
        return _this.timeupdate();
      };
      this.hls = hls;
      this.config = hls.config;
      this.registerListeners();
    }
    var _proto = LatencyController.prototype;
    _proto.destroy = function destroy() {
      this.unregisterListeners();
      this.onMediaDetaching();
      this.levelDetails = null;
      // @ts-ignore
      this.hls = this.timeupdateHandler = null;
    };
    _proto.registerListeners = function registerListeners() {
      this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      this.hls.on(Events.ERROR, this.onError, this);
    };
    _proto.unregisterListeners = function unregisterListeners() {
      this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      this.hls.off(Events.ERROR, this.onError, this);
    };
    _proto.onMediaAttached = function onMediaAttached(event, data) {
      this.media = data.media;
      this.media.addEventListener('timeupdate', this.timeupdateHandler);
    };
    _proto.onMediaDetaching = function onMediaDetaching() {
      if (this.media) {
        this.media.removeEventListener('timeupdate', this.timeupdateHandler);
        this.media = null;
      }
    };
    _proto.onManifestLoading = function onManifestLoading() {
      this.levelDetails = null;
      this._latency = null;
      this.stallCount = 0;
    };
    _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
      var details = _ref.details;
      this.levelDetails = details;
      if (details.advanced) {
        this.timeupdate();
      }
      if (!details.live && this.media) {
        this.media.removeEventListener('timeupdate', this.timeupdateHandler);
      }
    };
    _proto.onError = function onError(event, data) {
      var _this$levelDetails;
      if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {
        return;
      }
      this.stallCount++;
      if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {
        logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');
      }
    };
    _proto.timeupdate = function timeupdate() {
      var media = this.media,
        levelDetails = this.levelDetails;
      if (!media || !levelDetails) {
        return;
      }
      this.currentTime = media.currentTime;
      var latency = this.computeLatency();
      if (latency === null) {
        return;
      }
      this._latency = latency;

      // Adapt playbackRate to meet target latency in low-latency mode
      var _this$config = this.config,
        lowLatencyMode = _this$config.lowLatencyMode,
        maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;
      if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {
        return;
      }
      var targetLatency = this.targetLatency;
      if (targetLatency === null) {
        return;
      }
      var distanceFromTarget = latency - targetLatency;
      // Only adjust playbackRate when within one target duration of targetLatency
      // and more than one second from under-buffering.
      // Playback further than one target duration from target can be considered DVR playback.
      var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
      var inLiveRange = distanceFromTarget < liveMinLatencyDuration;
      if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
        var max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));
        var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
        media.playbackRate = Math.min(max, Math.max(1, rate));
      } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
        media.playbackRate = 1;
      }
    };
    _proto.estimateLiveEdge = function estimateLiveEdge() {
      var levelDetails = this.levelDetails;
      if (levelDetails === null) {
        return null;
      }
      return levelDetails.edge + levelDetails.age;
    };
    _proto.computeLatency = function computeLatency() {
      var liveEdge = this.estimateLiveEdge();
      if (liveEdge === null) {
        return null;
      }
      return liveEdge - this.currentTime;
    };
    _createClass(LatencyController, [{
      key: "latency",
      get: function get() {
        return this._latency || 0;
      }
    }, {
      key: "maxLatency",
      get: function get() {
        var config = this.config,
          levelDetails = this.levelDetails;
        if (config.liveMaxLatencyDuration !== undefined) {
          return config.liveMaxLatencyDuration;
        }
        return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
      }
    }, {
      key: "targetLatency",
      get: function get() {
        var levelDetails = this.levelDetails;
        if (levelDetails === null) {
          return null;
        }
        var holdBack = levelDetails.holdBack,
          partHoldBack = levelDetails.partHoldBack,
          targetduration = levelDetails.targetduration;
        var _this$config2 = this.config,
          liveSyncDuration = _this$config2.liveSyncDuration,
          liveSyncDurationCount = _this$config2.liveSyncDurationCount,
          lowLatencyMode = _this$config2.lowLatencyMode;
        var userConfig = this.hls.userConfig;
        var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
        if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
          targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;
        }
        var maxLiveSyncOnStallIncrease = targetduration;
        var liveSyncOnStallIncrease = 1.0;
        return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
      }
    }, {
      key: "liveSyncPosition",
      get: function get() {
        var liveEdge = this.estimateLiveEdge();
        var targetLatency = this.targetLatency;
        var levelDetails = this.levelDetails;
        if (liveEdge === null || targetLatency === null || levelDetails === null) {
          return null;
        }
        var edge = levelDetails.edge;
        var syncPosition = liveEdge - targetLatency - this.edgeStalled;
        var min = edge - levelDetails.totalduration;
        var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
        return Math.min(Math.max(min, syncPosition), max);
      }
    }, {
      key: "drift",
      get: function get() {
        var levelDetails = this.levelDetails;
        if (levelDetails === null) {
          return 1;
        }
        return levelDetails.drift;
      }
    }, {
      key: "edgeStalled",
      get: function get() {
        var levelDetails = this.levelDetails;
        if (levelDetails === null) {
          return 0;
        }
        var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
        return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
      }
    }, {
      key: "forwardBufferLength",
      get: function get() {
        var media = this.media,
          levelDetails = this.levelDetails;
        if (!media || !levelDetails) {
          return 0;
        }
        var bufferedRanges = media.buffered.length;
        return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
      }
    }]);
    return LatencyController;
  }();

  var HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];
  function isHdcpLevel(value) {
    return HdcpLevels.indexOf(value) > -1;
  }
  var VideoRangeValues = ['SDR', 'PQ', 'HLG'];
  function isVideoRange(value) {
    return !!value && VideoRangeValues.indexOf(value) > -1;
  }
  var HlsSkip = {
    No: "",
    Yes: "YES",
    v2: "v2"
  };
  function getSkipValue(details) {
    var canSkipUntil = details.canSkipUntil,
      canSkipDateRanges = details.canSkipDateRanges,
      age = details.age;
    // A Client SHOULD NOT request a Playlist Delta Update unless it already
    // has a version of the Playlist that is no older than one-half of the Skip Boundary.
    // @see: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-6.3.7
    var playlistRecentEnough = age < canSkipUntil / 2;
    if (canSkipUntil && playlistRecentEnough) {
      if (canSkipDateRanges) {
        return HlsSkip.v2;
      }
      return HlsSkip.Yes;
    }
    return HlsSkip.No;
  }
  var HlsUrlParameters = /*#__PURE__*/function () {
    function HlsUrlParameters(msn, part, skip) {
      this.msn = void 0;
      this.part = void 0;
      this.skip = void 0;
      this.msn = msn;
      this.part = part;
      this.skip = skip;
    }
    var _proto = HlsUrlParameters.prototype;
    _proto.addDirectives = function addDirectives(uri) {
      var url = new self.URL(uri);
      if (this.msn !== undefined) {
        url.searchParams.set('_HLS_msn', this.msn.toString());
      }
      if (this.part !== undefined) {
        url.searchParams.set('_HLS_part', this.part.toString());
      }
      if (this.skip) {
        url.searchParams.set('_HLS_skip', this.skip);
      }
      return url.href;
    };
    return HlsUrlParameters;
  }();
  var Level = /*#__PURE__*/function () {
    function Level(data) {
      this._attrs = void 0;
      this.audioCodec = void 0;
      this.bitrate = void 0;
      this.codecSet = void 0;
      this.url = void 0;
      this.frameRate = void 0;
      this.height = void 0;
      this.id = void 0;
      this.name = void 0;
      this.videoCodec = void 0;
      this.width = void 0;
      this.details = void 0;
      this.fragmentError = 0;
      this.loadError = 0;
      this.loaded = void 0;
      this.realBitrate = 0;
      this.supportedPromise = void 0;
      this.supportedResult = void 0;
      this._avgBitrate = 0;
      this._audioGroups = void 0;
      this._subtitleGroups = void 0;
      // Deprecated (retained for backwards compatibility)
      this._urlId = 0;
      this.url = [data.url];
      this._attrs = [data.attrs];
      this.bitrate = data.bitrate;
      if (data.details) {
        this.details = data.details;
      }
      this.id = data.id || 0;
      this.name = data.name;
      this.width = data.width || 0;
      this.height = data.height || 0;
      this.frameRate = data.attrs.optionalFloat('FRAME-RATE', 0);
      this._avgBitrate = data.attrs.decimalInteger('AVERAGE-BANDWIDTH');
      this.audioCodec = data.audioCodec;
      this.videoCodec = data.videoCodec;
      this.codecSet = [data.videoCodec, data.audioCodec].filter(function (c) {
        return !!c;
      }).map(function (s) {
        return s.substring(0, 4);
      }).join(',');
      this.addGroupId('audio', data.attrs.AUDIO);
      this.addGroupId('text', data.attrs.SUBTITLES);
    }
    var _proto2 = Level.prototype;
    _proto2.hasAudioGroup = function hasAudioGroup(groupId) {
      return hasGroup(this._audioGroups, groupId);
    };
    _proto2.hasSubtitleGroup = function hasSubtitleGroup(groupId) {
      return hasGroup(this._subtitleGroups, groupId);
    };
    _proto2.addGroupId = function addGroupId(type, groupId) {
      if (!groupId) {
        return;
      }
      if (type === 'audio') {
        var audioGroups = this._audioGroups;
        if (!audioGroups) {
          audioGroups = this._audioGroups = [];
        }
        if (audioGroups.indexOf(groupId) === -1) {
          audioGroups.push(groupId);
        }
      } else if (type === 'text') {
        var subtitleGroups = this._subtitleGroups;
        if (!subtitleGroups) {
          subtitleGroups = this._subtitleGroups = [];
        }
        if (subtitleGroups.indexOf(groupId) === -1) {
          subtitleGroups.push(groupId);
        }
      }
    }

    // Deprecated methods (retained for backwards compatibility)
    ;
    _proto2.addFallback = function addFallback() {};
    _createClass(Level, [{
      key: "maxBitrate",
      get: function get() {
        return Math.max(this.realBitrate, this.bitrate);
      }
    }, {
      key: "averageBitrate",
      get: function get() {
        return this._avgBitrate || this.realBitrate || this.bitrate;
      }
    }, {
      key: "attrs",
      get: function get() {
        return this._attrs[0];
      }
    }, {
      key: "codecs",
      get: function get() {
        return this.attrs.CODECS || '';
      }
    }, {
      key: "pathwayId",
      get: function get() {
        return this.attrs['PATHWAY-ID'] || '.';
      }
    }, {
      key: "videoRange",
      get: function get() {
        return this.attrs['VIDEO-RANGE'] || 'SDR';
      }
    }, {
      key: "score",
      get: function get() {
        return this.attrs.optionalFloat('SCORE', 0);
      }
    }, {
      key: "uri",
      get: function get() {
        return this.url[0] || '';
      }
    }, {
      key: "audioGroups",
      get: function get() {
        return this._audioGroups;
      }
    }, {
      key: "subtitleGroups",
      get: function get() {
        return this._subtitleGroups;
      }
    }, {
      key: "urlId",
      get: function get() {
        return 0;
      },
      set: function set(value) {}
    }, {
      key: "audioGroupIds",
      get: function get() {
        return this.audioGroups ? [this.audioGroupId] : undefined;
      }
    }, {
      key: "textGroupIds",
      get: function get() {
        return this.subtitleGroups ? [this.textGroupId] : undefined;
      }
    }, {
      key: "audioGroupId",
      get: function get() {
        var _this$audioGroups;
        return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];
      }
    }, {
      key: "textGroupId",
      get: function get() {
        var _this$subtitleGroups;
        return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];
      }
    }]);
    return Level;
  }();
  function hasGroup(groups, groupId) {
    if (!groupId || !groups) {
      return false;
    }
    return groups.indexOf(groupId) !== -1;
  }

  function updateFromToPTS(fragFrom, fragTo) {
    var fragToPTS = fragTo.startPTS;
    // if we know startPTS[toIdx]
    if (isFiniteNumber(fragToPTS)) {
      // update fragment duration.
      // it helps to fix drifts between playlist reported duration and fragment real duration
      var duration = 0;
      var frag;
      if (fragTo.sn > fragFrom.sn) {
        duration = fragToPTS - fragFrom.start;
        frag = fragFrom;
      } else {
        duration = fragFrom.start - fragToPTS;
        frag = fragTo;
      }
      if (frag.duration !== duration) {
        frag.duration = duration;
      }
      // we dont know startPTS[toIdx]
    } else if (fragTo.sn > fragFrom.sn) {
      var contiguous = fragFrom.cc === fragTo.cc;
      // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS
      if (contiguous && fragFrom.minEndPTS) {
        fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
      } else {
        fragTo.start = fragFrom.start + fragFrom.duration;
      }
    } else {
      fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
    }
  }
  function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
    var parsedMediaDuration = endPTS - startPTS;
    if (parsedMediaDuration <= 0) {
      logger.warn('Fragment should have a positive duration', frag);
      endPTS = startPTS + frag.duration;
      endDTS = startDTS + frag.duration;
    }
    var maxStartPTS = startPTS;
    var minEndPTS = endPTS;
    var fragStartPts = frag.startPTS;
    var fragEndPts = frag.endPTS;
    if (isFiniteNumber(fragStartPts)) {
      // delta PTS between audio and video
      var deltaPTS = Math.abs(fragStartPts - startPTS);
      if (!isFiniteNumber(frag.deltaPTS)) {
        frag.deltaPTS = deltaPTS;
      } else {
        frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
      }
      maxStartPTS = Math.max(startPTS, fragStartPts);
      startPTS = Math.min(startPTS, fragStartPts);
      startDTS = Math.min(startDTS, frag.startDTS);
      minEndPTS = Math.min(endPTS, fragEndPts);
      endPTS = Math.max(endPTS, fragEndPts);
      endDTS = Math.max(endDTS, frag.endDTS);
    }
    var drift = startPTS - frag.start;
    if (frag.start !== 0) {
      frag.start = startPTS;
    }
    frag.duration = endPTS - frag.start;
    frag.startPTS = startPTS;
    frag.maxStartPTS = maxStartPTS;
    frag.startDTS = startDTS;
    frag.endPTS = endPTS;
    frag.minEndPTS = minEndPTS;
    frag.endDTS = endDTS;
    var sn = frag.sn; // 'initSegment'
    // exit if sn out of range
    if (!details || sn < details.startSN || sn > details.endSN) {
      return 0;
    }
    var i;
    var fragIdx = sn - details.startSN;
    var fragments = details.fragments;
    // update frag reference in fragments array
    // rationale is that fragments array might not contain this frag object.
    // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
    // if we don't update frag, we won't be able to propagate PTS info on the playlist
    // resulting in invalid sliding computation
    fragments[fragIdx] = frag;
    // adjust fragment PTS/duration from seqnum-1 to frag 0
    for (i = fragIdx; i > 0; i--) {
      updateFromToPTS(fragments[i], fragments[i - 1]);
    }

    // adjust fragment PTS/duration from seqnum to last frag
    for (i = fragIdx; i < fragments.length - 1; i++) {
      updateFromToPTS(fragments[i], fragments[i + 1]);
    }
    if (details.fragmentHint) {
      updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
    }
    details.PTSKnown = details.alignedSliding = true;
    return drift;
  }
  function mergeDetails(oldDetails, newDetails) {
    // Track the last initSegment processed. Initialize it to the last one on the timeline.
    var currentInitSegment = null;
    var oldFragments = oldDetails.fragments;
    for (var i = oldFragments.length - 1; i >= 0; i--) {
      var oldInit = oldFragments[i].initSegment;
      if (oldInit) {
        currentInitSegment = oldInit;
        break;
      }
    }
    if (oldDetails.fragmentHint) {
      // prevent PTS and duration from being adjusted on the next hint
      delete oldDetails.fragmentHint.endPTS;
    }
    // check if old/new playlists have fragments in common
    // loop through overlapping SN and update startPTS, cc, and duration if any found
    var PTSFrag;
    mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag, newFragIndex, newFragments) {
      if (newDetails.skippedSegments) {
        if (newFrag.cc !== oldFrag.cc) {
          var ccOffset = oldFrag.cc - newFrag.cc;
          for (var _i = newFragIndex; _i < newFragments.length; _i++) {
            newFragments[_i].cc += ccOffset;
          }
        }
      }
      if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {
        newFrag.start = newFrag.startPTS = oldFrag.startPTS;
        newFrag.startDTS = oldFrag.startDTS;
        newFrag.maxStartPTS = oldFrag.maxStartPTS;
        newFrag.endPTS = oldFrag.endPTS;
        newFrag.endDTS = oldFrag.endDTS;
        newFrag.minEndPTS = oldFrag.minEndPTS;
        newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;
        if (newFrag.duration) {
          PTSFrag = newFrag;
        }

        // PTS is known when any segment has startPTS and endPTS
        newDetails.PTSKnown = newDetails.alignedSliding = true;
      }
      newFrag.elementaryStreams = oldFrag.elementaryStreams;
      newFrag.loader = oldFrag.loader;
      newFrag.stats = oldFrag.stats;
      if (oldFrag.initSegment) {
        newFrag.initSegment = oldFrag.initSegment;
        currentInitSegment = oldFrag.initSegment;
      }
    });
    var newFragments = newDetails.fragments;
    if (currentInitSegment) {
      var fragmentsToCheck = newDetails.fragmentHint ? newFragments.concat(newDetails.fragmentHint) : newFragments;
      fragmentsToCheck.forEach(function (frag) {
        var _currentInitSegment;
        if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {
          frag.initSegment = currentInitSegment;
        }
      });
    }
    if (newDetails.skippedSegments) {
      newDetails.deltaUpdateFailed = newFragments.some(function (frag) {
        return !frag;
      });
      if (newDetails.deltaUpdateFailed) {
        logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');
        for (var _i2 = newDetails.skippedSegments; _i2--;) {
          newFragments.shift();
        }
        newDetails.startSN = newFragments[0].sn;
      } else {
        if (newDetails.canSkipDateRanges) {
          newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);
        }
      }
      newDetails.startCC = newDetails.fragments[0].cc;
      newDetails.endCC = newFragments[newFragments.length - 1].cc;
    }

    // Merge parts
    mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {
      newPart.elementaryStreams = oldPart.elementaryStreams;
      newPart.stats = oldPart.stats;
    });

    // if at least one fragment contains PTS info, recompute PTS information for all fragments
    if (PTSFrag) {
      updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
    } else {
      // ensure that delta is within oldFragments range
      // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
      // in that case we also need to adjust start offset of all fragments
      adjustSliding(oldDetails, newDetails);
    }
    if (newFragments.length) {
      newDetails.totalduration = newDetails.edge - newFragments[0].start;
    }
    newDetails.driftStartTime = oldDetails.driftStartTime;
    newDetails.driftStart = oldDetails.driftStart;
    var advancedDateTime = newDetails.advancedDateTime;
    if (newDetails.advanced && advancedDateTime) {
      var edge = newDetails.edge;
      if (!newDetails.driftStart) {
        newDetails.driftStartTime = advancedDateTime;
        newDetails.driftStart = edge;
      }
      newDetails.driftEndTime = advancedDateTime;
      newDetails.driftEnd = edge;
    } else {
      newDetails.driftEndTime = oldDetails.driftEndTime;
      newDetails.driftEnd = oldDetails.driftEnd;
      newDetails.advancedDateTime = oldDetails.advancedDateTime;
    }
  }
  function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {
    var dateRanges = _extends({}, oldDateRanges);
    if (recentlyRemovedDateranges) {
      recentlyRemovedDateranges.forEach(function (id) {
        delete dateRanges[id];
      });
    }
    Object.keys(deltaDateRanges).forEach(function (id) {
      var dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);
      if (dateRange.isValid) {
        dateRanges[id] = dateRange;
      } else {
        logger.warn("Ignoring invalid Playlist Delta Update DATERANGE tag: \"" + JSON.stringify(deltaDateRanges[id].attr) + "\"");
      }
    });
    return dateRanges;
  }
  function mapPartIntersection(oldParts, newParts, intersectionFn) {
    if (oldParts && newParts) {
      var delta = 0;
      for (var i = 0, len = oldParts.length; i <= len; i++) {
        var _oldPart = oldParts[i];
        var _newPart = newParts[i + delta];
        if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {
          intersectionFn(_oldPart, _newPart);
        } else {
          delta--;
        }
      }
    }
  }
  function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
    var skippedSegments = newDetails.skippedSegments;
    var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
    var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
    var delta = newDetails.startSN - oldDetails.startSN;
    var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
    var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
    for (var i = start; i <= end; i++) {
      var _oldFrag = oldFrags[delta + i];
      var _newFrag = newFrags[i];
      if (skippedSegments && !_newFrag && i < skippedSegments) {
        // Fill in skipped segments in delta playlist
        _newFrag = newDetails.fragments[i] = _oldFrag;
      }
      if (_oldFrag && _newFrag) {
        intersectionFn(_oldFrag, _newFrag, i, newFrags);
      }
    }
  }
  function adjustSliding(oldDetails, newDetails) {
    var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
    var oldFragments = oldDetails.fragments;
    if (delta < 0 || delta >= oldFragments.length) {
      return;
    }
    addSliding(newDetails, oldFragments[delta].start);
  }
  function addSliding(details, start) {
    if (start) {
      var fragments = details.fragments;
      for (var i = details.skippedSegments; i < fragments.length; i++) {
        fragments[i].start += start;
      }
      if (details.fragmentHint) {
        details.fragmentHint.start += start;
      }
    }
  }
  function computeReloadInterval(newDetails, distanceToLiveEdgeMs) {
    if (distanceToLiveEdgeMs === void 0) {
      distanceToLiveEdgeMs = Infinity;
    }
    var reloadInterval = 1000 * newDetails.targetduration;
    if (newDetails.updated) {
      // Use last segment duration when shorter than target duration and near live edge
      var fragments = newDetails.fragments;
      var liveEdgeMaxTargetDurations = 4;
      if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
        var lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;
        if (lastSegmentDuration < reloadInterval) {
          reloadInterval = lastSegmentDuration;
        }
      }
    } else {
      // estimate = 'miss half average';
      // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
      // changed then it MUST wait for a period of one-half the target
      // duration before retrying.
      reloadInterval /= 2;
    }
    return Math.round(reloadInterval);
  }
  function getFragmentWithSN(level, sn, fragCurrent) {
    if (!(level != null && level.details)) {
      return null;
    }
    var levelDetails = level.details;
    var fragment = levelDetails.fragments[sn - levelDetails.startSN];
    if (fragment) {
      return fragment;
    }
    fragment = levelDetails.fragmentHint;
    if (fragment && fragment.sn === sn) {
      return fragment;
    }
    if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {
      return fragCurrent;
    }
    return null;
  }
  function getPartWith(level, sn, partIndex) {
    var _level$details;
    if (!(level != null && level.details)) {
      return null;
    }
    return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);
  }
  function findPart(partList, sn, partIndex) {
    if (partList) {
      for (var i = partList.length; i--;) {
        var part = partList[i];
        if (part.index === partIndex && part.fragment.sn === sn) {
          return part;
        }
      }
    }
    return null;
  }
  function reassignFragmentLevelIndexes(levels) {
    levels.forEach(function (level, index) {
      var details = level.details;
      if (details != null && details.fragments) {
        details.fragments.forEach(function (fragment) {
          fragment.level = index;
        });
      }
    });
  }

  function isTimeoutError(error) {
    switch (error.details) {
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
      case ErrorDetails.LEVEL_LOAD_TIMEOUT:
      case ErrorDetails.MANIFEST_LOAD_TIMEOUT:
        return true;
    }
    return false;
  }
  function getRetryConfig(loadPolicy, error) {
    var isTimeout = isTimeoutError(error);
    return loadPolicy.default[(isTimeout ? 'timeout' : 'error') + "Retry"];
  }
  function getRetryDelay(retryConfig, retryCount) {
    // exponential backoff capped to max retry delay
    var backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);
    return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);
  }
  function getLoaderConfigWithoutReties(loderConfig) {
    return _objectSpread2(_objectSpread2({}, loderConfig), {
      errorRetry: null,
      timeoutRetry: null
    });
  }
  function shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {
    if (!retryConfig) {
      return false;
    }
    var httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;
    var retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);
    return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;
  }
  function retryForHttpStatus(httpStatus) {
    // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)
    return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);
  }

  var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param list The array to search.
     * @param comparisonFn
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @returns the object if found, otherwise returns null
     */
    search: function search(list, comparisonFn) {
      var minIndex = 0;
      var maxIndex = list.length - 1;
      var currentIndex = null;
      var currentElement = null;
      while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0;
        currentElement = list[currentIndex];
        var comparisonResult = comparisonFn(currentElement);
        if (comparisonResult > 0) {
          minIndex = currentIndex + 1;
        } else if (comparisonResult < 0) {
          maxIndex = currentIndex - 1;
        } else {
          return currentElement;
        }
      }
      return null;
    }
  };

  /**
   * Returns first fragment whose endPdt value exceeds the given PDT, or null.
   * @param fragments - The array of candidate fragments
   * @param PDTValue - The PDT value which must be exceeded
   * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
   */
  function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
    if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {
      return null;
    }

    // if less than start
    var startPDT = fragments[0].programDateTime;
    if (PDTValue < (startPDT || 0)) {
      return null;
    }
    var endPDT = fragments[fragments.length - 1].endProgramDateTime;
    if (PDTValue >= (endPDT || 0)) {
      return null;
    }
    maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
    for (var seg = 0; seg < fragments.length; ++seg) {
      var frag = fragments[seg];
      if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
        return frag;
      }
    }
    return null;
  }

  /**
   * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
   * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
   * breaking any traps which would cause the same fragment to be continuously selected within a small range.
   * @param fragPrevious - The last frag successfully appended
   * @param fragments - The array of candidate fragments
   * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within
   * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
   * @returns a matching fragment or null
   */
  function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance, nextFragLookupTolerance) {
    if (bufferEnd === void 0) {
      bufferEnd = 0;
    }
    if (maxFragLookUpTolerance === void 0) {
      maxFragLookUpTolerance = 0;
    }
    if (nextFragLookupTolerance === void 0) {
      nextFragLookupTolerance = 0.005;
    }
    var fragNext = null;
    if (fragPrevious) {
      fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;
      // check for buffer-end rounding error
      var bufferEdgeError = fragPrevious.endDTS - bufferEnd;
      if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {
        bufferEnd += 0.0000015;
      }
    } else if (bufferEnd === 0 && fragments[0].start === 0) {
      fragNext = fragments[0];
    }
    // Prefer the next fragment if it's within tolerance
    if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {
      return fragNext;
    }
    // We might be seeking past the tolerance so find the best match
    var foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
    if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
      return foundFragment;
    }
    // If no match was found return the next fragment after fragPrevious, or null
    return fragNext;
  }
  function fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {
    if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {
      var firstDuration = fragPrevious.tagList.reduce(function (duration, tag) {
        if (tag[0] === 'INF') {
          duration += parseFloat(tag[1]);
        }
        return duration;
      }, nextFragLookupTolerance);
      return fragNext.start <= firstDuration;
    }
    return false;
  }

  /**
   * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
   * @param candidate - The fragment to test
   * @param bufferEnd - The end of the current buffered range the playhead is currently within
   * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous
   * @returns 0 if it matches, 1 if too low, -1 if too high
   */
  function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
    if (bufferEnd === void 0) {
      bufferEnd = 0;
    }
    if (maxFragLookUpTolerance === void 0) {
      maxFragLookUpTolerance = 0;
    }
    // eagerly accept an accurate match (no tolerance)
    if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
      return 0;
    }
    // offset should be within fragment boundary - config.maxFragLookUpTolerance
    // this is to cope with situations like
    // bufferEnd = 9.991
    // frag[] : [0,10]
    // frag[1] : [10,20]
    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
    //              frag start               frag start+duration
    //                  |-----------------------------|
    //              <--->                         <--->
    //  ...--------><-----------------------------><---------....
    // previous frag         matching fragment         next frag
    //  return -1             return 0                 return 1
    // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
      return 1;
    } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
      // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
      return -1;
    }
    return 0;
  }

  /**
   * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
   * This function tests the candidate's program date time values, as represented in Unix time
   * @param candidate - The fragment to test
   * @param pdtBufferEnd - The Unix time representing the end of the current buffered range
   * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous
   * @returns true if contiguous, false otherwise
   */
  function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;

    // endProgramDateTime can be null, default to zero
    var endProgramDateTime = candidate.endProgramDateTime || 0;
    return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
  }
  function findFragWithCC(fragments, cc) {
    return BinarySearch.search(fragments, function (candidate) {
      if (candidate.cc < cc) {
        return 1;
      } else if (candidate.cc > cc) {
        return -1;
      } else {
        return 0;
      }
    });
  }

  var NetworkErrorAction = {
    DoNothing: 0,
    SendEndCallback: 1,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    InsertDiscontinuity: 4,
    RetryRequest: 5
  };
  var ErrorActionFlags = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
    SwitchToSDR: 4
  }; // Reserved for future use
  var ErrorController = /*#__PURE__*/function () {
    function ErrorController(hls) {
      this.hls = void 0;
      this.playlistError = 0;
      this.penalizedRenditions = {};
      this.log = void 0;
      this.warn = void 0;
      this.error = void 0;
      this.hls = hls;
      this.log = logger.log.bind(logger, "[info]:");
      this.warn = logger.warn.bind(logger, "[warning]:");
      this.error = logger.error.bind(logger, "[error]:");
      this.registerListeners();
    }
    var _proto = ErrorController.prototype;
    _proto.registerListeners = function registerListeners() {
      var hls = this.hls;
      hls.on(Events.ERROR, this.onError, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    };
    _proto.unregisterListeners = function unregisterListeners() {
      var hls = this.hls;
      if (!hls) {
        return;
      }
      hls.off(Events.ERROR, this.onError, this);
      hls.off(Events.ERROR, this.onErrorOut, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    };
    _proto.destroy = function destroy() {
      this.unregisterListeners();
      // @ts-ignore
      this.hls = null;
      this.penalizedRenditions = {};
    };
    _proto.startLoad = function startLoad(startPosition) {};
    _proto.stopLoad = function stopLoad() {
      this.playlistError = 0;
    };
    _proto.getVariantLevelIndex = function getVariantLevelIndex(frag) {
      return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;
    };
    _proto.onManifestLoading = function onManifestLoading() {
      this.playlistError = 0;
      this.penalizedRenditions = {};
    };
    _proto.onLevelUpdated = function onLevelUpdated() {
      this.playlistError = 0;
    };
    _proto.onError = function onError(event, data) {
      var _data$frag, _data$level;
      if (data.fatal) {
        return;
      }
      var hls = this.hls;
      var context = data.context;
      switch (data.details) {
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          data.errorAction = this.getFragRetryOrSwitchAction(data);
          return;
        case ErrorDetails.FRAG_PARSING_ERROR:
          // ignore empty segment errors marked as gap
          if ((_data$frag = data.frag) != null && _data$frag.gap) {
            data.errorAction = {
              action: NetworkErrorAction.DoNothing,
              flags: ErrorActionFlags.None
            };
            return;
          }
        // falls through
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_DECRYPT_ERROR:
          {
            // Switch level if possible, otherwise allow retry count to reach max error retries
            data.errorAction = this.getFragRetryOrSwitchAction(data);
            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
            return;
          }
        case ErrorDetails.LEVEL_EMPTY_ERROR:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          {
            var _data$context, _data$context$levelDe;
            // Only retry when empty and live
            var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
            if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {
              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);
            } else {
              // Escalate to fatal if not retrying or switching
              data.levelRetry = false;
              data.errorAction = this.getLevelSwitchAction(data, levelIndex);
            }
          }
          return;
        case ErrorDetails.LEVEL_LOAD_ERROR:
        case ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (typeof (context == null ? void 0 : context.level) === 'number') {
            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);
          }
          return;
        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case ErrorDetails.SUBTITLE_LOAD_ERROR:
        case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:
          if (context) {
            var level = hls.levels[hls.loadLevel];
            if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {
              // Perform Pathway switch or Redundant failover if possible for fastest recovery
              // otherwise allow playlist retry count to reach max error retries
              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);
              data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
              data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;
              return;
            }
          }
          return;
        case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
          {
            var _level = hls.levels[hls.loadLevel];
            var restrictedHdcpLevel = _level == null ? void 0 : _level.attrs['HDCP-LEVEL'];
            if (restrictedHdcpLevel) {
              data.errorAction = {
                action: NetworkErrorAction.SendAlternateToPenaltyBox,
                flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,
                hdcpLevel: restrictedHdcpLevel
              };
            } else {
              this.keySystemError(data);
            }
          }
          return;
        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
        case ErrorDetails.REMUX_ALLOC_ERROR:
        case ErrorDetails.BUFFER_APPEND_ERROR:
          data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);
          return;
        case ErrorDetails.INTERNAL_EXCEPTION:
        case ErrorDetails.BUFFER_APPENDING_ERROR:
        case ErrorDetails.BUFFER_FULL_ERROR:
        case ErrorDetails.LEVEL_SWITCH_ERROR:
        case ErrorDetails.BUFFER_STALLED_ERROR:
        case ErrorDetails.BUFFER_SEEK_OVER_HOLE:
        case ErrorDetails.BUFFER_NUDGE_ON_STALL:
          data.errorAction = {
            action: NetworkErrorAction.DoNothing,
            flags: ErrorActionFlags.None
          };
          return;
      }
      if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {
        this.keySystemError(data);
      }
    };
    _proto.keySystemError = function keySystemError(data) {
      var levelIndex = this.getVariantLevelIndex(data.frag);
      // Do not retry level. Escalate to fatal if switching levels fails.
      data.levelRetry = false;
      data.errorAction = this.getLevelSwitchAction(data, levelIndex);
    };
    _proto.getPlaylistRetryOrSwitchAction = function getPlaylistRetryOrSwitchAction(data, levelIndex) {
      var hls = this.hls;
      var retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);
      var retryCount = this.playlistError++;
      var retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);
      if (retry) {
        return {
          action: NetworkErrorAction.RetryRequest,
          flags: ErrorActionFlags.None,
          retryConfig: retryConfig,
          retryCount: retryCount
        };
      }
      var errorAction = this.getLevelSwitchAction(data, levelIndex);
      if (retryConfig) {
        errorAction.retryConfig = retryConfig;
        errorAction.retryCount = retryCount;
      }
      return errorAction;
    };
    _proto.getFragRetryOrSwitchAction = function getFragRetryOrSwitchAction(data) {
      var hls = this.hls;
      // Share fragment error count accross media options (main, audio, subs)
      // This allows for level based rendition switching when media option assets fail
      var variantLevelIndex = this.getVariantLevelIndex(data.frag);
      var level = hls.levels[variantLevelIndex];
      var _hls$config = hls.config,
        fragLoadPolicy = _hls$config.fragLoadPolicy,
        keyLoadPolicy = _hls$config.keyLoadPolicy;
      var retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);
      var fragmentErrors = hls.levels.reduce(function (acc, level) {
        return acc + level.fragmentError;
      }, 0);
      // Switch levels when out of retried or level index out of bounds
      if (level) {
        if (data.details !== ErrorDetails.FRAG_GAP) {
          level.fragmentError++;
        }
        var retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);
        if (retry) {
          return {
            action: NetworkErrorAction.RetryRequest,
            flags: ErrorActionFlags.None,
            retryConfig: retryConfig,
            retryCount: fragmentErrors
          };
        }
      }
      // Reach max retry count, or Missing level reference
      // Switch to valid index
      var errorAction = this.getLevelSwitchAction(data, variantLevelIndex);
      // Add retry details to allow skipping of FRAG_PARSING_ERROR
      if (retryConfig) {
        errorAction.retryConfig = retryConfig;
        errorAction.retryCount = fragmentErrors;
      }
      return errorAction;
    };
    _proto.getLevelSwitchAction = function getLevelSwitchAction(data, levelIndex) {
      var hls = this.hls;
      if (levelIndex === null || levelIndex === undefined) {
        levelIndex = hls.loadLevel;
      }
      var level = this.hls.levels[levelIndex];
      if (level) {
        var _data$frag2, _data$context2;
        var errorDetails = data.details;
        level.loadError++;
        if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {
          level.fragmentError++;
        }
        // Search for next level to retry
        var nextLevel = -1;
        var levels = hls.levels,
          loadLevel = hls.loadLevel,
          minAutoLevel = hls.minAutoLevel,
          maxAutoLevel = hls.maxAutoLevel;
        if (!hls.autoLevelEnabled) {
          hls.loadLevel = -1;
        }
        var fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;
        // Find alternate audio codec if available on audio codec error
        var isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === 'audio' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
        var findAudioCodecAlternate = isAudioCodecError && levels.some(function (_ref) {
          var audioCodec = _ref.audioCodec;
          return level.audioCodec !== audioCodec;
        });
        // Find alternate video codec if available on video codec error
        var isVideoCodecError = data.sourceBufferName === 'video' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
        var findVideoCodecAlternate = isVideoCodecError && levels.some(function (_ref2) {
          var codecSet = _ref2.codecSet,
            audioCodec = _ref2.audioCodec;
          return level.codecSet !== codecSet && level.audioCodec === audioCodec;
        });
        var _ref3 = (_data$context2 = data.context) != null ? _data$context2 : {},
          playlistErrorType = _ref3.type,
          playlistErrorGroupId = _ref3.groupId;
        var _loop = function _loop() {
            var candidate = (i + loadLevel) % levels.length;
            if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {
              var _level$audioGroups, _level$subtitleGroups;
              var levelCandidate = levels[candidate];
              // Skip level switch if GAP tag is found in next level at same position
              if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {
                var levelDetails = levels[candidate].details;
                if (levelDetails) {
                  var fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);
                  if (fragCandidate != null && fragCandidate.gap) {
                    return 0; // continue
                  }
                }
              } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {
                // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over
                return 0; // continue
              } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(function (groupId) {
                return levelCandidate.hasAudioGroup(groupId);
              }) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(function (groupId) {
                return levelCandidate.hasSubtitleGroup(groupId);
              }) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {
                // For video/audio/subs frag errors find another group ID or fallthrough to redundant fail-over
                return 0; // continue
              }
              nextLevel = candidate;
              return 1; // break
            }
          },
          _ret;
        for (var i = levels.length; i--;) {
          _ret = _loop();
          if (_ret === 0) continue;
          if (_ret === 1) break;
        }
        if (nextLevel > -1 && hls.loadLevel !== nextLevel) {
          data.levelRetry = true;
          this.playlistError = 0;
          return {
            action: NetworkErrorAction.SendAlternateToPenaltyBox,
            flags: ErrorActionFlags.None,
            nextAutoLevel: nextLevel
          };
        }
      }
      // No levels to switch / Manual level selection / Level not found
      // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level
      return {
        action: NetworkErrorAction.SendAlternateToPenaltyBox,
        flags: ErrorActionFlags.MoveAllAlternatesMatchingHost
      };
    };
    _proto.onErrorOut = function onErrorOut(event, data) {
      var _data$errorAction;
      switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {
        case NetworkErrorAction.DoNothing:
          break;
        case NetworkErrorAction.SendAlternateToPenaltyBox:
          this.sendAlternateToPenaltyBox(data);
          if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {
            data.fatal = true;
          } else if (/MediaSource readyState: ended/.test(data.error.message)) {
            this.warn("MediaSource ended after \"" + data.sourceBufferName + "\" sourceBuffer append error. Attempting to recover from media error.");
            this.hls.recoverMediaError();
          }
          break;
      }
      if (data.fatal) {
        this.hls.stopLoad();
        return;
      }
    };
    _proto.sendAlternateToPenaltyBox = function sendAlternateToPenaltyBox(data) {
      var hls = this.hls;
      var errorAction = data.errorAction;
      if (!errorAction) {
        return;
      }
      var flags = errorAction.flags,
        hdcpLevel = errorAction.hdcpLevel,
        nextAutoLevel = errorAction.nextAutoLevel;
      switch (flags) {
        case ErrorActionFlags.None:
          this.switchLevel(data, nextAutoLevel);
          break;
        case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:
          if (hdcpLevel) {
            hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];
            errorAction.resolved = true;
          }
          this.warn("Restricting playback to HDCP-LEVEL of \"" + hls.maxHdcpLevel + "\" or lower");
          break;
      }
      // If not resolved by previous actions try to switch to next level
      if (!errorAction.resolved) {
        this.switchLevel(data, nextAutoLevel);
      }
    };
    _proto.switchLevel = function switchLevel(data, levelIndex) {
      if (levelIndex !== undefined && data.errorAction) {
        this.warn("switching to level " + levelIndex + " after " + data.details);
        this.hls.nextAutoLevel = levelIndex;
        data.errorAction.resolved = true;
        // Stream controller is responsible for this but won't switch on false start
        this.hls.nextLoadLevel = this.hls.nextAutoLevel;
      }
    };
    return ErrorController;
  }();

  var BasePlaylistController = /*#__PURE__*/function () {
    function BasePlaylistController(hls, logPrefix) {
      this.hls = void 0;
      this.timer = -1;
      this.requestScheduled = -1;
      this.canLoad = false;
      this.log = void 0;
      this.warn = void 0;
      this.log = logger.log.bind(logger, logPrefix + ":");
      this.warn = logger.warn.bind(logger, logPrefix + ":");
      this.hls = hls;
    }
    var _proto = BasePlaylistController.prototype;
    _proto.destroy = function destroy() {
      this.clearTimer();
      // @ts-ignore
      this.hls = this.log = this.warn = null;
    };
    _proto.clearTimer = function clearTimer() {
      if (this.timer !== -1) {
        self.clearTimeout(this.timer);
        this.timer = -1;
      }
    };
    _proto.startLoad = function startLoad() {
      this.canLoad = true;
      this.requestScheduled = -1;
      this.loadPlaylist();
    };
    _proto.stopLoad = function stopLoad() {
      this.canLoad = false;
      this.clearTimer();
    };
    _proto.switchParams = function switchParams(playlistUri, previous, current) {
      var renditionReports = previous == null ? void 0 : previous.renditionReports;
      if (renditionReports) {
        var foundIndex = -1;
        for (var i = 0; i < renditionReports.length; i++) {
          var attr = renditionReports[i];
          var uri = void 0;
          try {
            uri = new self.URL(attr.URI, previous.url).href;
          } catch (error) {
            logger.warn("Could not construct new URL for Rendition Report: " + error);
            uri = attr.URI || '';
          }
          // Use exact match. Otherwise, the last partial match, if any, will be used
          // (Playlist URI includes a query string that the Rendition Report does not)
          if (uri === playlistUri) {
            foundIndex = i;
            break;
          } else if (uri === playlistUri.substring(0, uri.length)) {
            foundIndex = i;
          }
        }
        if (foundIndex !== -1) {
          var _attr = renditionReports[foundIndex];
          var msn = parseInt(_attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);
          var part = parseInt(_attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);
          if (this.hls.config.lowLatencyMode) {
            var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
            if (part >= 0 && currentGoal > previous.partTarget) {
              part += 1;
            }
          }
          var skip = current && getSkipValue(current);
          return new HlsUrlParameters(msn, part >= 0 ? part : undefined, skip);
        }
      }
    };
    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
      if (this.requestScheduled === -1) {
        this.requestScheduled = self.performance.now();
      }
      // Loading is handled by the subclasses
    };
    _proto.shouldLoadPlaylist = function shouldLoadPlaylist(playlist) {
      return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);
    };
    _proto.shouldReloadPlaylist = function shouldReloadPlaylist(playlist) {
      return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);
    };
    _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {
      var _this = this;
      var details = data.details,
        stats = data.stats;

      // Set last updated date-time
      var now = self.performance.now();
      var elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;
      details.advancedDateTime = Date.now() - elapsed;

      // if current playlist is a live playlist, arm a timer to reload it
      if (details.live || previousDetails != null && previousDetails.live) {
        details.reloaded(previousDetails);
        if (previousDetails) {
          this.log("live playlist " + index + " " + (details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : details.updated ? 'UPDATED' : 'MISSED'));
        }
        // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments
        if (previousDetails && details.fragments.length > 0) {
          mergeDetails(previousDetails, details);
        }
        if (!this.canLoad || !details.live) {
          return;
        }
        var deliveryDirectives;
        var msn = undefined;
        var part = undefined;
        if (details.canBlockReload && details.endSN && details.advanced) {
          // Load level with LL-HLS delivery directives
          var lowLatencyMode = this.hls.config.lowLatencyMode;
          var lastPartSn = details.lastPartSn;
          var endSn = details.endSN;
          var lastPartIndex = details.lastPartIndex;
          var hasParts = lastPartIndex !== -1;
          var lastPart = lastPartSn === endSn;
          // When low latency mode is disabled, we'll skip part requests once the last part index is found
          var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;
          if (hasParts) {
            msn = lastPart ? endSn + 1 : lastPartSn;
            part = lastPart ? nextSnStartIndex : lastPartIndex + 1;
          } else {
            msn = endSn + 1;
          }
          // Low-Latency CDN Tune-in: "age" header and time since load indicates we're behind by more than one part
          // Update directives to obtain the Playlist that has the estimated additional duration of media
          var lastAdvanced = details.age;
          var cdnAge = lastAdvanced + details.ageHeader;
          var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
          if (currentGoal > 0) {
            if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
              // If we attempted to get the next or latest playlist update, but currentGoal increased,
              // then we either can't catchup, or the "age" header cannot be trusted.
              this.warn("CDN Tune-in goal increased from: " + previousDetails.tuneInGoal + " to: " + currentGoal + " with playlist age: " + details.age);
              currentGoal = 0;
            } else {
              var segments = Math.floor(currentGoal / details.targetduration);
              msn += segments;
              if (part !== undefined) {
                var parts = Math.round(currentGoal % details.targetduration / details.partTarget);
                part += parts;
              }
              this.log("CDN Tune-in age: " + details.ageHeader + "s last advanced " + lastAdvanced.toFixed(2) + "s goal: " + currentGoal + " skip sn " + segments + " to part " + part);
            }
            details.tuneInGoal = currentGoal;
          }
          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
          if (lowLatencyMode || !lastPart) {
            this.loadPlaylist(deliveryDirectives);
            return;
          }
        } else if (details.canBlockReload || details.canSkipUntil) {
          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
        }
        var bufferInfo = this.hls.mainForwardBufferInfo;
        var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
        var distanceToLiveEdgeMs = (details.edge - position) * 1000;
        var reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);
        if (details.updated && now > this.requestScheduled + reloadInterval) {
          this.requestScheduled = stats.loading.start;
        }
        if (msn !== undefined && details.canBlockReload) {
          this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);
        } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {
          this.requestScheduled = now;
        } else if (this.requestScheduled - now <= 0) {
          this.requestScheduled += reloadInterval;
        }
        var estimatedTimeUntilUpdate = this.requestScheduled - now;
        estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);
        this.log("reload live playlist " + index + " in " + Math.round(estimatedTimeUntilUpdate) + " ms");
        // this.log(
        //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}
        // reload in ${estimatedTimeUntilUpdate / 1000}
        // round trip ${(stats.loading.end - stats.loading.start) / 1000}
        // diff ${
        //   (reloadInterval -
        //     (estimatedTimeUntilUpdate +
        //       stats.loading.end -
        //       stats.loading.start)) /
        //   1000
        // }
        // reload interval ${reloadInterval / 1000}
        // target duration ${details.targetduration}
        // distance to edge ${distanceToLiveEdgeMs / 1000}`
        // );

        this.timer = self.setTimeout(function () {
          return _this.loadPlaylist(deliveryDirectives);
        }, estimatedTimeUntilUpdate);
      } else {
        this.clearTimer();
      }
    };
    _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
      var skip = getSkipValue(details);
      if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
        msn = previousDeliveryDirectives.msn;
        part = previousDeliveryDirectives.part;
        skip = HlsSkip.No;
      }
      return new HlsUrlParameters(msn, part, skip);
    };
    _proto.checkRetry = function checkRetry(errorEvent) {
      var _this2 = this;
      var errorDetails = errorEvent.details;
      var isTimeout = isTimeoutError(errorEvent);
      var errorAction = errorEvent.errorAction;
      var _ref = errorAction || {},
        action = _ref.action,
        _ref$retryCount = _ref.retryCount,
        retryCount = _ref$retryCount === void 0 ? 0 : _ref$retryCount,
        retryConfig = _ref.retryConfig;
      var retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);
      if (retry) {
        var _errorEvent$context;
        this.requestScheduled = -1;
        if (retryCount >= retryConfig.maxNumRetry) {
          return false;
        }
        if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {
          // The LL-HLS request already timed out so retry immediately
          this.warn("Retrying playlist loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + " after \"" + errorDetails + "\" without delivery-directives");
          this.loadPlaylist();
        } else {
          var delay = getRetryDelay(retryConfig, retryCount);
          // Schedule level/track reload
          this.timer = self.setTimeout(function () {
            return _this2.loadPlaylist();
          }, delay);
          this.warn("Retrying playlist loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + " after \"" + errorDetails + "\" in " + delay + "ms");
        }
        // `levelRetry = true` used to inform other controllers that a retry is happening
        errorEvent.levelRetry = true;
        errorAction.resolved = true;
      }
      return retry;
    };
    return BasePlaylistController;
  }();

  /*
   * compute an Exponential Weighted moving average
   * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
   *  - heavily inspired from shaka-player
   */
  var EWMA = /*#__PURE__*/function () {
    //  About half of the estimated value will be from the last |halfLife| samples by weight.
    function EWMA(halfLife, estimate, weight) {
      if (estimate === void 0) {
        estimate = 0;
      }
      if (weight === void 0) {
        weight = 0;
      }
      this.halfLife = void 0;
      this.alpha_ = void 0;
      this.estimate_ = void 0;
      this.totalWeight_ = void 0;
      this.halfLife = halfLife;
      // Larger values of alpha expire historical data more slowly.
      this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
      this.estimate_ = estimate;
      this.totalWeight_ = weight;
    }
    var _proto = EWMA.prototype;
    _proto.sample = function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    };
    _proto.getTotalWeight = function getTotalWeight() {
      return this.totalWeight_;
    };
    _proto.getEstimate = function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        if (zeroFactor) {
          return this.estimate_ / zeroFactor;
        }
      }
      return this.estimate_;
    };
    return EWMA;
  }();

  /*
   * EWMA Bandwidth Estimator
   *  - heavily inspired from shaka-player
   * Tracks bandwidth samples and estimates available bandwidth.
   * Based on the minimum of two exponentially-weighted moving averages with
   * different half-lives.
   */

  var EwmaBandWidthEstimator = /*#__PURE__*/function () {
    function EwmaBandWidthEstimator(slow, fast, defaultEstimate, defaultTTFB) {
      if (defaultTTFB === void 0) {
        defaultTTFB = 100;
      }
      this.defaultEstimate_ = void 0;
      this.minWeight_ = void 0;
      this.minDelayMs_ = void 0;
      this.slow_ = void 0;
      this.fast_ = void 0;
      this.defaultTTFB_ = void 0;
      this.ttfb_ = void 0;
      this.defaultEstimate_ = defaultEstimate;
      this.minWeight_ = 0.001;
      this.minDelayMs_ = 50;
      this.slow_ = new EWMA(slow);
      this.fast_ = new EWMA(fast);
      this.defaultTTFB_ = defaultTTFB;
      this.ttfb_ = new EWMA(slow);
    }
    var _proto = EwmaBandWidthEstimator.prototype;
    _proto.update = function update(slow, fast) {
      var slow_ = this.slow_,
        fast_ = this.fast_,
        ttfb_ = this.ttfb_;
      if (slow_.halfLife !== slow) {
        this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
      }
      if (fast_.halfLife !== fast) {
        this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
      }
      if (ttfb_.halfLife !== slow) {
        this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
      }
    };
    _proto.sample = function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var numBits = 8 * numBytes;
      // weight is duration in seconds
      var durationS = durationMs / 1000;
      // value is bandwidth in bits/s
      var bandwidthInBps = numBits / durationS;
      this.fast_.sample(durationS, bandwidthInBps);
      this.slow_.sample(durationS, bandwidthInBps);
    };
    _proto.sampleTTFB = function sampleTTFB(ttfb) {
      // weight is frequency curve applied to TTFB in seconds
      // (longer times have less weight with expected input under 1 second)
      var seconds = ttfb / 1000;
      var weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
      this.ttfb_.sample(weight, Math.max(ttfb, 5));
    };
    _proto.canEstimate = function canEstimate() {
      return this.fast_.getTotalWeight() >= this.minWeight_;
    };
    _proto.getEstimate = function getEstimate() {
      if (this.canEstimate()) {
        // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    };
    _proto.getEstimateTTFB = function getEstimateTTFB() {
      if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
        return this.ttfb_.getEstimate();
      } else {
        return this.defaultTTFB_;
      }
    };
    _proto.destroy = function destroy() {};
    return EwmaBandWidthEstimator;
  }();

  var SUPPORTED_INFO_DEFAULT = {
    supported: true,
    configurations: [],
    decodingInfoResults: [{
      supported: true,
      powerEfficient: true,
      smooth: true
    }]
  };
  var SUPPORTED_INFO_CACHE = {};
  function requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {
    // Only test support when configuration is exceeds minimum options
    var audioGroups = level.audioCodec ? level.audioGroups : null;
    var audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;
    var channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;
    var maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;
    var audioChannels = null;
    if (audioGroups != null && audioGroups.length) {
      try {
        if (audioGroups.length === 1 && audioGroups[0]) {
          audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;
        } else {
          audioChannels = audioGroups.reduce(function (acc, groupId) {
            if (groupId) {
              var audioTrackGroup = audioTracksByGroup.groups[groupId];
              if (!audioTrackGroup) {
                throw new Error("Audio track group " + groupId + " not found");
              }
              // Sum all channel key values
              Object.keys(audioTrackGroup.channels).forEach(function (key) {
                acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];
              });
            }
            return acc;
          }, {
            2: 0
          });
        }
      } catch (error) {
        return true;
      }
    }
    return level.videoCodec !== undefined && (level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== 'SDR' && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some(function (channels) {
      return parseInt(channels) > maxChannels;
    });
  }
  function getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {
    var videoCodecs = level.videoCodec;
    var audioCodecs = level.audioCodec;
    if (!videoCodecs || !audioCodecs || !mediaCapabilities) {
      return Promise.resolve(SUPPORTED_INFO_DEFAULT);
    }
    var baseVideoConfiguration = {
      width: level.width,
      height: level.height,
      bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),
      // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.
      framerate: level.frameRate || 30
    };
    var videoRange = level.videoRange;
    if (videoRange !== 'SDR') {
      baseVideoConfiguration.transferFunction = videoRange.toLowerCase();
    }
    var configurations = videoCodecs.split(',').map(function (videoCodec) {
      return {
        type: 'media-source',
        video: _objectSpread2(_objectSpread2({}, baseVideoConfiguration), {}, {
          contentType: mimeTypeForCodec(videoCodec, 'video')
        })
      };
    });
    if (audioCodecs && level.audioGroups) {
      level.audioGroups.forEach(function (audioGroupId) {
        var _audioTracksByGroup$g;
        if (!audioGroupId) {
          return;
        }
        (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks.forEach(function (audioTrack) {
          if (audioTrack.groupId === audioGroupId) {
            var channels = audioTrack.channels || '';
            var channelsNumber = parseFloat(channels);
            if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {
              configurations.push.apply(configurations, audioCodecs.split(',').map(function (audioCodec) {
                return {
                  type: 'media-source',
                  audio: {
                    contentType: mimeTypeForCodec(audioCodec, 'audio'),
                    channels: '' + channelsNumber
                    // spatialRendering:
                    //   audioCodec === 'ec-3' && channels.indexOf('JOC'),
                  }
                };
              }));
            }
          }
        });
      });
    }
    return Promise.all(configurations.map(function (configuration) {
      // Cache MediaCapabilities promises
      var decodingInfoKey = getMediaDecodingInfoKey(configuration);
      return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));
    })).then(function (decodingInfoResults) {
      return {
        supported: !decodingInfoResults.some(function (info) {
          return !info.supported;
        }),
        configurations: configurations,
        decodingInfoResults: decodingInfoResults
      };
    }).catch(function (error) {
      return {
        supported: false,
        configurations: configurations,
        decodingInfoResults: [],
        error: error
      };
    });
  }
  function getMediaDecodingInfoKey(config) {
    var audio = config.audio,
      video = config.video;
    var mediaConfig = video || audio;
    if (mediaConfig) {
      var codec = mediaConfig.contentType.split('"')[1];
      if (video) {
        return "r" + video.height + "x" + video.width + "f" + Math.ceil(video.framerate) + (video.transferFunction || 'sd') + "_" + codec + "_" + Math.ceil(video.bitrate / 1e5);
      }
      if (audio) {
        return "c" + audio.channels + (audio.spatialRendering ? 's' : 'n') + "_" + codec;
      }
    }
    return '';
  }

  /**
   * @returns Whether we can detect and validate HDR capability within the window context
   */
  function isHdrSupported() {
    if (typeof matchMedia === 'function') {
      var mediaQueryList = matchMedia('(dynamic-range: high)');
      var badQuery = matchMedia('bad query');
      if (mediaQueryList.media !== badQuery.media) {
        return mediaQueryList.matches === true;
      }
    }
    return false;
  }

  /**
   * Sanitizes inputs to return the active video selection options for HDR/SDR.
   * When both inputs are null:
   *
   *    `{ preferHDR: false, allowedVideoRanges: [] }`
   *
   * When `currentVideoRange` non-null, maintain the active range:
   *
   *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`
   *
   * When VideoSelectionOption non-null:
   *
   *  - Allow all video ranges if `allowedVideoRanges` unspecified.
   *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.
   *  - Else check window for HDR support and set `preferHDR` to the result.
   *
   * @param currentVideoRange
   * @param videoPreference
   */
  function getVideoSelectionOptions(currentVideoRange, videoPreference) {
    var preferHDR = false;
    var allowedVideoRanges = [];
    if (currentVideoRange) {
      preferHDR = currentVideoRange !== 'SDR';
      allowedVideoRanges = [currentVideoRange];
    }
    if (videoPreference) {
      allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);
      preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : isHdrSupported();
      if (preferHDR) {
        allowedVideoRanges = allowedVideoRanges.filter(function (range) {
          return range !== 'SDR';
        });
      } else {
        allowedVideoRanges = ['SDR'];
      }
    }
    return {
      preferHDR: preferHDR,
      allowedVideoRanges: allowedVideoRanges
    };
  }

  function getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {
    var codecSets = Object.keys(codecTiers);
    var channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;
    var audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;
    var preferStereo = channelsPreference && parseInt(channelsPreference) === 2;
    // Use first level set to determine stereo, and minimum resolution and framerate
    var hasStereo = true;
    var hasCurrentVideoRange = false;
    var minHeight = Infinity;
    var minFramerate = Infinity;
    var minBitrate = Infinity;
    var selectedScore = 0;
    var videoRanges = [];
    var _getVideoSelectionOpt = getVideoSelectionOptions(currentVideoRange, videoPreference),
      preferHDR = _getVideoSelectionOpt.preferHDR,
      allowedVideoRanges = _getVideoSelectionOpt.allowedVideoRanges;
    var _loop = function _loop() {
      var tier = codecTiers[codecSets[i]];
      hasStereo = tier.channels[2] > 0;
      minHeight = Math.min(minHeight, tier.minHeight);
      minFramerate = Math.min(minFramerate, tier.minFramerate);
      minBitrate = Math.min(minBitrate, tier.minBitrate);
      var matchingVideoRanges = allowedVideoRanges.filter(function (range) {
        return tier.videoRanges[range] > 0;
      });
      if (matchingVideoRanges.length > 0) {
        hasCurrentVideoRange = true;
        videoRanges = matchingVideoRanges;
      }
    };
    for (var i = codecSets.length; i--;) {
      _loop();
    }
    minHeight = isFiniteNumber(minHeight) ? minHeight : 0;
    minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;
    var maxHeight = Math.max(1080, minHeight);
    var maxFramerate = Math.max(30, minFramerate);
    minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;
    currentBw = Math.max(minBitrate, currentBw);
    // If there are no variants with matching preference, set currentVideoRange to undefined
    if (!hasCurrentVideoRange) {
      currentVideoRange = undefined;
      videoRanges = [];
    }
    var codecSet = codecSets.reduce(function (selected, candidate) {
      // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present
      var candidateTier = codecTiers[candidate];
      if (candidate === selected) {
        return selected;
      }
      if (candidateTier.minBitrate > currentBw) {
        logStartCodecCandidateIgnored(candidate, "min bitrate of " + candidateTier.minBitrate + " > current estimate of " + currentBw);
        return selected;
      }
      if (!candidateTier.hasDefaultAudio) {
        logStartCodecCandidateIgnored(candidate, "no renditions with default or auto-select sound found");
        return selected;
      }
      if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {
        logStartCodecCandidateIgnored(candidate, "audio codec preference \"" + audioCodecPreference + "\" not found");
        return selected;
      }
      if (channelsPreference && !preferStereo) {
        if (!candidateTier.channels[channelsPreference]) {
          logStartCodecCandidateIgnored(candidate, "no renditions with " + channelsPreference + " channel sound found (channels options: " + Object.keys(candidateTier.channels) + ")");
          return selected;
        }
      } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels['2'] === 0) {
        logStartCodecCandidateIgnored(candidate, "no renditions with stereo sound found");
        return selected;
      }
      if (candidateTier.minHeight > maxHeight) {
        logStartCodecCandidateIgnored(candidate, "min resolution of " + candidateTier.minHeight + " > maximum of " + maxHeight);
        return selected;
      }
      if (candidateTier.minFramerate > maxFramerate) {
        logStartCodecCandidateIgnored(candidate, "min framerate of " + candidateTier.minFramerate + " > maximum of " + maxFramerate);
        return selected;
      }
      if (!videoRanges.some(function (range) {
        return candidateTier.videoRanges[range] > 0;
      })) {
        logStartCodecCandidateIgnored(candidate, "no variants with VIDEO-RANGE of " + JSON.stringify(videoRanges) + " found");
        return selected;
      }
      if (candidateTier.maxScore < selectedScore) {
        logStartCodecCandidateIgnored(candidate, "max score of " + candidateTier.maxScore + " < selected max of " + selectedScore);
        return selected;
      }
      // Remove candiates with less preferred codecs or more errors
      if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {
        return selected;
      }
      selectedScore = candidateTier.maxScore;
      return candidate;
    }, undefined);
    return {
      codecSet: codecSet,
      videoRanges: videoRanges,
      preferHDR: preferHDR,
      minFramerate: minFramerate,
      minBitrate: minBitrate
    };
  }
  function logStartCodecCandidateIgnored(codeSet, reason) {
    logger.log("[abr] start candidates with \"" + codeSet + "\" ignored because " + reason);
  }
  function getAudioTracksByGroup(allAudioTracks) {
    return allAudioTracks.reduce(function (audioTracksByGroup, track) {
      var trackGroup = audioTracksByGroup.groups[track.groupId];
      if (!trackGroup) {
        trackGroup = audioTracksByGroup.groups[track.groupId] = {
          tracks: [],
          channels: {
            2: 0
          },
          hasDefault: false,
          hasAutoSelect: false
        };
      }
      trackGroup.tracks.push(track);
      var channelsKey = track.channels || '2';
      trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;
      trackGroup.hasDefault = trackGroup.hasDefault || track.default;
      trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;
      if (trackGroup.hasDefault) {
        audioTracksByGroup.hasDefaultAudio = true;
      }
      if (trackGroup.hasAutoSelect) {
        audioTracksByGroup.hasAutoSelectAudio = true;
      }
      return audioTracksByGroup;
    }, {
      hasDefaultAudio: false,
      hasAutoSelectAudio: false,
      groups: {}
    });
  }
  function getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {
    return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce(function (tiers, level) {
      if (!level.codecSet) {
        return tiers;
      }
      var audioGroups = level.audioGroups;
      var tier = tiers[level.codecSet];
      if (!tier) {
        tiers[level.codecSet] = tier = {
          minBitrate: Infinity,
          minHeight: Infinity,
          minFramerate: Infinity,
          maxScore: 0,
          videoRanges: {
            SDR: 0
          },
          channels: {
            '2': 0
          },
          hasDefaultAudio: !audioGroups,
          fragmentError: 0
        };
      }
      tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);
      var lesserWidthOrHeight = Math.min(level.height, level.width);
      tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);
      tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);
      tier.maxScore = Math.max(tier.maxScore, level.score);
      tier.fragmentError += level.fragmentError;
      tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;
      if (audioGroups) {
        audioGroups.forEach(function (audioGroupId) {
          if (!audioGroupId) {
            return;
          }
          var audioGroup = audioTracksByGroup.groups[audioGroupId];
          if (!audioGroup) {
            return;
          }
          // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants
          tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;
          Object.keys(audioGroup.channels).forEach(function (channels) {
            tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];
          });
        });
      }
      return tiers;
    }, {});
  }
  function findMatchingOption(option, tracks, matchPredicate) {
    if ('attrs' in option) {
      var index = tracks.indexOf(option);
      if (index !== -1) {
        return index;
      }
    }
    for (var i = 0; i < tracks.length; i++) {
      var _track = tracks[i];
      if (matchesOption(option, _track, matchPredicate)) {
        return i;
      }
    }
    return -1;
  }
  function matchesOption(option, track, matchPredicate) {
    var groupId = option.groupId,
      name = option.name,
      lang = option.lang,
      assocLang = option.assocLang,
      isDefault = option.default;
    var forced = option.forced;
    return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || track.lang === lang) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (!('characteristics' in option) || characteristicsMatch(option.characteristics || '', track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));
  }
  function characteristicsMatch(characteristicsA, characteristicsB) {
    if (characteristicsB === void 0) {
      characteristicsB = '';
    }
    var arrA = characteristicsA.split(',');
    var arrB = characteristicsB.split(',');
    // Expects each item to be unique:
    return arrA.length === arrB.length && !arrA.some(function (el) {
      return arrB.indexOf(el) === -1;
    });
  }
  function audioMatchPredicate(option, track) {
    var audioCodec = option.audioCodec,
      channels = option.channels;
    return (audioCodec === undefined || (track.audioCodec || '').substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || '2'));
  }
  function findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {
    var currentLevel = levels[searchIndex];
    // Are there variants with same URI as current level?
    // If so, find a match that does not require any level URI change
    var variants = levels.reduce(function (variantMap, level, index) {
      var uri = level.uri;
      var renditions = variantMap[uri] || (variantMap[uri] = []);
      renditions.push(index);
      return variantMap;
    }, {});
    var renditions = variants[currentLevel.uri];
    if (renditions.length > 1) {
      searchIndex = Math.max.apply(Math, renditions);
    }
    // Find best match
    var currentVideoRange = currentLevel.videoRange;
    var currentFrameRate = currentLevel.frameRate;
    var currentVideoCodec = currentLevel.codecSet.substring(0, 4);
    var matchingVideo = searchDownAndUpList(levels, searchIndex, function (level) {
      if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {
        return false;
      }
      var audioGroups = level.audioGroups;
      var tracks = allAudioTracks.filter(function (track) {
        return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;
      });
      return findMatchingOption(option, tracks, matchPredicate) > -1;
    });
    if (matchingVideo > -1) {
      return matchingVideo;
    }
    return searchDownAndUpList(levels, searchIndex, function (level) {
      var audioGroups = level.audioGroups;
      var tracks = allAudioTracks.filter(function (track) {
        return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;
      });
      return findMatchingOption(option, tracks, matchPredicate) > -1;
    });
  }
  function searchDownAndUpList(arr, searchIndex, predicate) {
    for (var i = searchIndex; i > -1; i--) {
      if (predicate(arr[i])) {
        return i;
      }
    }
    for (var _i = searchIndex + 1; _i < arr.length; _i++) {
      if (predicate(arr[_i])) {
        return _i;
      }
    }
    return -1;
  }

  var AbrController = /*#__PURE__*/function () {
    function AbrController(_hls) {
      var _this = this;
      this.hls = void 0;
      this.lastLevelLoadSec = 0;
      this.lastLoadedFragLevel = -1;
      this.firstSelection = -1;
      this._nextAutoLevel = -1;
      this.nextAutoLevelKey = '';
      this.audioTracksByGroup = null;
      this.codecTiers = null;
      this.timer = -1;
      this.fragCurrent = null;
      this.partCurrent = null;
      this.bitrateTestDelay = 0;
      this.bwEstimator = void 0;
      /*
          This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load
          quickly enough to prevent underbuffering
        */
      this._abandonRulesCheck = function () {
        var frag = _this.fragCurrent,
          part = _this.partCurrent,
          hls = _this.hls;
        var autoLevelEnabled = hls.autoLevelEnabled,
          media = hls.media;
        if (!frag || !media) {
          return;
        }
        var now = performance.now();
        var stats = part ? part.stats : frag.stats;
        var duration = part ? part.duration : frag.duration;
        var timeLoading = now - stats.loading.start;
        var minAutoLevel = hls.minAutoLevel;
        // If frag loading is aborted, complete, or from lowest level, stop timer and return
        if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {
          _this.clearTimer();
          // reset forced auto level value so that next level will be selected
          _this._nextAutoLevel = -1;
          return;
        }

        // This check only runs if we're in ABR mode and actually playing
        if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
          return;
        }
        var bufferInfo = hls.mainForwardBufferInfo;
        if (bufferInfo === null) {
          return;
        }
        var ttfbEstimate = _this.bwEstimator.getEstimateTTFB();
        var playbackRate = Math.abs(media.playbackRate);
        // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed
        if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {
          return;
        }

        // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer
        var bufferStarvationDelay = bufferInfo.len / playbackRate;
        var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
        var loadedFirstByte = stats.loaded && ttfb > -1;
        var bwEstimate = _this.getBwEstimate();
        var levels = hls.levels;
        var level = levels[frag.level];
        var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.averageBitrate / 8));
        var timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;
        if (timeStreaming < 1 && loadedFirstByte) {
          timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);
        }
        var loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;
        // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment
        var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;
        // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left
        if (fragLoadedDelay <= bufferStarvationDelay) {
          return;
        }
        var bwe = loadRate ? loadRate * 8 : bwEstimate;
        var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
        var nextLoadLevel;
        // Iterate through lower level and try to find the largest one that avoids rebuffering
        for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
          // compute time to load next fragment at lower level
          // 8 = bits per byte (bps/Bps)
          var levelNextBitrate = levels[nextLoadLevel].maxBitrate;
          fragLevelNextLoadedDelay = _this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);
          if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
            break;
          }
        }
        // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing
        // to load the current one
        if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
          return;
        }

        // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down
        if (fragLevelNextLoadedDelay > duration * 10) {
          return;
        }
        hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;
        if (loadedFirstByte) {
          // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time
          _this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
        } else {
          // If there has been no loading progress, sample TTFB
          _this.bwEstimator.sampleTTFB(timeLoading);
        }
        var nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;
        if (_this.getBwEstimate() * _this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {
          _this.resetEstimator(nextLoadLevelBitrate);
        }
        _this.clearTimer();
        logger.warn("[abr] Fragment " + frag.sn + (part ? ' part ' + part.index : '') + " of level " + frag.level + " is loading too slowly;\n      Time to underbuffer: " + bufferStarvationDelay.toFixed(3) + " s\n      Estimated load time for current fragment: " + fragLoadedDelay.toFixed(3) + " s\n      Estimated load time for down switch fragment: " + fragLevelNextLoadedDelay.toFixed(3) + " s\n      TTFB estimate: " + (ttfb | 0) + " ms\n      Current BW estimate: " + (isFiniteNumber(bwEstimate) ? bwEstimate | 0 : 'Unknown') + " bps\n      New BW estimate: " + (_this.getBwEstimate() | 0) + " bps\n      Switching to level " + nextLoadLevel + " @ " + (nextLoadLevelBitrate | 0) + " bps");
        hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {
          frag: frag,
          part: part,
          stats: stats
        });
      };
      this.hls = _hls;
      this.bwEstimator = this.initEstimator();
      this.registerListeners();
    }
    var _proto = AbrController.prototype;
    _proto.resetEstimator = function resetEstimator(abrEwmaDefaultEstimate) {
      if (abrEwmaDefaultEstimate) {
        logger.log("setting initial bwe to " + abrEwmaDefaultEstimate);
        this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;
      }
      this.firstSelection = -1;
      this.bwEstimator = this.initEstimator();
    };
    _proto.initEstimator = function initEstimator() {
      var config = this.hls.config;
      return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
    };
    _proto.registerListeners = function registerListeners() {
      var hls = this.hls;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
      hls.on(Events.ERROR, this.onError, this);
    };
    _proto.unregisterListeners = function unregisterListeners() {
      var hls = this.hls;
      if (!hls) {
        return;
      }
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
      hls.off(Events.ERROR, this.onError, this);
    };
    _proto.destroy = function destroy() {
      this.unregisterListeners();
      this.clearTimer();
      // @ts-ignore
      this.hls = this._abandonRulesCheck = null;
      this.fragCurrent = this.partCurrent = null;
    };
    _proto.onManifestLoading = function onManifestLoading(event, data) {
      this.lastLoadedFragLevel = -1;
      this.firstSelection = -1;
      this.lastLevelLoadSec = 0;
      this.fragCurrent = this.partCurrent = null;
      this.onLevelsUpdated();
      this.clearTimer();
    };
    _proto.onLevelsUpdated = function onLevelsUpdated() {
      if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {
        this.lastLoadedFragLevel = this.fragCurrent.level;
      }
      this._nextAutoLevel = -1;
      this.onMaxAutoLevelUpdated();
      this.codecTiers = null;
      this.audioTracksByGroup = null;
    };
    _proto.onMaxAutoLevelUpdated = function onMaxAutoLevelUpdated() {
      this.firstSelection = -1;
      this.nextAutoLevelKey = '';
    };
    _proto.onFragLoading = function onFragLoading(event, data) {
      var frag = data.frag;
      if (this.ignoreFragment(frag)) {
        return;
      }
      if (!frag.bitrateTest) {
        var _data$part;
        this.fragCurrent = frag;
        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
      }
      this.clearTimer();
      this.timer = self.setInterval(this._abandonRulesCheck, 100);
    };
    _proto.onLevelSwitching = function onLevelSwitching(event, data) {
      this.clearTimer();
    };
    _proto.onError = function onError(event, data) {
      if (data.fatal) {
        return;
      }
      switch (data.details) {
        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
        case ErrorDetails.BUFFER_APPEND_ERROR:
          // Reset last loaded level so that a new selection can be made after calling recoverMediaError
          this.lastLoadedFragLevel = -1;
          this.firstSelection = -1;
          break;
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
          {
            var frag = data.frag;
            var fragCurrent = this.fragCurrent,
              part = this.partCurrent;
            if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {
              var now = performance.now();
              var stats = part ? part.stats : frag.stats;
              var timeLoading = now - stats.loading.start;
              var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
              var loadedFirstByte = stats.loaded && ttfb > -1;
              if (loadedFirstByte) {
                var ttfbEstimate = this.bwEstimator.getEstimateTTFB();
                this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
              } else {
                this.bwEstimator.sampleTTFB(timeLoading);
              }
            }
            break;
          }
      }
    };
    _proto.getTimeToLoadFrag = function getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {
      var fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;
      var playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;
      return fragLoadSec + playlistLoadSec;
    };
    _proto.onLevelLoaded = function onLevelLoaded(event, data) {
      var config = this.hls.config;
      var loading = data.stats.loading;
      var timeLoadingMs = loading.end - loading.start;
      if (isFiniteNumber(timeLoadingMs)) {
        this.lastLevelLoadSec = timeLoadingMs / 1000;
      }
      if (data.details.live) {
        this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
      } else {
        this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
      }
    };
    _proto.onFragLoaded = function onFragLoaded(event, _ref) {
      var frag = _ref.frag,
        part = _ref.part;
      var stats = part ? part.stats : frag.stats;
      if (frag.type === PlaylistLevelType.MAIN) {
        this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);
      }
      if (this.ignoreFragment(frag)) {
        return;
      }
      // stop monitoring bw once frag loaded
      this.clearTimer();
      // reset forced auto level value so that next level will be selected
      if (frag.level === this._nextAutoLevel) {
        this._nextAutoLevel = -1;
      }
      this.firstSelection = -1;

      // compute level average bitrate
      if (this.hls.config.abrMaxWithRealBitrate) {
        var duration = part ? part.duration : frag.duration;
        var level = this.hls.levels[frag.level];
        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
        level.loaded = {
          bytes: loadedBytes,
          duration: loadedDuration
        };
        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
      }
      if (frag.bitrateTest) {
        var fragBufferedData = {
          stats: stats,
          frag: frag,
          part: part,
          id: frag.type
        };
        this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);
        frag.bitrateTest = false;
      } else {
        // store level id after successful fragment load for playback
        this.lastLoadedFragLevel = frag.level;
      }
    };
    _proto.onFragBuffered = function onFragBuffered(event, data) {
      var frag = data.frag,
        part = data.part;
      var stats = part != null && part.stats.loaded ? part.stats : frag.stats;
      if (stats.aborted) {
        return;
      }
      if (this.ignoreFragment(frag)) {
        return;
      }
      // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;
      // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch
      // is used. If we used buffering in that case, our BW estimate sample will be very large.
      var processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());
      this.bwEstimator.sample(processingMs, stats.loaded);
      stats.bwEstimate = this.getBwEstimate();
      if (frag.bitrateTest) {
        this.bitrateTestDelay = processingMs / 1000;
      } else {
        this.bitrateTestDelay = 0;
      }
    };
    _proto.ignoreFragment = function ignoreFragment(frag) {
      // Only count non-alt-audio frags which were actually buffered in our BW calculations
      return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';
    };
    _proto.clearTimer = function clearTimer() {
      if (this.timer > -1) {
        self.clearInterval(this.timer);
        this.timer = -1;
      }
    };
    _proto.getAutoLevelKey = function getAutoLevelKey() {
      return this.getBwEstimate() + "_" + this.getStarvationDelay().toFixed(2);
    };
    _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {
      var fragCurrent = this.fragCurrent,
        partCurrent = this.partCurrent,
        hls = this.hls;
      var maxAutoLevel = hls.maxAutoLevel,
        config = hls.config,
        minAutoLevel = hls.minAutoLevel;
      var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
      var avgbw = this.getBwEstimate();
      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      var bufferStarvationDelay = this.getStarvationDelay();
      var bwFactor = config.abrBandWidthFactor;
      var bwUpFactor = config.abrBandWidthUpFactor;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      if (bufferStarvationDelay) {
        var _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);
        if (_bestLevel >= 0) {
          return _bestLevel;
        }
      }
      // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering
      var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
      if (!bufferStarvationDelay) {
        // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
        var bitrateTestDelay = this.bitrateTestDelay;
        if (bitrateTestDelay) {
          // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
          // max video loading delay used in  automatic start level selection :
          // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
          // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
          // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
          var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
          maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
          logger.info("[abr] bitrate test took " + Math.round(1000 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1000 * maxStarvationDelay) + " ms");
          // don't use conservative factor on bitrate test
          bwFactor = bwUpFactor = 1;
        }
      }
      var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);
      logger.info("[abr] " + (bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty') + ", optimal quality level " + bestLevel);
      if (bestLevel > -1) {
        return bestLevel;
      }
      // If no matching level found, see if min auto level would be a better option
      var minLevel = hls.levels[minAutoLevel];
      var autoLevel = hls.levels[hls.loadLevel];
      if ((minLevel == null ? void 0 : minLevel.bitrate) < (autoLevel == null ? void 0 : autoLevel.bitrate)) {
        return minAutoLevel;
      }
      // or if bitrate is not lower, continue to use loadLevel
      return hls.loadLevel;
    };
    _proto.getStarvationDelay = function getStarvationDelay() {
      var hls = this.hls;
      var media = hls.media;
      if (!media) {
        return Infinity;
      }
      // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;
      var bufferInfo = hls.mainForwardBufferInfo;
      return (bufferInfo ? bufferInfo.len : 0) / playbackRate;
    };
    _proto.getBwEstimate = function getBwEstimate() {
      return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
    };
    _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {
      var _level$details,
        _this2 = this;
      var maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;
      var lastLoadedFragLevel = this.lastLoadedFragLevel;
      var selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;
      var fragCurrent = this.fragCurrent,
        partCurrent = this.partCurrent;
      var _this$hls = this.hls,
        levels = _this$hls.levels,
        allAudioTracks = _this$hls.allAudioTracks,
        loadLevel = _this$hls.loadLevel,
        config = _this$hls.config;
      if (levels.length === 1) {
        return 0;
      }
      var level = levels[selectionBaseLevel];
      var live = !!(level != null && (_level$details = level.details) != null && _level$details.live);
      var firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;
      var currentCodecSet;
      var currentVideoRange = 'SDR';
      var currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;
      var audioPreference = config.audioPreference,
        videoPreference = config.videoPreference;
      var audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));
      if (firstSelection) {
        if (this.firstSelection !== -1) {
          return this.firstSelection;
        }
        var codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));
        var startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);
        var codecSet = startTier.codecSet,
          videoRanges = startTier.videoRanges,
          minFramerate = startTier.minFramerate,
          minBitrate = startTier.minBitrate,
          preferHDR = startTier.preferHDR;
        currentCodecSet = codecSet;
        currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];
        currentFrameRate = minFramerate;
        currentBw = Math.max(currentBw, minBitrate);
        logger.log("[abr] picked start tier " + JSON.stringify(startTier));
      } else {
        currentCodecSet = level == null ? void 0 : level.codecSet;
        currentVideoRange = level == null ? void 0 : level.videoRange;
      }
      var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
      var ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;
      var levelsSkipped = [];
      var _loop = function _loop() {
          var _levelInfo$supportedR;
          var levelInfo = levels[i];
          var upSwitch = i > selectionBaseLevel;
          if (!levelInfo) {
            return 0; // continue
          }
          if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {
            var mediaCapabilities = navigator.mediaCapabilities;
            if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === 'function' && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {
              levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities);
              levelInfo.supportedPromise.then(function (decodingInfo) {
                if (!_this2.hls) {
                  return;
                }
                levelInfo.supportedResult = decodingInfo;
                var levels = _this2.hls.levels;
                var index = levels.indexOf(levelInfo);
                if (decodingInfo.error) {
                  logger.warn("[abr] MediaCapabilities decodingInfo error: \"" + decodingInfo.error + "\" for level " + index + " " + JSON.stringify(decodingInfo));
                } else if (!decodingInfo.supported) {
                  logger.warn("[abr] Unsupported MediaCapabilities decodingInfo result for level " + index + " " + JSON.stringify(decodingInfo));
                  if (index > -1 && levels.length > 1) {
                    logger.log("[abr] Removing unsupported level " + index);
                    _this2.hls.removeLevel(index);
                  }
                }
              });
            } else {
              levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;
            }
          }

          // skip candidates which change codec-family or video-range,
          // and which decrease or increase frame-rate for up and down-switch respectfully
          if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || levelInfo.supportedResult && !((_levelInfo$supportedR = levelInfo.supportedResult.decodingInfoResults) != null && _levelInfo$supportedR[0].smooth)) {
            levelsSkipped.push(i);
            return 0; // continue
          }
          var levelDetails = levelInfo.details;
          var avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;
          var adjustedbw;
          // follow algorithm captured from stagefright :
          // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
          // Pick the highest bandwidth stream below or equal to estimated bandwidth.
          // consider only 80% of the available bandwidth, but if we are switching up,
          // be even more conservative (70%) to avoid overestimating and immediately
          // switching back.
          if (!upSwitch) {
            adjustedbw = bwFactor * currentBw;
          } else {
            adjustedbw = bwUpFactor * currentBw;
          }

          // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)
          var bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;
          var fetchDuration = _this2.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);
          var canSwitchWithinTolerance =
          // if adjusted bw is greater than level bitrate AND
          adjustedbw >= bitrate && (
          // no level change, or new level has no error history
          i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (
          // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
          // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
          // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
          fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !_this2.bitrateTestDelay || fetchDuration < maxFetchDuration);
          if (canSwitchWithinTolerance) {
            var forcedAutoLevel = _this2.forcedAutoLevel;
            if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {
              if (levelsSkipped.length) {
                logger.trace("[abr] Skipped level(s) " + levelsSkipped.join(',') + " of " + maxAutoLevel + " max with CODECS and VIDEO-RANGE:\"" + levels[levelsSkipped[0]].codecs + "\" " + levels[levelsSkipped[0]].videoRange + "; not compatible with \"" + level.codecs + "\" " + currentVideoRange);
              }
              logger.info("[abr] switch candidate:" + selectionBaseLevel + "->" + i + " adjustedbw(" + Math.round(adjustedbw) + ")-bitrate=" + Math.round(adjustedbw - bitrate) + " ttfb:" + ttfbEstimateSec.toFixed(1) + " avgDuration:" + avgDuration.toFixed(1) + " maxFetchDuration:" + maxFetchDuration.toFixed(1) + " fetchDuration:" + fetchDuration.toFixed(1) + " firstSelection:" + firstSelection + " codecSet:" + currentCodecSet + " videoRange:" + currentVideoRange + " hls.loadLevel:" + loadLevel);
            }
            if (firstSelection) {
              _this2.firstSelection = i;
            }
            // as we are looping from highest to lowest, this will return the best achievable quality level
            return {
              v: i
            };
          }
        },
        _ret;
      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
        _ret = _loop();
        if (_ret === 0) continue;
        if (_ret) return _ret.v;
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    };
    _createClass(AbrController, [{
      key: "firstAutoLevel",
      get: function get() {
        var _this$hls2 = this.hls,
          maxAutoLevel = _this$hls2.maxAutoLevel,
          minAutoLevel = _this$hls2.minAutoLevel;
        var bwEstimate = this.getBwEstimate();
        var maxStartDelay = this.hls.config.maxStarvationDelay;
        var abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);
        if (abrAutoLevel > -1) {
          return abrAutoLevel;
        }
        var firstLevel = this.hls.firstLevel;
        var clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);
        logger.warn("[abr] Could not find best starting auto level. Defaulting to first in playlist " + firstLevel + " clamped to " + clamped);
        return clamped;
      }
    }, {
      key: "forcedAutoLevel",
      get: function get() {
        if (this.nextAutoLevelKey) {
          return -1;
        }
        return this._nextAutoLevel;
      }

      // return next auto level
    }, {
      key: "nextAutoLevel",
      get: function get() {
        var forcedAutoLevel = this.forcedAutoLevel;
        var bwEstimator = this.bwEstimator;
        var useEstimate = bwEstimator.canEstimate();
        var loadedFirstFrag = this.lastLoadedFragLevel > -1;
        // in case next auto level has been forced, and bw not available or not reliable, return forced value
        if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {
          return forcedAutoLevel;
        }

        // compute next level using ABR logic
        var nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;

        // use forced auto level while it hasn't errored more than ABR selection
        if (forcedAutoLevel !== -1) {
          var levels = this.hls.levels;
          if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {
            return forcedAutoLevel;
          }
        }

        // save result until state has changed
        this._nextAutoLevel = nextABRAutoLevel;
        this.nextAutoLevelKey = this.getAutoLevelKey();
        return nextABRAutoLevel;
      },
      set: function set(nextLevel) {
        var _this$hls3 = this.hls,
          maxAutoLevel = _this$hls3.maxAutoLevel,
          minAutoLevel = _this$hls3.minAutoLevel;
        var value = Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);
        if (this._nextAutoLevel !== value) {
          this.nextAutoLevelKey = '';
          this._nextAutoLevel = value;
        }
      }
    }]);
    return AbrController;
  }();

  /**
   * @ignore
   * Sub-class specialization of EventHandler base class.
   *
   * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
   * scheduled asynchroneously, avoiding recursive calls in the same tick.
   *
   * The task itself is implemented in `doTick`. It can be requested and called for single execution
   * using the `tick` method.
   *
   * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
   * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
   *
   * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
   * and cancelled with `clearNextTick`.
   *
   * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
   *
   * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
   *
   * Further explanations:
   *
   * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
   * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
   *
   * When the task execution (`tick` method) is called in re-entrant way this is detected and
   * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
   * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
   */
  var TaskLoop = /*#__PURE__*/function () {
    function TaskLoop() {
      this._boundTick = void 0;
      this._tickTimer = null;
      this._tickInterval = null;
      this._tickCallCount = 0;
      this._boundTick = this.tick.bind(this);
    }
    var _proto = TaskLoop.prototype;
    _proto.destroy = function destroy() {
      this.onHandlerDestroying();
      this.onHandlerDestroyed();
    };
    _proto.onHandlerDestroying = function onHandlerDestroying() {
      // clear all timers before unregistering from event bus
      this.clearNextTick();
      this.clearInterval();
    };
    _proto.onHandlerDestroyed = function onHandlerDestroyed() {};
    _proto.hasInterval = function hasInterval() {
      return !!this._tickInterval;
    };
    _proto.hasNextTick = function hasNextTick() {
      return !!this._tickTimer;
    }

    /**
     * @param millis - Interval time (ms)
     * @eturns True when interval has been scheduled, false when already scheduled (no effect)
     */;
    _proto.setInterval = function setInterval(millis) {
      if (!this._tickInterval) {
        this._tickCallCount = 0;
        this._tickInterval = self.setInterval(this._boundTick, millis);
        return true;
      }
      return false;
    }

    /**
     * @returns True when interval was cleared, false when none was set (no effect)
     */;
    _proto.clearInterval = function clearInterval() {
      if (this._tickInterval) {
        self.clearInterval(this._tickInterval);
        this._tickInterval = null;
        return true;
      }
      return false;
    }

    /**
     * @returns True when timeout was cleared, false when none was set (no effect)
     */;
    _proto.clearNextTick = function clearNextTick() {
      if (this._tickTimer) {
        self.clearTimeout(this._tickTimer);
        this._tickTimer = null;
        return true;
      }
      return false;
    }

    /**
     * Will call the subclass doTick implementation in this main loop tick
     * or in the next one (via setTimeout(,0)) in case it has already been called
     * in this tick (in case this is a re-entrant call).
     */;
    _proto.tick = function tick() {
      this._tickCallCount++;
      if (this._tickCallCount === 1) {
        this.doTick();
        // re-entrant call to tick from previous doTick call stack
        // -> schedule a call on the next main loop iteration to process this task processing request
        if (this._tickCallCount > 1) {
          // make sure only one timer exists at any time at max
          this.tickImmediate();
        }
        this._tickCallCount = 0;
      }
    };
    _proto.tickImmediate = function tickImmediate() {
      this.clearNextTick();
      this._tickTimer = self.setTimeout(this._boundTick, 0);
    }

    /**
     * For subclass to implement task logic
     * @abstract
     */;
    _proto.doTick = function doTick() {};
    return TaskLoop;
  }();

  var FragmentState = {
    NOT_LOADED: "NOT_LOADED",
    APPENDING: "APPENDING",
    PARTIAL: "PARTIAL",
    OK: "OK"
  };
  var FragmentTracker = /*#__PURE__*/function () {
    function FragmentTracker(hls) {
      this.activePartLists = Object.create(null);
      this.endListFragments = Object.create(null);
      this.fragments = Object.create(null);
      this.timeRanges = Object.create(null);
      this.bufferPadding = 0.2;
      this.hls = void 0;
      this.hasGaps = false;
      this.hls = hls;
      this._registerListeners();
    }
    var _proto = FragmentTracker.prototype;
    _proto._registerListeners = function _registerListeners() {
      var hls = this.hls;
      hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
    };
    _proto._unregisterListeners = function _unregisterListeners() {
      var hls = this.hls;
      hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
    };
    _proto.destroy = function destroy() {
      this._unregisterListeners();
      // @ts-ignore
      this.fragments =
      // @ts-ignore
      this.activePartLists =
      // @ts-ignore
      this.endListFragments = this.timeRanges = null;
    }

    /**
     * Return a Fragment or Part with an appended range that matches the position and levelType
     * Otherwise, return null
     */;
    _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {
      var activeParts = this.activePartLists[levelType];
      if (activeParts) {
        for (var i = activeParts.length; i--;) {
          var activePart = activeParts[i];
          if (!activePart) {
            break;
          }
          var appendedPTS = activePart.end;
          if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {
            return activePart;
          }
        }
      }
      return this.getBufferedFrag(position, levelType);
    }

    /**
     * Return a buffered Fragment that matches the position and levelType.
     * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
     * If not found any Fragment, return null
     */;
    _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {
      var fragments = this.fragments;
      var keys = Object.keys(fragments);
      for (var i = keys.length; i--;) {
        var fragmentEntity = fragments[keys[i]];
        if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
          var frag = fragmentEntity.body;
          if (frag.start <= position && position <= frag.end) {
            return frag;
          }
        }
      }
      return null;
    }

    /**
     * Partial fragments effected by coded frame eviction will be removed
     * The browser will unload parts of the buffer to free up memory for new buffer data
     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
     */;
    _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {
      var _this = this;
      if (this.timeRanges) {
        this.timeRanges[elementaryStream] = timeRange;
      }
      // Check if any flagged fragments have been unloaded
      // excluding anything newer than appendedPartSn
      var appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this.fragments[key];
        if (!fragmentEntity) {
          return;
        }
        if (appendedPartSn >= fragmentEntity.body.sn) {
          return;
        }
        if (!fragmentEntity.buffered && !fragmentEntity.loaded) {
          if (fragmentEntity.body.type === playlistType) {
            _this.removeFragment(fragmentEntity.body);
          }
          return;
        }
        var esData = fragmentEntity.range[elementaryStream];
        if (!esData) {
          return;
        }
        esData.time.some(function (time) {
          var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
          if (isNotBuffered) {
            // Unregister partial fragment as it needs to load again to be reused
            _this.removeFragment(fragmentEntity.body);
          }
          return isNotBuffered;
        });
      });
    }

    /**
     * Checks if the fragment passed in is loaded in the buffer properly
     * Partially loaded fragments will be registered as a partial fragment
     */;
    _proto.detectPartialFragments = function detectPartialFragments(data) {
      var _this2 = this;
      var timeRanges = this.timeRanges;
      var frag = data.frag,
        part = data.part;
      if (!timeRanges || frag.sn === 'initSegment') {
        return;
      }
      var fragKey = getFragmentKey(frag);
      var fragmentEntity = this.fragments[fragKey];
      if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {
        return;
      }
      var isFragHint = !frag.relurl;
      Object.keys(timeRanges).forEach(function (elementaryStream) {
        var streamInfo = frag.elementaryStreams[elementaryStream];
        if (!streamInfo) {
          return;
        }
        var timeRange = timeRanges[elementaryStream];
        var partial = isFragHint || streamInfo.partial === true;
        fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);
      });
      fragmentEntity.loaded = null;
      if (Object.keys(fragmentEntity.range).length) {
        fragmentEntity.buffered = true;
        var endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;
        if (endList) {
          this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
        }
        if (!isPartial(fragmentEntity)) {
          // Remove older fragment parts from lookup after frag is tracked as buffered
          this.removeParts(frag.sn - 1, frag.type);
        }
      } else {
        // remove fragment if nothing was appended
        this.removeFragment(fragmentEntity.body);
      }
    };
    _proto.removeParts = function removeParts(snToKeep, levelType) {
      var activeParts = this.activePartLists[levelType];
      if (!activeParts) {
        return;
      }
      this.activePartLists[levelType] = activeParts.filter(function (part) {
        return part.fragment.sn >= snToKeep;
      });
    };
    _proto.fragBuffered = function fragBuffered(frag, force) {
      var fragKey = getFragmentKey(frag);
      var fragmentEntity = this.fragments[fragKey];
      if (!fragmentEntity && force) {
        fragmentEntity = this.fragments[fragKey] = {
          body: frag,
          appendedPTS: null,
          loaded: null,
          buffered: false,
          range: Object.create(null)
        };
        if (frag.gap) {
          this.hasGaps = true;
        }
      }
      if (fragmentEntity) {
        fragmentEntity.loaded = null;
        fragmentEntity.buffered = true;
      }
    };
    _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {
      var buffered = {
        time: [],
        partial: partial
      };
      var startPTS = fragment.start;
      var endPTS = fragment.end;
      var minEndPTS = fragment.minEndPTS || endPTS;
      var maxStartPTS = fragment.maxStartPTS || startPTS;
      for (var i = 0; i < timeRange.length; i++) {
        var startTime = timeRange.start(i) - this.bufferPadding;
        var endTime = timeRange.end(i) + this.bufferPadding;
        if (maxStartPTS >= startTime && minEndPTS <= endTime) {
          // Fragment is entirely contained in buffer
          // No need to check the other timeRange times since it's completely playable
          buffered.time.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          break;
        } else if (startPTS < endTime && endPTS > startTime) {
          var start = Math.max(startPTS, timeRange.start(i));
          var end = Math.min(endPTS, timeRange.end(i));
          if (end > start) {
            buffered.partial = true;
            // Check for intersection with buffer
            // Get playable sections of the fragment
            buffered.time.push({
              startPTS: start,
              endPTS: end
            });
          }
        } else if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          break;
        }
      }
      return buffered;
    }

    /**
     * Gets the partial fragment for a certain time
     */;
    _proto.getPartialFragment = function getPartialFragment(time) {
      var bestFragment = null;
      var timePadding;
      var startTime;
      var endTime;
      var bestOverlap = 0;
      var bufferPadding = this.bufferPadding,
        fragments = this.fragments;
      Object.keys(fragments).forEach(function (key) {
        var fragmentEntity = fragments[key];
        if (!fragmentEntity) {
          return;
        }
        if (isPartial(fragmentEntity)) {
          startTime = fragmentEntity.body.start - bufferPadding;
          endTime = fragmentEntity.body.end + bufferPadding;
          if (time >= startTime && time <= endTime) {
            // Use the fragment that has the most padding from start and end time
            timePadding = Math.min(time - startTime, endTime - time);
            if (bestOverlap <= timePadding) {
              bestFragment = fragmentEntity.body;
              bestOverlap = timePadding;
            }
          }
        }
      });
      return bestFragment;
    };
    _proto.isEndListAppended = function isEndListAppended(type) {
      var lastFragmentEntity = this.endListFragments[type];
      return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
    };
    _proto.getState = function getState(fragment) {
      var fragKey = getFragmentKey(fragment);
      var fragmentEntity = this.fragments[fragKey];
      if (fragmentEntity) {
        if (!fragmentEntity.buffered) {
          return FragmentState.APPENDING;
        } else if (isPartial(fragmentEntity)) {
          return FragmentState.PARTIAL;
        } else {
          return FragmentState.OK;
        }
      }
      return FragmentState.NOT_LOADED;
    };
    _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {
      var startTime;
      var endTime;
      for (var i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          return true;
        }
        if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          return false;
        }
      }
      return false;
    };
    _proto.onFragLoaded = function onFragLoaded(event, data) {
      var frag = data.frag,
        part = data.part;
      // don't track initsegment (for which sn is not a number)
      // don't track frags used for bitrateTest, they're irrelevant.
      if (frag.sn === 'initSegment' || frag.bitrateTest) {
        return;
      }

      // Fragment entity `loaded` FragLoadedData is null when loading parts
      var loaded = part ? null : data;
      var fragKey = getFragmentKey(frag);
      this.fragments[fragKey] = {
        body: frag,
        appendedPTS: null,
        loaded: loaded,
        buffered: false,
        range: Object.create(null)
      };
    };
    _proto.onBufferAppended = function onBufferAppended(event, data) {
      var _this3 = this;
      var frag = data.frag,
        part = data.part,
        timeRanges = data.timeRanges;
      if (frag.sn === 'initSegment') {
        return;
      }
      var playlistType = frag.type;
      if (part) {
        var activeParts = this.activePartLists[playlistType];
        if (!activeParts) {
          this.activePartLists[playlistType] = activeParts = [];
        }
        activeParts.push(part);
      }
      // Store the latest timeRanges loaded in the buffer
      this.timeRanges = timeRanges;
      Object.keys(timeRanges).forEach(function (elementaryStream) {
        var timeRange = timeRanges[elementaryStream];
        _this3.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);
      });
    };
    _proto.onFragBuffered = function onFragBuffered(event, data) {
      this.detectPartialFragments(data);
    };
    _proto.hasFragment = function hasFragment(fragment) {
      var fragKey = getFragmentKey(fragment);
      return !!this.fragments[fragKey];
    };
    _proto.hasParts = function hasParts(type) {
      var _this$activePartLists;
      return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);
    };
    _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {
      var _this4 = this;
      if (withGapOnly && !this.hasGaps) {
        return;
      }
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this4.fragments[key];
        if (!fragmentEntity) {
          return;
        }
        var frag = fragmentEntity.body;
        if (frag.type !== playlistType || withGapOnly && !frag.gap) {
          return;
        }
        if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {
          _this4.removeFragment(frag);
        }
      });
    };
    _proto.removeFragment = function removeFragment(fragment) {
      var fragKey = getFragmentKey(fragment);
      fragment.stats.loaded = 0;
      fragment.clearElementaryStreamInfo();
      var activeParts = this.activePartLists[fragment.type];
      if (activeParts) {
        var snToRemove = fragment.sn;
        this.activePartLists[fragment.type] = activeParts.filter(function (part) {
          return part.fragment.sn !== snToRemove;
        });
      }
      delete this.fragments[fragKey];
      if (fragment.endList) {
        delete this.endListFragments[fragment.type];
      }
    };
    _proto.removeAllFragments = function removeAllFragments() {
      this.fragments = Object.create(null);
      this.endListFragments = Object.create(null);
      this.activePartLists = Object.create(null);
      this.hasGaps = false;
    };
    return FragmentTracker;
  }();
  function isPartial(fragmentEntity) {
    var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;
    return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));
  }
  function getFragmentKey(fragment) {
    return fragment.type + "_" + fragment.level + "_" + fragment.sn;
  }

  /**
   * Provides methods dealing with buffer length retrieval for example.
   *
   * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
   *
   * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
   */

  var noopBuffered = {
    length: 0,
    start: function start() {
      return 0;
    },
    end: function end() {
      return 0;
    }
  };
  var BufferHelper = /*#__PURE__*/function () {
    function BufferHelper() {}
    /**
     * Return true if `media`'s buffered include `position`
     */
    BufferHelper.isBuffered = function isBuffered(media, position) {
      try {
        if (media) {
          var buffered = BufferHelper.getBuffered(media);
          for (var i = 0; i < buffered.length; i++) {
            if (position >= buffered.start(i) && position <= buffered.end(i)) {
              return true;
            }
          }
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return false;
    };
    BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {
      try {
        if (media) {
          var vbuffered = BufferHelper.getBuffered(media);
          var buffered = [];
          var i;
          for (i = 0; i < vbuffered.length; i++) {
            buffered.push({
              start: vbuffered.start(i),
              end: vbuffered.end(i)
            });
          }
          return this.bufferedInfo(buffered, pos, maxHoleDuration);
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return {
        len: 0,
        start: pos,
        end: pos,
        nextStart: undefined
      };
    };
    BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {
      pos = Math.max(0, pos);
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        var diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      var buffered2 = [];
      if (maxHoleDuration) {
        // there might be some small holes between buffer time range
        // consider that holes smaller than maxHoleDuration are irrelevant and build another
        // buffer time range representations that discards those holes
        for (var i = 0; i < buffered.length; i++) {
          var buf2len = buffered2.length;
          if (buf2len) {
            var buf2end = buffered2[buf2len - 1].end;
            // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
            if (buffered[i].start - buf2end < maxHoleDuration) {
              // merge overlapping time ranges
              // update lastRange.end only if smaller than item.end
              // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
              // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
              if (buffered[i].end > buf2end) {
                buffered2[buf2len - 1].end = buffered[i].end;
              }
            } else {
              // big hole
              buffered2.push(buffered[i]);
            }
          } else {
            // first value
            buffered2.push(buffered[i]);
          }
        }
      } else {
        buffered2 = buffered;
      }
      var bufferLen = 0;

      // bufferStartNext can possibly be undefined based on the conditional logic below
      var bufferStartNext;

      // bufferStart and bufferEnd are buffer boundaries around current video position
      var bufferStart = pos;
      var bufferEnd = pos;
      for (var _i = 0; _i < buffered2.length; _i++) {
        var start = buffered2[_i].start;
        var end = buffered2[_i].end;
        // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return {
        len: bufferLen,
        start: bufferStart || 0,
        end: bufferEnd || 0,
        nextStart: bufferStartNext
      };
    }

    /**
     * Safe method to get buffered property.
     * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
     */;
    BufferHelper.getBuffered = function getBuffered(media) {
      try {
        return media.buffered;
      } catch (e) {
        logger.log('failed to get media.buffered', e);
        return noopBuffered;
      }
    };
    return BufferHelper;
  }();

  var ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {
    if (size === void 0) {
      size = 0;
    }
    if (part === void 0) {
      part = -1;
    }
    if (partial === void 0) {
      partial = false;
    }
    this.level = void 0;
    this.sn = void 0;
    this.part = void 0;
    this.id = void 0;
    this.size = void 0;
    this.partial = void 0;
    this.transmuxing = getNewPerformanceTiming();
    this.buffering = {
      audio: getNewPerformanceTiming(),
      video: getNewPerformanceTiming(),
      audiovideo: getNewPerformanceTiming()
    };
    this.level = level;
    this.sn = sn;
    this.id = id;
    this.size = size;
    this.part = part;
    this.partial = partial;
  };
  function getNewPerformanceTiming() {
    return {
      start: 0,
      executeStart: 0,
      executeEnd: 0,
      end: 0
    };
  }

  function findFirstFragWithCC(fragments, cc) {
    for (var i = 0, len = fragments.length; i < len; i++) {
      var _fragments$i;
      if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {
        return fragments[i];
      }
    }
    return null;
  }
  function shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {
    if (switchDetails) {
      if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
        return true;
      }
    }
    return false;
  }

  // Find the first frag in the previous level which matches the CC of the first frag of the new level
  function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
    var prevFrags = prevDetails.fragments;
    var curFrags = curDetails.fragments;
    if (!curFrags.length || !prevFrags.length) {
      logger.log('No fragments to align');
      return;
    }
    var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
    if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
      logger.log('No frag in previous level to align on');
      return;
    }
    return prevStartFrag;
  }
  function adjustFragmentStart(frag, sliding) {
    if (frag) {
      var start = frag.start + sliding;
      frag.start = frag.startPTS = start;
      frag.endPTS = start + frag.duration;
    }
  }
  function adjustSlidingStart(sliding, details) {
    // Update segments
    var fragments = details.fragments;
    for (var i = 0, len = fragments.length; i < len; i++) {
      adjustFragmentStart(fragments[i], sliding);
    }
    // Update LL-HLS parts at the end of the playlist
    if (details.fragmentHint) {
      adjustFragmentStart(details.fragmentHint, sliding);
    }
    details.alignedSliding = true;
  }

  /**
   * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
   * contiguous stream with the last fragments.
   * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
   * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
   * and an extra download.
   * @param lastFrag
   * @param lastLevel
   * @param details
   */
  function alignStream(lastFrag, switchDetails, details) {
    if (!switchDetails) {
      return;
    }
    alignDiscontinuities(lastFrag, details, switchDetails);
    if (!details.alignedSliding && switchDetails) {
      // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
      // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
      // discontinuity sequence.
      alignMediaPlaylistByPDT(details, switchDetails);
    }
    if (!details.alignedSliding && switchDetails && !details.skippedSegments) {
      // Try to align on sn so that we pick a better start fragment.
      // Do not perform this on playlists with delta updates as this is only to align levels on switch
      // and adjustSliding only adjusts fragments after skippedSegments.
      adjustSliding(switchDetails, details);
    }
  }

  /**
   * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
   * discontinuity sequence.
   * @param lastFrag - The last Fragment which shares the same discontinuity sequence
   * @param lastLevel - The details of the last loaded level
   * @param details - The details of the new level
   */
  function alignDiscontinuities(lastFrag, details, switchDetails) {
    if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {
      var referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);
      if (referenceFrag && isFiniteNumber(referenceFrag.start)) {
        logger.log("Adjusting PTS using last level due to CC increase within current level " + details.url);
        adjustSlidingStart(referenceFrag.start, details);
      }
    }
  }

  /**
   * Ensures appropriate time-alignment between renditions based on PDT.
   * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs
   * for the last discontinuity sequence number shared by both playlists when present,
   * and uses the "wallclock"/PDT timeline as a cross-reference to `details`, adjusting the presentation
   * times/timelines of `details` accordingly.
   * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,
   * the primary purpose of this function is to ensure the "local timelines" of audio/subtitle tracks
   * are aligned to the main/video timeline, using PDT as the cross-reference/"anchor" that should
   * be consistent across playlists, per the HLS spec.
   * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).
   * @param refDetails - The details of the reference rendition with start and PDT times for alignment.
   */
  function alignMediaPlaylistByPDT(details, refDetails) {
    if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
      return;
    }
    var fragments = details.fragments;
    var refFragments = refDetails.fragments;
    if (!fragments.length || !refFragments.length) {
      return;
    }

    // Calculate a delta to apply to all fragments according to the delta in PDT times and start times
    // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.
    // If a fragment of the same discontinuity was not found use the middle fragment of both.
    var refFrag;
    var frag;
    var targetCC = Math.min(refDetails.endCC, details.endCC);
    if (refDetails.startCC < targetCC && details.startCC < targetCC) {
      refFrag = findFirstFragWithCC(refFragments, targetCC);
      frag = findFirstFragWithCC(fragments, targetCC);
    }
    if (!refFrag || !frag) {
      refFrag = refFragments[Math.floor(refFragments.length / 2)];
      frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];
    }
    var refPDT = refFrag.programDateTime;
    var targetPDT = frag.programDateTime;
    if (!refPDT || !targetPDT) {
      return;
    }
    var delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);
    adjustSlidingStart(delta, details);
  }

  var MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb
  var FragmentLoader = /*#__PURE__*/function () {
    function FragmentLoader(config) {
      this.config = void 0;
      this.loader = null;
      this.partLoadTimeout = -1;
      this.config = config;
    }
    var _proto = FragmentLoader.prototype;
    _proto.destroy = function destroy() {
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
    };
    _proto.abort = function abort() {
      if (this.loader) {
        // Abort the loader for current fragment. Only one may load at any given time
        this.loader.abort();
      }
    };
    _proto.load = function load(frag, _onProgress) {
      var _this = this;
      var url = frag.url;
      if (!url) {
        return Promise.reject(new LoadError({
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.FRAG_LOAD_ERROR,
          fatal: false,
          frag: frag,
          error: new Error("Fragment does not have a " + (url ? 'part list' : 'url')),
          networkDetails: null
        }));
      }
      this.abort();
      var config = this.config;
      var FragmentILoader = config.fLoader;
      var DefaultILoader = config.loader;
      return new Promise(function (resolve, reject) {
        if (_this.loader) {
          _this.loader.destroy();
        }
        if (frag.gap) {
          if (frag.tagList.some(function (tags) {
            return tags[0] === 'GAP';
          })) {
            reject(createGapLoadError(frag));
            return;
          } else {
            // Reset temporary treatment as GAP tag
            frag.gap = false;
          }
        }
        var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
        var loaderContext = createLoaderContext(frag);
        var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
        var loaderConfig = {
          loadPolicy: loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE
        };
        // Assign frag stats to the loader's stats reference
        frag.stats = loader.stats;
        loader.load(loaderContext, loaderConfig, {
          onSuccess: function onSuccess(response, stats, context, networkDetails) {
            _this.resetLoader(frag, loader);
            var payload = response.data;
            if (context.resetIV && frag.decryptdata) {
              frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
              payload = payload.slice(16);
            }
            resolve({
              frag: frag,
              part: null,
              payload: payload,
              networkDetails: networkDetails
            });
          },
          onError: function onError(response, context, networkDetails, stats) {
            _this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_ERROR,
              fatal: false,
              frag: frag,
              response: _objectSpread2({
                url: url,
                data: undefined
              }, response),
              error: new Error("HTTP Error " + response.code + " " + response.text),
              networkDetails: networkDetails,
              stats: stats
            }));
          },
          onAbort: function onAbort(stats, context, networkDetails) {
            _this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.INTERNAL_ABORTED,
              fatal: false,
              frag: frag,
              error: new Error('Aborted'),
              networkDetails: networkDetails,
              stats: stats
            }));
          },
          onTimeout: function onTimeout(stats, context, networkDetails) {
            _this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_TIMEOUT,
              fatal: false,
              frag: frag,
              error: new Error("Timeout after " + loaderConfig.timeout + "ms"),
              networkDetails: networkDetails,
              stats: stats
            }));
          },
          onProgress: function onProgress(stats, context, data, networkDetails) {
            if (_onProgress) {
              _onProgress({
                frag: frag,
                part: null,
                payload: data,
                networkDetails: networkDetails
              });
            }
          }
        });
      });
    };
    _proto.loadPart = function loadPart(frag, part, onProgress) {
      var _this2 = this;
      this.abort();
      var config = this.config;
      var FragmentILoader = config.fLoader;
      var DefaultILoader = config.loader;
      return new Promise(function (resolve, reject) {
        if (_this2.loader) {
          _this2.loader.destroy();
        }
        if (frag.gap || part.gap) {
          reject(createGapLoadError(frag, part));
          return;
        }
        var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
        var loaderContext = createLoaderContext(frag, part);
        // Should we define another load policy for parts?
        var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
        var loaderConfig = {
          loadPolicy: loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: MIN_CHUNK_SIZE
        };
        // Assign part stats to the loader's stats reference
        part.stats = loader.stats;
        loader.load(loaderContext, loaderConfig, {
          onSuccess: function onSuccess(response, stats, context, networkDetails) {
            _this2.resetLoader(frag, loader);
            _this2.updateStatsFromPart(frag, part);
            var partLoadedData = {
              frag: frag,
              part: part,
              payload: response.data,
              networkDetails: networkDetails
            };
            onProgress(partLoadedData);
            resolve(partLoadedData);
          },
          onError: function onError(response, context, networkDetails, stats) {
            _this2.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_ERROR,
              fatal: false,
              frag: frag,
              part: part,
              response: _objectSpread2({
                url: loaderContext.url,
                data: undefined
              }, response),
              error: new Error("HTTP Error " + response.code + " " + response.text),
              networkDetails: networkDetails,
              stats: stats
            }));
          },
          onAbort: function onAbort(stats, context, networkDetails) {
            frag.stats.aborted = part.stats.aborted;
            _this2.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.INTERNAL_ABORTED,
              fatal: false,
              frag: frag,
              part: part,
              error: new Error('Aborted'),
              networkDetails: networkDetails,
              stats: stats
            }));
          },
          onTimeout: function onTimeout(stats, context, networkDetails) {
            _this2.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_TIMEOUT,
              fatal: false,
              frag: frag,
              part: part,
              error: new Error("Timeout after " + loaderConfig.timeout + "ms"),
              networkDetails: networkDetails,
              stats: stats
            }));
          }
        });
      });
    };
    _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {
      var fragStats = frag.stats;
      var partStats = part.stats;
      var partTotal = partStats.total;
      fragStats.loaded += partStats.loaded;
      if (partTotal) {
        var estTotalParts = Math.round(frag.duration / part.duration);
        var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
        var estRemainingParts = estTotalParts - estLoadedParts;
        var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
        fragStats.total = fragStats.loaded + estRemainingBytes;
      } else {
        fragStats.total = Math.max(fragStats.loaded, fragStats.total);
      }
      var fragLoading = fragStats.loading;
      var partLoading = partStats.loading;
      if (fragLoading.start) {
        // add to fragment loader latency
        fragLoading.first += partLoading.first - partLoading.start;
      } else {
        fragLoading.start = partLoading.start;
        fragLoading.first = partLoading.first;
      }
      fragLoading.end = partLoading.end;
    };
    _proto.resetLoader = function resetLoader(frag, loader) {
      frag.loader = null;
      if (this.loader === loader) {
        self.clearTimeout(this.partLoadTimeout);
        this.loader = null;
      }
      loader.destroy();
    };
    return FragmentLoader;
  }();
  function createLoaderContext(frag, part) {
    if (part === void 0) {
      part = null;
    }
    var segment = part || frag;
    var loaderContext = {
      frag: frag,
      part: part,
      responseType: 'arraybuffer',
      url: segment.url,
      headers: {},
      rangeStart: 0,
      rangeEnd: 0
    };
    var start = segment.byteRangeStartOffset;
    var end = segment.byteRangeEndOffset;
    if (isFiniteNumber(start) && isFiniteNumber(end)) {
      var _frag$decryptdata;
      var byteRangeStart = start;
      var byteRangeEnd = end;
      if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === 'AES-128') {
        // MAP segment encrypted with method 'AES-128', when served with HTTP Range,
        // has the unencrypted size specified in the range.
        // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6
        var fragmentLen = end - start;
        if (fragmentLen % 16) {
          byteRangeEnd = end + (16 - fragmentLen % 16);
        }
        if (start !== 0) {
          loaderContext.resetIV = true;
          byteRangeStart = start - 16;
        }
      }
      loaderContext.rangeStart = byteRangeStart;
      loaderContext.rangeEnd = byteRangeEnd;
    }
    return loaderContext;
  }
  function createGapLoadError(frag, part) {
    var error = new Error("GAP " + (frag.gap ? 'tag' : 'attribute') + " found");
    var errorData = {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_GAP,
      fatal: false,
      frag: frag,
      error: error,
      networkDetails: null
    };
    if (part) {
      errorData.part = part;
    }
    (part ? part : frag).stats.aborted = true;
    return new LoadError(errorData);
  }
  var LoadError = /*#__PURE__*/function (_Error) {
    _inheritsLoose(LoadError, _Error);
    function LoadError(data) {
      var _this3;
      _this3 = _Error.call(this, data.error.message) || this;
      _this3.data = void 0;
      _this3.data = data;
      return _this3;
    }
    return LoadError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  var AESCrypto = /*#__PURE__*/function () {
    function AESCrypto(subtle, iv) {
      this.subtle = void 0;
      this.aesIV = void 0;
      this.subtle = subtle;
      this.aesIV = iv;
    }
    var _proto = AESCrypto.prototype;
    _proto.decrypt = function decrypt(data, key) {
      return this.subtle.decrypt({
        name: 'AES-CBC',
        iv: this.aesIV
      }, key, data);
    };
    return AESCrypto;
  }();

  var FastAESKey = /*#__PURE__*/function () {
    function FastAESKey(subtle, key) {
      this.subtle = void 0;
      this.key = void 0;
      this.subtle = subtle;
      this.key = key;
    }
    var _proto = FastAESKey.prototype;
    _proto.expandKey = function expandKey() {
      return this.subtle.importKey('raw', this.key, {
        name: 'AES-CBC'
      }, false, ['encrypt', 'decrypt']);
    };
    return FastAESKey;
  }();

  // PKCS7
  function removePadding(array) {
    var outputBytes = array.byteLength;
    var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
    if (paddingBytes) {
      return sliceUint8(array, 0, outputBytes - paddingBytes);
    }
    return array;
  }
  var AESDecryptor = /*#__PURE__*/function () {
    function AESDecryptor() {
      this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
      this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.sBox = new Uint32Array(256);
      this.invSBox = new Uint32Array(256);
      this.key = new Uint32Array(0);
      this.ksRows = 0;
      this.keySize = 0;
      this.keySchedule = void 0;
      this.invKeySchedule = void 0;
      this.initTable();
    }

    // Using view.getUint32() also swaps the byte order.
    var _proto = AESDecryptor.prototype;
    _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }
      return newArray;
    };
    _proto.initTable = function initTable() {
      var sBox = this.sBox;
      var invSBox = this.invSBox;
      var subMix = this.subMix;
      var subMix0 = subMix[0];
      var subMix1 = subMix[1];
      var subMix2 = subMix[2];
      var subMix3 = subMix[3];
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];
      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }
      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    };
    _proto.expandKey = function expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      var key = this.uint8ArrayToUint32Array_(keyBuffer);
      var sameKey = true;
      var offset = 0;
      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }
      if (sameKey) {
        return;
      }
      this.key = key;
      var keySize = this.keySize = key.length;
      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }
      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      var ksRow;
      var invKsRow;
      var keySchedule = this.keySchedule = new Uint32Array(ksRows);
      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      var sbox = this.sBox;
      var rcon = this.rcon;
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];
      var prev;
      var t;
      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;
        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }
        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }
      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }
        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }
        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.
    ;
    _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    };
    _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {
      var nRounds = this.keySize + 6;
      var invKeySchedule = this.invKeySchedule;
      var invSBOX = this.invSBox;
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];
      var initVector = this.uint8ArrayToUint32Array_(aesIV);
      var initVector0 = initVector[0];
      var initVector1 = initVector[1];
      var initVector2 = initVector[2];
      var initVector3 = initVector[3];
      var inputInt32 = new Int32Array(inputArrayBuffer);
      var outputInt32 = new Int32Array(inputInt32.length);
      var t0, t1, t2, t3;
      var s0, s1, s2, s3;
      var inputWords0, inputWords1, inputWords2, inputWords3;
      var ksRow, i;
      var swapWord = this.networkToHostOrderSwap;
      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);
        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];
        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];

        // Write
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;
        offset = offset + 4;
      }
      return outputInt32.buffer;
    };
    return AESDecryptor;
  }();

  var CHUNK_SIZE = 16; // 16 bytes, 128 bits
  var Decrypter = /*#__PURE__*/function () {
    function Decrypter(config, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,
        removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;
      this.logEnabled = true;
      this.removePKCS7Padding = void 0;
      this.subtle = null;
      this.softwareDecrypter = null;
      this.key = null;
      this.fastAesKey = null;
      this.remainderData = null;
      this.currentIV = null;
      this.currentResult = null;
      this.useSoftware = void 0;
      this.useSoftware = config.enableSoftwareAES;
      this.removePKCS7Padding = removePKCS7Padding;
      // built in decryptor expects PKCS7 padding
      if (removePKCS7Padding) {
        try {
          var browserCrypto = self.crypto;
          if (browserCrypto) {
            this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
          }
        } catch (e) {
          /* no-op */
        }
      }
      this.useSoftware = !this.subtle;
    }
    var _proto = Decrypter.prototype;
    _proto.destroy = function destroy() {
      this.subtle = null;
      this.softwareDecrypter = null;
      this.key = null;
      this.fastAesKey = null;
      this.remainderData = null;
      this.currentIV = null;
      this.currentResult = null;
    };
    _proto.isSync = function isSync() {
      return this.useSoftware;
    };
    _proto.flush = function flush() {
      var currentResult = this.currentResult,
        remainderData = this.remainderData;
      if (!currentResult || remainderData) {
        this.reset();
        return null;
      }
      var data = new Uint8Array(currentResult);
      this.reset();
      if (this.removePKCS7Padding) {
        return removePadding(data);
      }
      return data;
    };
    _proto.reset = function reset() {
      this.currentResult = null;
      this.currentIV = null;
      this.remainderData = null;
      if (this.softwareDecrypter) {
        this.softwareDecrypter = null;
      }
    };
    _proto.decrypt = function decrypt(data, key, iv) {
      var _this = this;
      if (this.useSoftware) {
        return new Promise(function (resolve, reject) {
          _this.softwareDecrypt(new Uint8Array(data), key, iv);
          var decryptResult = _this.flush();
          if (decryptResult) {
            resolve(decryptResult.buffer);
          } else {
            reject(new Error('[softwareDecrypt] Failed to decrypt data'));
          }
        });
      }
      return this.webCryptoDecrypt(new Uint8Array(data), key, iv);
    }

    // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
    // data is handled in the flush() call
    ;
    _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {
      var currentIV = this.currentIV,
        currentResult = this.currentResult,
        remainderData = this.remainderData;
      this.logOnce('JS AES decrypt');
      // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call
      // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached
      // the end on flush(), but by that time we have already received all bytes for the segment.
      // Progressive decryption does not work with WebCrypto

      if (remainderData) {
        data = appendUint8Array(remainderData, data);
        this.remainderData = null;
      }

      // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)
      var currentChunk = this.getValidChunk(data);
      if (!currentChunk.length) {
        return null;
      }
      if (currentIV) {
        iv = currentIV;
      }
      var softwareDecrypter = this.softwareDecrypter;
      if (!softwareDecrypter) {
        softwareDecrypter = this.softwareDecrypter = new AESDecryptor();
      }
      softwareDecrypter.expandKey(key);
      var result = currentResult;
      this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
      this.currentIV = sliceUint8(currentChunk, -16).buffer;
      if (!result) {
        return null;
      }
      return result;
    };
    _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {
      var _this2 = this;
      if (this.key !== key || !this.fastAesKey) {
        if (!this.subtle) {
          return Promise.resolve(this.onWebCryptoError(data, key, iv));
        }
        this.key = key;
        this.fastAesKey = new FastAESKey(this.subtle, key);
      }
      return this.fastAesKey.expandKey().then(function (aesKey) {
        // decrypt using web crypto
        if (!_this2.subtle) {
          return Promise.reject(new Error('web crypto not initialized'));
        }
        _this2.logOnce('WebCrypto AES decrypt');
        var crypto = new AESCrypto(_this2.subtle, new Uint8Array(iv));
        return crypto.decrypt(data.buffer, aesKey);
      }).catch(function (err) {
        logger.warn("[decrypter]: WebCrypto Error, disable WebCrypto API, " + err.name + ": " + err.message);
        return _this2.onWebCryptoError(data, key, iv);
      });
    };
    _proto.onWebCryptoError = function onWebCryptoError(data, key, iv) {
      this.useSoftware = true;
      this.logEnabled = true;
      this.softwareDecrypt(data, key, iv);
      var decryptResult = this.flush();
      if (decryptResult) {
        return decryptResult.buffer;
      }
      throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');
    };
    _proto.getValidChunk = function getValidChunk(data) {
      var currentChunk = data;
      var splitPoint = data.length - data.length % CHUNK_SIZE;
      if (splitPoint !== data.length) {
        currentChunk = sliceUint8(data, 0, splitPoint);
        this.remainderData = sliceUint8(data, splitPoint);
      }
      return currentChunk;
    };
    _proto.logOnce = function logOnce(msg) {
      if (!this.logEnabled) {
        return;
      }
      logger.log("[decrypter]: " + msg);
      this.logEnabled = false;
    };
    return Decrypter;
  }();

  /**
   *  TimeRanges to string helper
   */

  var TimeRanges = {
    toString: function toString(r) {
      var log = '';
      var len = r.length;
      for (var i = 0; i < len; i++) {
        log += "[" + r.start(i).toFixed(3) + "-" + r.end(i).toFixed(3) + "]";
      }
      return log;
    }
  };

  var State = {
    STOPPED: 'STOPPED',
    IDLE: 'IDLE',
    KEY_LOADING: 'KEY_LOADING',
    FRAG_LOADING: 'FRAG_LOADING',
    FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
    WAITING_TRACK: 'WAITING_TRACK',
    PARSING: 'PARSING',
    PARSED: 'PARSED',
    ENDED: 'ENDED',
    ERROR: 'ERROR',
    WAITING_INIT_PTS: 'WAITING_INIT_PTS',
    WAITING_LEVEL: 'WAITING_LEVEL'
  };
  var BaseStreamController = /*#__PURE__*/function (_TaskLoop) {
    _inheritsLoose(BaseStreamController, _TaskLoop);
    function BaseStreamController(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {
      var _this;
      _this = _TaskLoop.call(this) || this;
      _this.hls = void 0;
      _this.fragPrevious = null;
      _this.fragCurrent = null;
      _this.fragmentTracker = void 0;
      _this.transmuxer = null;
      _this._state = State.STOPPED;
      _this.playlistType = void 0;
      _this.media = null;
      _this.mediaBuffer = null;
      _this.config = void 0;
      _this.bitrateTest = false;
      _this.lastCurrentTime = 0;
      _this.nextLoadPosition = 0;
      _this.startPosition = 0;
      _this.startTimeOffset = null;
      _this.loadedmetadata = false;
      _this.retryDate = 0;
      _this.levels = null;
      _this.fragmentLoader = void 0;
      _this.keyLoader = void 0;
      _this.levelLastLoaded = null;
      _this.startFragRequested = false;
      _this.decrypter = void 0;
      _this.initPTS = [];
      _this.buffering = true;
      _this.onvseeking = null;
      _this.onvended = null;
      _this.logPrefix = '';
      _this.log = void 0;
      _this.warn = void 0;
      _this.playlistType = playlistType;
      _this.logPrefix = logPrefix;
      _this.log = logger.log.bind(logger, logPrefix + ":");
      _this.warn = logger.warn.bind(logger, logPrefix + ":");
      _this.hls = hls;
      _this.fragmentLoader = new FragmentLoader(hls.config);
      _this.keyLoader = keyLoader;
      _this.fragmentTracker = fragmentTracker;
      _this.config = hls.config;
      _this.decrypter = new Decrypter(hls.config);
      hls.on(Events.MANIFEST_LOADED, _this.onManifestLoaded, _assertThisInitialized(_this));
      return _this;
    }
    var _proto = BaseStreamController.prototype;
    _proto.doTick = function doTick() {
      this.onTickEnd();
    };
    _proto.onTickEnd = function onTickEnd() {}

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ;
    _proto.startLoad = function startLoad(startPosition) {};
    _proto.stopLoad = function stopLoad() {
      this.fragmentLoader.abort();
      this.keyLoader.abort(this.playlistType);
      var frag = this.fragCurrent;
      if (frag != null && frag.loader) {
        frag.abortRequests();
        this.fragmentTracker.removeFragment(frag);
      }
      this.resetTransmuxer();
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.clearInterval();
      this.clearNextTick();
      this.state = State.STOPPED;
    };
    _proto.pauseBuffering = function pauseBuffering() {
      this.buffering = false;
    };
    _proto.resumeBuffering = function resumeBuffering() {
      this.buffering = true;
    };
    _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {
      // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,
      // of nothing loading/loaded return false
      if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {
        return false;
      }
      var partList = levelDetails.partList;
      // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,
      // check instead if the last part is buffered.
      if (partList != null && partList.length) {
        var lastPart = partList[partList.length - 1];

        // Checking the midpoint of the part for potential margin of error and related issues.
        // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)
        // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream
        // part mismatches for independent audio and video playlists/segments.
        var lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
        return lastPartBuffered;
      }
      var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
      return this.fragmentTracker.isEndListAppended(playlistType);
    };
    _proto.getLevelDetails = function getLevelDetails() {
      if (this.levels && this.levelLastLoaded !== null) {
        var _this$levelLastLoaded;
        return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;
      }
    };
    _proto.onMediaAttached = function onMediaAttached(event, data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
        this.startLoad(config.startPosition);
      }
    };
    _proto.onMediaDetaching = function onMediaDetaching() {
      var media = this.media;
      if (media != null && media.ended) {
        this.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // remove video listeners
      if (media && this.onvseeking && this.onvended) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvended = null;
      }
      if (this.keyLoader) {
        this.keyLoader.detach();
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.fragmentTracker.removeAllFragments();
      this.stopLoad();
    };
    _proto.onMediaSeeking = function onMediaSeeking() {
      var config = this.config,
        fragCurrent = this.fragCurrent,
        media = this.media,
        mediaBuffer = this.mediaBuffer,
        state = this.state;
      var currentTime = media ? media.currentTime : 0;
      var bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
      this.log("media seeking to " + (isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime) + ", state: " + state);
      if (this.state === State.ENDED) {
        this.resetLoadingState();
      } else if (fragCurrent) {
        // Seeking while frag load is in progress
        var tolerance = config.maxFragLookUpTolerance;
        var fragStartOffset = fragCurrent.start - tolerance;
        var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
        // if seeking out of buffered range or into new one
        if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
          var pastFragment = currentTime > fragEndOffset;
          // if the seek position is outside the current fragment range
          if (currentTime < fragStartOffset || pastFragment) {
            if (pastFragment && fragCurrent.loader) {
              this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.abortRequests();
              this.resetLoadingState();
            }
            this.fragPrevious = null;
          }
        }
      }
      if (media) {
        // Remove gap fragments
        this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);
        this.lastCurrentTime = currentTime;
      }

      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata && !bufferInfo.len) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }

      // Async tick to speed up processing
      this.tickImmediate();
    };
    _proto.onMediaEnded = function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    };
    _proto.onManifestLoaded = function onManifestLoaded(event, data) {
      this.startTimeOffset = data.startTimeOffset;
      this.initPTS = [];
    };
    _proto.onHandlerDestroying = function onHandlerDestroying() {
      this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      this.stopLoad();
      _TaskLoop.prototype.onHandlerDestroying.call(this);
      // @ts-ignore
      this.hls = null;
    };
    _proto.onHandlerDestroyed = function onHandlerDestroyed() {
      this.state = State.STOPPED;
      if (this.fragmentLoader) {
        this.fragmentLoader.destroy();
      }
      if (this.keyLoader) {
        this.keyLoader.destroy();
      }
      if (this.decrypter) {
        this.decrypter.destroy();
      }
      this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
      _TaskLoop.prototype.onHandlerDestroyed.call(this);
    };
    _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {
      this._loadFragForPlayback(frag, level, targetBufferTime);
    };
    _proto._loadFragForPlayback = function _loadFragForPlayback(frag, level, targetBufferTime) {
      var _this2 = this;
      var progressCallback = function progressCallback(data) {
        if (_this2.fragContextChanged(frag)) {
          _this2.warn("Fragment " + frag.sn + (data.part ? ' p: ' + data.part.index : '') + " of level " + frag.level + " was dropped during download.");
          _this2.fragmentTracker.removeFragment(frag);
          return;
        }
        frag.stats.chunkCount++;
        _this2._handleFragmentLoadProgress(data);
      };
      this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(function (data) {
        if (!data) {
          // if we're here we probably needed to backtrack or are waiting for more parts
          return;
        }
        var state = _this2.state;
        if (_this2.fragContextChanged(frag)) {
          if (state === State.FRAG_LOADING || !_this2.fragCurrent && state === State.PARSING) {
            _this2.fragmentTracker.removeFragment(frag);
            _this2.state = State.IDLE;
          }
          return;
        }
        if ('payload' in data) {
          _this2.log("Loaded fragment " + frag.sn + " of level " + frag.level);
          _this2.hls.trigger(Events.FRAG_LOADED, data);
        }

        // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback
        _this2._handleFragmentLoadComplete(data);
      }).catch(function (reason) {
        if (_this2.state === State.STOPPED || _this2.state === State.ERROR) {
          return;
        }
        _this2.warn("Frag error: " + ((reason == null ? void 0 : reason.message) || reason));
        _this2.resetFragmentLoading(frag);
      });
    };
    _proto.clearTrackerIfNeeded = function clearTrackerIfNeeded(frag) {
      var _this$mediaBuffer;
      var fragmentTracker = this.fragmentTracker;
      var fragState = fragmentTracker.getState(frag);
      if (fragState === FragmentState.APPENDING) {
        // Lower the max buffer length and try again
        var playlistType = frag.type;
        var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
        var minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);
        // If backtracking, always remove from the tracker without reducing max buffer length
        var backtrackFragment = this.backtrackFragment;
        var backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;
        if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {
          fragmentTracker.removeFragment(frag);
        }
      } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {
        // Stop gap for bad tracker / buffer flush behavior
        fragmentTracker.removeAllFragments();
      } else if (fragmentTracker.hasParts(frag.type)) {
        // In low latency mode, remove fragments for which only some parts were buffered
        fragmentTracker.detectPartialFragments({
          frag: frag,
          part: null,
          stats: frag.stats,
          id: frag.type
        });
        if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {
          fragmentTracker.removeFragment(frag);
        }
      }
    };
    _proto.checkLiveUpdate = function checkLiveUpdate(details) {
      if (details.updated && !details.live) {
        // Live stream ended, update fragment tracker
        var lastFragment = details.fragments[details.fragments.length - 1];
        this.fragmentTracker.detectPartialFragments({
          frag: lastFragment,
          part: null,
          stats: lastFragment.stats,
          id: lastFragment.type
        });
      }
      if (!details.fragments[0]) {
        details.deltaUpdateFailed = true;
      }
    };
    _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {
      if (type === void 0) {
        type = null;
      }
      if (!(startOffset - endOffset)) {
        return;
      }
      // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,
      // passing a null type flushes both buffers
      var flushScope = {
        startOffset: startOffset,
        endOffset: endOffset,
        type: type
      };
      this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);
    };
    _proto._loadInitSegment = function _loadInitSegment(frag, level) {
      var _this3 = this;
      this._doFragLoad(frag, level).then(function (data) {
        if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {
          throw new Error('init load aborted');
        }
        return data;
      }).then(function (data) {
        var hls = _this3.hls;
        var payload = data.payload;
        var decryptData = frag.decryptdata;

        // check to see if the payload needs to be decrypted
        if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {
          var startTime = self.performance.now();
          // decrypt init segment data
          return _this3.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(function (err) {
            hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.FRAG_DECRYPT_ERROR,
              fatal: false,
              error: err,
              reason: err.message,
              frag: frag
            });
            throw err;
          }).then(function (decryptedData) {
            var endTime = self.performance.now();
            hls.trigger(Events.FRAG_DECRYPTED, {
              frag: frag,
              payload: decryptedData,
              stats: {
                tstart: startTime,
                tdecrypt: endTime
              }
            });
            data.payload = decryptedData;
            return _this3.completeInitSegmentLoad(data);
          });
        }
        return _this3.completeInitSegmentLoad(data);
      }).catch(function (reason) {
        if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {
          return;
        }
        _this3.warn(reason);
        _this3.resetFragmentLoading(frag);
      });
    };
    _proto.completeInitSegmentLoad = function completeInitSegmentLoad(data) {
      var levels = this.levels;
      if (!levels) {
        throw new Error('init load aborted, missing levels');
      }
      var stats = data.frag.stats;
      this.state = State.IDLE;
      data.frag.data = new Uint8Array(data.payload);
      stats.parsing.start = stats.buffering.start = self.performance.now();
      stats.parsing.end = stats.buffering.end = self.performance.now();
      this.tick();
    };
    _proto.fragContextChanged = function fragContextChanged(frag) {
      var fragCurrent = this.fragCurrent;
      return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;
    };
    _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {
      var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;
      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
      this.log("Buffered " + frag.type + " sn: " + frag.sn + (part ? ' part: ' + part.index : '') + " of " + (this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track') + " " + frag.level + " (frag:[" + ((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3) + "-" + ((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3) + "] > buffer:" + (media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)') + ")");
      if (frag.sn !== 'initSegment') {
        var _this$levels;
        if (frag.type !== PlaylistLevelType.SUBTITLE) {
          var el = frag.elementaryStreams;
          if (!Object.keys(el).some(function (type) {
            return !!el[type];
          })) {
            // empty segment
            this.state = State.IDLE;
            return;
          }
        }
        var level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];
        if (level != null && level.fragmentError) {
          this.log("Resetting level fragment error count of " + level.fragmentError + " on frag buffered");
          level.fragmentError = 0;
        }
      }
      this.state = State.IDLE;
      if (!media) {
        return;
      }
      if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {
        this.loadedmetadata = true;
        this.seekToStartPos();
      }
      this.tick();
    };
    _proto.seekToStartPos = function seekToStartPos() {};
    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {
      var transmuxer = this.transmuxer;
      if (!transmuxer) {
        return;
      }
      var frag = fragLoadedEndData.frag,
        part = fragLoadedEndData.part,
        partsLoaded = fragLoadedEndData.partsLoaded;
      // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data
      var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function (fragLoaded) {
        return !fragLoaded;
      });
      var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
      transmuxer.flush(chunkMeta);
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ;
    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};
    _proto._doFragLoad = function _doFragLoad(frag, level, targetBufferTime, progressCallback) {
      var _frag$decryptdata,
        _this4 = this;
      if (targetBufferTime === void 0) {
        targetBufferTime = null;
      }
      var details = level == null ? void 0 : level.details;
      if (!this.levels || !details) {
        throw new Error("frag load aborted, missing level" + (details ? '' : ' detail') + "s");
      }
      var keyLoadingPromise = null;
      if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {
        this.log("Loading key for " + frag.sn + " of [" + details.startSN + "-" + details.endSN + "], " + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + " " + frag.level);
        this.state = State.KEY_LOADING;
        this.fragCurrent = frag;
        keyLoadingPromise = this.keyLoader.load(frag).then(function (keyLoadedData) {
          if (!_this4.fragContextChanged(keyLoadedData.frag)) {
            _this4.hls.trigger(Events.KEY_LOADED, keyLoadedData);
            if (_this4.state === State.KEY_LOADING) {
              _this4.state = State.IDLE;
            }
            return keyLoadedData;
          }
        });
        this.hls.trigger(Events.KEY_LOADING, {
          frag: frag
        });
        if (this.fragCurrent === null) {
          keyLoadingPromise = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING"));
        }
      } else if (!frag.encrypted && details.encryptedFragments.length) {
        this.keyLoader.loadClear(frag, details.encryptedFragments);
      }
      targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
      if (this.config.lowLatencyMode && frag.sn !== 'initSegment') {
        var partList = details.partList;
        if (partList && progressCallback) {
          if (targetBufferTime > frag.end && details.fragmentHint) {
            frag = details.fragmentHint;
          }
          var partIndex = this.getNextPart(partList, frag, targetBufferTime);
          if (partIndex > -1) {
            var part = partList[partIndex];
            this.log("Loading part sn: " + frag.sn + " p: " + part.index + " cc: " + frag.cc + " of playlist [" + details.startSN + "-" + details.endSN + "] parts [0-" + partIndex + "-" + (partList.length - 1) + "] " + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
            this.nextLoadPosition = part.start + part.duration;
            this.state = State.FRAG_LOADING;
            var _result;
            if (keyLoadingPromise) {
              _result = keyLoadingPromise.then(function (keyLoadedData) {
                if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData.frag)) {
                  return null;
                }
                return _this4.doFragPartsLoad(frag, part, level, progressCallback);
              }).catch(function (error) {
                return _this4.handleFragLoadError(error);
              });
            } else {
              _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(function (error) {
                return _this4.handleFragLoadError(error);
              });
            }
            this.hls.trigger(Events.FRAG_LOADING, {
              frag: frag,
              part: part,
              targetBufferTime: targetBufferTime
            });
            if (this.fragCurrent === null) {
              return Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts"));
            }
            return _result;
          } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
            // Fragment hint has no parts
            return Promise.resolve(null);
          }
        }
      }
      this.log("Loading fragment " + frag.sn + " cc: " + frag.cc + " " + (details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : '') + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
      // Don't update nextLoadPosition for fragments which are not buffered
      if (isFiniteNumber(frag.sn) && !this.bitrateTest) {
        this.nextLoadPosition = frag.start + frag.duration;
      }
      this.state = State.FRAG_LOADING;

      // Load key before streaming fragment data
      var dataOnProgress = this.config.progressive;
      var result;
      if (dataOnProgress && keyLoadingPromise) {
        result = keyLoadingPromise.then(function (keyLoadedData) {
          if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {
            return null;
          }
          return _this4.fragmentLoader.load(frag, progressCallback);
        }).catch(function (error) {
          return _this4.handleFragLoadError(error);
        });
      } else {
        // load unencrypted fragment data with progress event,
        // or handle fragment result after key and fragment are finished loading
        result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(function (_ref) {
          var fragLoadedData = _ref[0];
          if (!dataOnProgress && fragLoadedData && progressCallback) {
            progressCallback(fragLoadedData);
          }
          return fragLoadedData;
        }).catch(function (error) {
          return _this4.handleFragLoadError(error);
        });
      }
      this.hls.trigger(Events.FRAG_LOADING, {
        frag: frag,
        targetBufferTime: targetBufferTime
      });
      if (this.fragCurrent === null) {
        return Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING"));
      }
      return result;
    };
    _proto.doFragPartsLoad = function doFragPartsLoad(frag, fromPart, level, progressCallback) {
      var _this5 = this;
      return new Promise(function (resolve, reject) {
        var _level$details;
        var partsLoaded = [];
        var initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;
        var loadPart = function loadPart(part) {
          _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function (partLoadedData) {
            partsLoaded[part.index] = partLoadedData;
            var loadedPart = partLoadedData.part;
            _this5.hls.trigger(Events.FRAG_LOADED, partLoadedData);
            var nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);
            if (nextPart) {
              loadPart(nextPart);
            } else {
              return resolve({
                frag: frag,
                part: loadedPart,
                partsLoaded: partsLoaded
              });
            }
          }).catch(reject);
        };
        loadPart(fromPart);
      });
    };
    _proto.handleFragLoadError = function handleFragLoadError(error) {
      if ('data' in error) {
        var data = error.data;
        if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {
          this.handleFragLoadAborted(data.frag, data.part);
        } else {
          this.hls.trigger(Events.ERROR, data);
        }
      } else {
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.INTERNAL_EXCEPTION,
          err: error,
          error: error,
          fatal: true
        });
      }
      return null;
    };
    _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {
      var context = this.getCurrentContext(chunkMeta);
      if (!context || this.state !== State.PARSING) {
        if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
          this.state = State.IDLE;
        }
        return;
      }
      var frag = context.frag,
        part = context.part,
        level = context.level;
      var now = self.performance.now();
      frag.stats.parsing.end = now;
      if (part) {
        part.stats.parsing.end = now;
      }
      this.updateLevelTiming(frag, part, level, chunkMeta.partial);
    };
    _proto.getCurrentContext = function getCurrentContext(chunkMeta) {
      var levels = this.levels,
        fragCurrent = this.fragCurrent;
      var levelIndex = chunkMeta.level,
        sn = chunkMeta.sn,
        partIndex = chunkMeta.part;
      if (!(levels != null && levels[levelIndex])) {
        this.warn("Levels object was unset while buffering fragment " + sn + " of level " + levelIndex + ". The current chunk will not be buffered.");
        return null;
      }
      var level = levels[levelIndex];
      var part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;
      var frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);
      if (!frag) {
        return null;
      }
      if (fragCurrent && fragCurrent !== frag) {
        frag.stats = fragCurrent.stats;
      }
      return {
        frag: frag,
        part: part,
        level: level
      };
    };
    _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {
      var _buffer;
      if (!data || this.state !== State.PARSING) {
        return;
      }
      var data1 = data.data1,
        data2 = data.data2;
      var buffer = data1;
      if (data1 && data2) {
        // Combine the moof + mdat so that we buffer with a single append
        buffer = appendUint8Array(data1, data2);
      }
      if (!((_buffer = buffer) != null && _buffer.length)) {
        return;
      }
      var segment = {
        type: data.type,
        frag: frag,
        part: part,
        chunkMeta: chunkMeta,
        parent: frag.type,
        data: buffer
      };
      this.hls.trigger(Events.BUFFER_APPENDING, segment);
      if (data.dropped && data.independent && !part) {
        if (noBacktracking) {
          return;
        }
        // Clear buffer so that we reload previous segments sequentially if required
        this.flushBufferGap(frag);
      }
    };
    _proto.flushBufferGap = function flushBufferGap(frag) {
      var media = this.media;
      if (!media) {
        return;
      }
      // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed
      if (!BufferHelper.isBuffered(media, media.currentTime)) {
        this.flushMainBuffer(0, frag.start);
        return;
      }
      // Remove back-buffer without interrupting playback to allow back tracking
      var currentTime = media.currentTime;
      var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      var fragDuration = frag.duration;
      var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
      var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
      if (frag.start - start > segmentFraction) {
        this.flushMainBuffer(start, frag.start);
      }
    };
    _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {
      var pos = this.getLoadPosition();
      if (!isFiniteNumber(pos)) {
        return null;
      }
      return this.getFwdBufferInfoAtPos(bufferable, pos, type);
    };
    _proto.getFwdBufferInfoAtPos = function getFwdBufferInfoAtPos(bufferable, pos, type) {
      var maxBufferHole = this.config.maxBufferHole;
      var bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);
      // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos
      if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {
        var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
        if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {
          return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));
        }
      }
      return bufferInfo;
    };
    _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {
      var config = this.config;
      var maxBufLen;
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }
      return Math.min(maxBufLen, config.maxMaxBufferLength);
    };
    _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold, fragDuration) {
      var config = this.config;
      var minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);
      var reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);
      if (reducedLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength = reducedLength;
        this.warn("Reduce max buffer length to " + reducedLength + "s");
        return true;
      }
      return false;
    };
    _proto.getAppendedFrag = function getAppendedFrag(position, playlistType) {
      var fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);
      if (fragOrPart && 'fragment' in fragOrPart) {
        return fragOrPart.fragment;
      }
      return fragOrPart;
    };
    _proto.getNextFragment = fun