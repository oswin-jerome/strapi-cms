'use strict';

var fp = require('lodash/fp');
var utils = require('@strapi/utils');
var index = require('../utils/index.js');
var constants = require('../constants.js');
var findEntityAndCheckPermissions = require('./utils/find-entity-and-check-permissions.js');

var adminFile = {
    async find (ctx) {
        const { state: { userAbility } } = ctx;
        const defaultQuery = {
            populate: {
                folder: true
            }
        };
        const pm = strapi.service('admin::permission').createPermissionsManager({
            ability: userAbility,
            action: constants.ACTIONS.read,
            model: constants.FILE_MODEL_UID
        });
        if (!pm.isAllowed) {
            return ctx.forbidden();
        }
        // validate the incoming user query params
        await pm.validateQuery(ctx.query);
        const query = await utils.async.pipe(// Start by sanitizing the incoming query
        (q)=>pm.sanitizeQuery(q), // Add the default query which should not be validated or sanitized
        (q)=>fp.merge(defaultQuery, q), // Add the dynamic filters based on permissions' conditions
        (q)=>pm.addPermissionsQueryTo(q))(ctx.query);
        const { results: files, pagination } = await index.getService('upload').findPage(query);
        // Sign file urls for private providers
        const signedFiles = await utils.async.map(files, index.getService('file').signFileUrls);
        const sanitizedFiles = await pm.sanitizeOutput(signedFiles);
        return {
            results: sanitizedFiles,
            pagination
        };
    },
    async findOne (ctx) {
        const { state: { userAbility }, params: { id } } = ctx;
        const { pm, file } = await findEntityAndCheckPermissions.findEntityAndCheckPermissions(userAbility, constants.ACTIONS.read, constants.FILE_MODEL_UID, id);
        const signedFile = await index.getService('file').signFileUrls(file);
        ctx.body = await pm.sanitizeOutput(signedFile);
    },
    async destroy (ctx) {
        const { id } = ctx.params;
        const { userAbility } = ctx.state;
        const { pm, file } = await findEntityAndCheckPermissions.findEntityAndCheckPermissions(userAbility, constants.ACTIONS.update, constants.FILE_MODEL_UID, id);
        const [body] = await Promise.all([
            pm.sanitizeOutput(file, {
                action: constants.ACTIONS.read
            }),
            index.getService('upload').remove(file)
        ]);
        ctx.body = body;
    },
    async getAIMetadataCount (ctx) {
        const { userAbility } = ctx.state;
        const pm = strapi.service('admin::permission').createPermissionsManager({
            ability: userAbility,
            action: constants.ACTIONS.read,
            model: constants.FILE_MODEL_UID
        });
        if (!pm.isAllowed) {
            return ctx.forbidden();
        }
        const aiMetadataService = index.getService('aiMetadata');
        // Check if AI service is enabled
        if (!await aiMetadataService.isEnabled()) {
            return ctx.badRequest('AI Metadata service is not enabled');
        }
        try {
            const { imagesWithoutMetadataCount, totalImages } = await aiMetadataService.countImagesWithoutMetadata();
            ctx.body = {
                imagesWithoutMetadataCount,
                totalImages
            };
        } catch (error) {
            const message = error instanceof Error ? error.message : 'Failed to get AI metadata count';
            strapi.log.error('Failed to get AI metadata count', {
                message,
                error
            });
            ctx.badRequest(message);
        }
    },
    async generateAIMetadata (ctx) {
        const { userAbility } = ctx.state;
        const pm = strapi.service('admin::permission').createPermissionsManager({
            ability: userAbility,
            action: constants.ACTIONS.update,
            model: constants.FILE_MODEL_UID
        });
        if (!pm.isAllowed) {
            return ctx.forbidden();
        }
        const aiMetadataService = index.getService('aiMetadata');
        // Check if AI service is enabled
        if (!await aiMetadataService.isEnabled()) {
            return ctx.badRequest('AI Metadata service is not enabled');
        }
        try {
            // Get count first to check if there are images to process
            const result = await aiMetadataService.countImagesWithoutMetadata();
            if (result.imagesWithoutMetadataCount === 0) {
                ctx.body = {
                    count: 0,
                    message: 'No images without metadata found'
                };
                return;
            }
            // Create job
            const jobService = index.getService('aiMetadataJobs');
            const jobId = await jobService.createJob();
            // Start async processing (fire and forget)
            aiMetadataService.processExistingFiles(jobId, ctx.state.user).catch((err)=>{
                strapi.log.error('AI metadata job failed:', err);
            });
            // Return immediately with job ID
            ctx.body = {
                jobId,
                status: 'pending'
            };
        } catch (error) {
            const message = error instanceof Error ? error.message : 'Failed to generate AI metadata';
            const cause = error instanceof Error && error.cause ? String(error.cause) : undefined;
            strapi.log.error('AI metadata generation failed in controller', {
                message,
                cause,
                error
            });
            ctx.badRequest(cause ? `${message}: ${cause}` : message);
        }
    },
    async getLatestAIMetadataJob (ctx) {
        const jobService = index.getService('aiMetadataJobs');
        const job = await jobService.getLatestActiveJob();
        if (!job) {
            return ctx.notFound('No active job found');
        }
        ctx.body = job;
    }
};

module.exports = adminFile;
//# sourceMappingURL=admin-file.js.map
