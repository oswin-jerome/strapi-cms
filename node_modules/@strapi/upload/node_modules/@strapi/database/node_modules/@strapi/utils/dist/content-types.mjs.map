{"version":3,"file":"content-types.mjs","sources":["../src/content-types.ts"],"sourcesContent":["import _ from 'lodash';\nimport { has, getOr, union } from 'lodash/fp';\nimport type {\n  Model,\n  Kind,\n  Attribute,\n  RelationalAttribute,\n  ComponentAttribute,\n  DynamicZoneAttribute,\n  WithRequired,\n} from './types';\n\nconst SINGLE_TYPE = 'singleType';\nconst COLLECTION_TYPE = 'collectionType';\n\nconst ID_ATTRIBUTE = 'id';\nconst DOC_ID_ATTRIBUTE = 'documentId';\n\nconst PUBLISHED_AT_ATTRIBUTE = 'publishedAt';\nconst FIRST_PUBLISHED_AT_ATTRIBUTE = 'firstPublishedAt';\nconst CREATED_BY_ATTRIBUTE = 'createdBy';\nconst UPDATED_BY_ATTRIBUTE = 'updatedBy';\n\nconst CREATED_AT_ATTRIBUTE = 'createdAt';\nconst UPDATED_AT_ATTRIBUTE = 'updatedAt';\n\nconst constants = {\n  ID_ATTRIBUTE,\n  DOC_ID_ATTRIBUTE,\n  PUBLISHED_AT_ATTRIBUTE,\n  FIRST_PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n  CREATED_AT_ATTRIBUTE,\n  UPDATED_AT_ATTRIBUTE,\n  SINGLE_TYPE,\n  COLLECTION_TYPE,\n};\n\nconst getTimestamps = (model: Model) => {\n  const attributes: string[] = [];\n\n  if (has(CREATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_AT_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_AT_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getCreatorFields = (model: Model) => {\n  const attributes: string[] = [];\n\n  if (has(CREATED_BY_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_BY_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_BY_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_BY_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getNonWritableAttributes = (model: Model) => {\n  if (!model) return [];\n\n  const nonWritableAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.writable === false ? acc.concat(attrName) : acc),\n    [] as string[]\n  );\n\n  return _.uniq([\n    ID_ATTRIBUTE,\n    DOC_ID_ATTRIBUTE,\n    ...getTimestamps(model),\n    ...nonWritableAttributes,\n  ]);\n};\n\nconst getWritableAttributes = (model: Model) => {\n  if (!model) return [];\n\n  return _.difference(Object.keys(model.attributes), getNonWritableAttributes(model));\n};\n\nconst isWritableAttribute = (model: Model, attributeName: string) => {\n  return getWritableAttributes(model).includes(attributeName);\n};\n\nconst getNonVisibleAttributes = (model: Model) => {\n  const nonVisibleAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.visible === false ? acc.concat(attrName) : acc),\n    [] as string[]\n  );\n\n  return _.uniq([\n    ID_ATTRIBUTE,\n    DOC_ID_ATTRIBUTE,\n    PUBLISHED_AT_ATTRIBUTE,\n    ...getTimestamps(model),\n    ...nonVisibleAttributes,\n  ]);\n};\n\nconst getVisibleAttributes = (model: Model) => {\n  return _.difference(_.keys(model.attributes), getNonVisibleAttributes(model));\n};\n\nconst isVisibleAttribute = (model: Model, attributeName: string) => {\n  return getVisibleAttributes(model).includes(attributeName);\n};\n\nconst getOptions = (model: Model) =>\n  _.assign({ draftAndPublish: false }, _.get(model, 'options', {}));\n\nconst hasDraftAndPublish = (model: Model) =>\n  _.get(model, 'options.draftAndPublish', false) === true;\n\nconst hasFirstPublishedAtField = (model: Model) =>\n  strapi.config.get('features.future.experimental_firstPublishedAt', false) &&\n  hasDraftAndPublish(model);\n\nconst isDraft = <T extends object>(data: T, model: Model) =>\n  hasDraftAndPublish(model) && _.get(data, PUBLISHED_AT_ATTRIBUTE) === null;\n\nconst isSchema = (data: unknown): data is Model => {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'modelType' in data &&\n    typeof data.modelType === 'string' &&\n    ['component', 'contentType'].includes(data.modelType)\n  );\n};\n\nconst isComponentSchema = (data: unknown): data is Model & { modelType: 'component' } => {\n  return isSchema(data) && data.modelType === 'component';\n};\n\nconst isContentTypeSchema = (data: unknown): data is Model & { modelType: 'contentType' } => {\n  return isSchema(data) && data.modelType === 'contentType';\n};\n\nconst isSingleType = ({ kind = COLLECTION_TYPE }) => kind === SINGLE_TYPE;\nconst isCollectionType = ({ kind = COLLECTION_TYPE }) => kind === COLLECTION_TYPE;\nconst isKind = (kind: Kind) => (model: Model) => model.kind === kind;\n\nconst getStoredPrivateAttributes = (model: Model) =>\n  union(\n    (strapi?.config?.get('api.responses.privateAttributes', []) ?? []) as Array<string>,\n    getOr([], 'options.privateAttributes', model)\n  );\n\nconst getPrivateAttributes = (model: Model) => {\n  return _.union(\n    getStoredPrivateAttributes(model),\n    _.keys(_.pickBy(model.attributes, (attr) => !!attr.private))\n  );\n};\n\nconst isPrivateAttribute = (model: Model, attributeName: string) => {\n  if (model?.attributes?.[attributeName]?.private === true) {\n    return true;\n  }\n  return getStoredPrivateAttributes(model).includes(attributeName);\n};\n\nconst isScalarAttribute = (attribute?: Attribute) => {\n  return attribute && !['media', 'component', 'relation', 'dynamiczone'].includes(attribute.type);\n};\n\nconst getDoesAttributeRequireValidation = (attribute: Attribute) => {\n  return (\n    attribute.required ||\n    attribute.unique ||\n    Object.prototype.hasOwnProperty.call(attribute, 'max') ||\n    Object.prototype.hasOwnProperty.call(attribute, 'min') ||\n    Object.prototype.hasOwnProperty.call(attribute, 'maxLength') ||\n    Object.prototype.hasOwnProperty.call(attribute, 'minLength')\n  );\n};\nconst isMediaAttribute = (attribute?: Attribute) => attribute?.type === 'media';\nconst isRelationalAttribute = (attribute?: Attribute): attribute is RelationalAttribute =>\n  attribute?.type === 'relation';\n\nconst HAS_RELATION_REORDERING = ['manyToMany', 'manyToOne', 'oneToMany'];\nconst hasRelationReordering = (attribute?: Attribute) =>\n  isRelationalAttribute(attribute) && HAS_RELATION_REORDERING.includes(attribute.relation);\n\nconst isComponentAttribute = (\n  attribute: Attribute\n): attribute is ComponentAttribute | DynamicZoneAttribute =>\n  ['component', 'dynamiczone'].includes(attribute?.type);\n\nconst isDynamicZoneAttribute = (attribute?: Attribute): attribute is DynamicZoneAttribute =>\n  !!attribute && attribute.type === 'dynamiczone';\nconst isMorphToRelationalAttribute = (attribute?: Attribute) => {\n  return (\n    !!attribute && isRelationalAttribute(attribute) && attribute.relation?.startsWith?.('morphTo')\n  );\n};\n\nconst getComponentAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isComponentAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\nconst getMediaAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isMediaAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\nconst getScalarAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isScalarAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\nconst getRelationalAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isRelationalAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\n/**\n * Checks if an attribute is of type `type`\n * @param {object} attribute\n * @param {string} type\n */\nconst isTypedAttribute = (attribute: Attribute, type: string) => {\n  return _.has(attribute, 'type') && attribute.type === type;\n};\n\n/**\n *  Returns a route prefix for a contentType\n * @param {object} contentType\n * @returns {string}\n */\nconst getContentTypeRoutePrefix = (contentType: WithRequired<Model, 'info'>) => {\n  return isSingleType(contentType)\n    ? _.kebabCase(contentType.info.singularName)\n    : _.kebabCase(contentType.info.pluralName);\n};\n\nexport {\n  isSchema,\n  isContentTypeSchema,\n  isComponentSchema,\n  isScalarAttribute,\n  isMediaAttribute,\n  isRelationalAttribute,\n  hasRelationReordering,\n  isComponentAttribute,\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n  isTypedAttribute,\n  getPrivateAttributes,\n  isPrivateAttribute,\n  constants,\n  getNonWritableAttributes,\n  getComponentAttributes,\n  getMediaAttributes,\n  getScalarAttributes,\n  getRelationalAttributes,\n  getWritableAttributes,\n  isWritableAttribute,\n  getNonVisibleAttributes,\n  getVisibleAttributes,\n  getTimestamps,\n  getCreatorFields,\n  isVisibleAttribute,\n  getOptions,\n  isDraft,\n  hasDraftAndPublish,\n  hasFirstPublishedAtField,\n  isSingleType,\n  isCollectionType,\n  isKind,\n  getContentTypeRoutePrefix,\n  getDoesAttributeRequireValidation,\n};\n"],"names":["SINGLE_TYPE","COLLECTION_TYPE","ID_ATTRIBUTE","DOC_ID_ATTRIBUTE","PUBLISHED_AT_ATTRIBUTE","FIRST_PUBLISHED_AT_ATTRIBUTE","CREATED_BY_ATTRIBUTE","UPDATED_BY_ATTRIBUTE","CREATED_AT_ATTRIBUTE","UPDATED_AT_ATTRIBUTE","constants","getTimestamps","model","attributes","has","push","getCreatorFields","getNonWritableAttributes","nonWritableAttributes","_","reduce","acc","attr","attrName","writable","concat","uniq","getWritableAttributes","difference","Object","keys","isWritableAttribute","attributeName","includes","getNonVisibleAttributes","nonVisibleAttributes","visible","getVisibleAttributes","isVisibleAttribute","getOptions","assign","draftAndPublish","get","hasDraftAndPublish","hasFirstPublishedAtField","strapi","config","isDraft","data","isSchema","modelType","isComponentSchema","isContentTypeSchema","isSingleType","kind","isCollectionType","isKind","getStoredPrivateAttributes","union","getOr","getPrivateAttributes","pickBy","private","isPrivateAttribute","isScalarAttribute","attribute","type","getDoesAttributeRequireValidation","required","unique","prototype","hasOwnProperty","call","isMediaAttribute","isRelationalAttribute","HAS_RELATION_REORDERING","hasRelationReordering","relation","isComponentAttribute","isDynamicZoneAttribute","isMorphToRelationalAttribute","startsWith","getComponentAttributes","schema","getMediaAttributes","getScalarAttributes","getRelationalAttributes","isTypedAttribute","getContentTypeRoutePrefix","contentType","kebabCase","info","singularName","pluralName"],"mappings":";;;AAYA,MAAMA,WAAc,GAAA,YAAA;AACpB,MAAMC,eAAkB,GAAA,gBAAA;AAExB,MAAMC,YAAe,GAAA,IAAA;AACrB,MAAMC,gBAAmB,GAAA,YAAA;AAEzB,MAAMC,sBAAyB,GAAA,aAAA;AAC/B,MAAMC,4BAA+B,GAAA,kBAAA;AACrC,MAAMC,oBAAuB,GAAA,WAAA;AAC7B,MAAMC,oBAAuB,GAAA,WAAA;AAE7B,MAAMC,oBAAuB,GAAA,WAAA;AAC7B,MAAMC,oBAAuB,GAAA,WAAA;AAE7B,MAAMC,SAAY,GAAA;AAChBR,IAAAA,YAAAA;AACAC,IAAAA,gBAAAA;AACAC,IAAAA,sBAAAA;AACAC,IAAAA,4BAAAA;AACAC,IAAAA,oBAAAA;AACAC,IAAAA,oBAAAA;AACAC,IAAAA,oBAAAA;AACAC,IAAAA,oBAAAA;AACAT,IAAAA,WAAAA;AACAC,IAAAA;AACF;AAEA,MAAMU,gBAAgB,CAACC,KAAAA,GAAAA;AACrB,IAAA,MAAMC,aAAuB,EAAE;AAE/B,IAAA,IAAIC,GAAIN,CAAAA,oBAAAA,EAAsBI,KAAMC,CAAAA,UAAU,CAAG,EAAA;AAC/CA,QAAAA,UAAAA,CAAWE,IAAI,CAACP,oBAAAA,CAAAA;AAClB;AAEA,IAAA,IAAIM,GAAIL,CAAAA,oBAAAA,EAAsBG,KAAMC,CAAAA,UAAU,CAAG,EAAA;AAC/CA,QAAAA,UAAAA,CAAWE,IAAI,CAACN,oBAAAA,CAAAA;AAClB;IAEA,OAAOI,UAAAA;AACT;AAEA,MAAMG,mBAAmB,CAACJ,KAAAA,GAAAA;AACxB,IAAA,MAAMC,aAAuB,EAAE;AAE/B,IAAA,IAAIC,GAAIR,CAAAA,oBAAAA,EAAsBM,KAAMC,CAAAA,UAAU,CAAG,EAAA;AAC/CA,QAAAA,UAAAA,CAAWE,IAAI,CAACT,oBAAAA,CAAAA;AAClB;AAEA,IAAA,IAAIQ,GAAIP,CAAAA,oBAAAA,EAAsBK,KAAMC,CAAAA,UAAU,CAAG,EAAA;AAC/CA,QAAAA,UAAAA,CAAWE,IAAI,CAACR,oBAAAA,CAAAA;AAClB;IAEA,OAAOM,UAAAA;AACT;AAEA,MAAMI,2BAA2B,CAACL,KAAAA,GAAAA;IAChC,IAAI,CAACA,KAAO,EAAA,OAAO,EAAE;IAErB,MAAMM,qBAAAA,GAAwBC,WAAEC,MAAM,CACpCR,MAAMC,UAAU,EAChB,CAACQ,GAAKC,EAAAA,IAAAA,EAAMC,WAAcD,IAAKE,CAAAA,QAAQ,KAAK,KAAQH,GAAAA,GAAAA,CAAII,MAAM,CAACF,QAAAA,CAAAA,GAAYF,KAC3E,EAAE,CAAA;IAGJ,OAAOF,UAAAA,CAAEO,IAAI,CAAC;AACZxB,QAAAA,YAAAA;AACAC,QAAAA,gBAAAA;WACGQ,aAAcC,CAAAA,KAAAA,CAAAA;AACdM,QAAAA,GAAAA;AACJ,KAAA,CAAA;AACH;AAEA,MAAMS,wBAAwB,CAACf,KAAAA,GAAAA;IAC7B,IAAI,CAACA,KAAO,EAAA,OAAO,EAAE;IAErB,OAAOO,UAAAA,CAAES,UAAU,CAACC,MAAAA,CAAOC,IAAI,CAAClB,KAAAA,CAAMC,UAAU,CAAA,EAAGI,wBAAyBL,CAAAA,KAAAA,CAAAA,CAAAA;AAC9E;AAEMmB,MAAAA,mBAAAA,GAAsB,CAACnB,KAAcoB,EAAAA,aAAAA,GAAAA;IACzC,O