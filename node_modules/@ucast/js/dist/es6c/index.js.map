{"version":3,"file":"index.js","sources":["../../src/utils.ts","../../src/interpreter.ts","../../src/interpreters.ts","../../src/defaults.ts"],"sourcesContent":["import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return i < length - 1 ? undefined : value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n\nexport const hasOwn = Object.hasOwn ||\n  Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n","import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n","import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n  hasOwn,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => {\n    if (value == null) return Boolean(value) === node.value;\n    return hasOwn(value, field) === node.value;\n  };\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n","import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n"],"names":["includes","items","value","compare","i","length","isArrayAndNotNumericField","object","field","Array","isArray","Number","isNaN","getField","get","result","concat","testValueOrArray","test","node","context","some","v","hasOwn","Object","prototype","hasOwnProperty","call","bind","defaultGet","getObjectFieldCursor","path","dotIndex","lastIndexOf","slice","getObjectField","ITSELF","Error","String","indexOf","paths","split","undefined","getValueByPath","a","b","createJsInterpreter","operators","options","createInterpreter","or","interpret","condition","nor","and","every","not","eq","ne","lte","lt","gt","gte","exists","item","Boolean","mod","size","regex","within","nin","all","elemMatch","where","allInterpreters","interpreters","in"],"mappings":"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"}