{"version":3,"file":"index.js","sources":["../../src/utils.ts","../../src/interpreter.ts","../../src/interpreters.ts","../../src/defaults.ts"],"sourcesContent":["import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return i < length - 1 ? undefined : value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n\nexport const hasOwn = Object.hasOwn ||\n  Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n","import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n","import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n  hasOwn,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => {\n    if (value == null) return Boolean(value) === node.value;\n    return hasOwn(value, field) === node.value;\n  };\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n","import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n"],"names":["includes","items","value","compare","i","length","isArrayAndNotNumericField","object","field","Array","isArray","Number","isNaN","getField","get","result","concat","testValueOrArray","test","node","context","some","v","hasOwn","Object","prototype","hasOwnProperty","call","bind","defaultGet","getObjectFieldCursor","path","dotIndex","lastIndexOf","slice","getObjectField","ITSELF","Error","String","indexOf","paths","split","undefined","getValueByPath","a","b","createJsInterpreter","operators","options","createInterpreter","or","interpret","condition","nor","and","every","not","eq","ne","lte","lt","gt","gte","exists","item","Boolean","mod","size","regex","within","nin","all","elemMatch","where","allInterpreters","in","interpreters"],"mappings":"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"}