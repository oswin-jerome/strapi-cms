---
title: API Reference
---

import {Steps, LinkCard, Card, CardGrid} from '@astrojs/starlight/components';

`jscodeshift` has around 25 APIs to help developers easily detect and transform any JS/TS code.

Generally, creating a codemod involves two main tasks: **detection** and **transformation**.

<Steps>
  1. **Detection**

      Detecting a specific pattern in a large codebase can be expensive, so this task is often divided into two passes.

      <Steps>
        1. **First pass**

            In the first pass, we perform an initial scope reduction of the AST nodes to significantly reduce the search space and produce a collection of AST nodes to process.
        2. **Second pass**

            In the second pass, we process and filter the nodes collection to pinpoint the specific AST nodes that need transformation.
      </Steps>

  2. **Transformation**

      Once we detect the desired nodes, we transform the AST and produce the modified code.
</Steps>

For jscodeshift, we have a set of APIs for each part of the codemod process (initial traversal, filtering, transformation), as detailed below. jscodeshift accepts `â€”parser` as argument. We can select from the list of parser that are currently supported, all those parsers should be compatible with `estree` spec and have same AST grammar. It's important to know the AST grammar for describing the nodes in the codemod.

Refer to the [`jscodeshift` node types](/build/ast-grammar/).

## Building jscodeshift codemods

<CardGrid>
  <LinkCard title="Core API" href="#core-api"/>
  <LinkCard title="Node Traversal APIs" href="#node-traversal-apis"/>
  <LinkCard title="Node Transformation APIs" href="#node-transformation-apis"/>
</CardGrid>

## Core API

### **`jscodeshift`**

The main function that returns the jscodeshift instance.

**Parameters**: `source` (String): The source code to be transformed.

**Example**:

```jsx
const jscodeshift = require('jscodeshift');
const sourceCode = `const a = 1;`;
const j = jscodeshift(sourceCode);
```

## Node Traversal APIs

Below are APIs that often used in the **initial scope reduction** phase ([source](https://github.com/facebook/jscodeshift/blob/4851fc8a01036868efb4cf9676f3e97836097376/src/collections/Node.js#L139)). The input is usually the whole file, and the output is a collection of nodes.

### **`find`**

Finds nodes that match the provided type.

**Parameters**: `type` (String or Function): The type of nodes to find.

**Example**:

```jsx
const variableDeclarations = j.find(j.VariableDeclaration);
```

### **`closestScope`**

Finds the closest enclosing scope of a node. Useful for determining the scope context of variables and functions.

**Example**:

```jsx
const closestScopes = j.find(j.Identifier).closestScope();
```

### **`closest`**

Finds the nearest parent node that matches the specified type. The child node must be obtained from a previous function call, such as find.

**Parameters**:`type` (String or Function): The type of ancestor to find.

```jsx
const closestFunction = j.find(j.Identifier).closest(j.FunctionDeclaration);
```

### **`getVariableDeclarators`**

Retrieves variable declarators from the current collection. If the callback function returns a falsy value, the element is not included in the result.

**Parameters**:`callback` (Function): A function that returns the name of the variable to find.

**Example**:

```jsx
const variableDeclarators = j.find(j.Identifier).getVariableDeclarators(path => path.value.name);
```

### **`findVariableDeclarators` ([source](https://github.com/facebook/jscodeshift/blob/main/src/collections/VariableDeclarator.js))**

Finds variable declarators by name.

**Parameters**: `name` (String): The 